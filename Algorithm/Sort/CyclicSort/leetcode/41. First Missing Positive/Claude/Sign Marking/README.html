<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>First Missing Positive - アルゴリズム解析</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: #333;
                line-height: 1.6;
            }

            .container {
                background: rgba(255, 255, 255, 0.95);
                padding: 30px;
                border-radius: 15px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
                backdrop-filter: blur(10px);
            }

            h1 {
                text-align: center;
                color: #4a5568;
                margin-bottom: 30px;
                font-size: 2.5em;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            }

            h2 {
                color: #2d3748;
                border-bottom: 3px solid #667eea;
                padding-bottom: 10px;
                margin-top: 40px;
                font-size: 1.8em;
            }

            .step {
                margin: 30px 0;
                padding: 25px;
                background: linear-gradient(135deg, #f7fafc, #edf2f7);
                border-radius: 12px;
                border-left: 6px solid #667eea;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.08);
                transition: transform 0.3s ease;
            }

            .step:hover {
                transform: translateY(-5px);
            }

            .array-container {
                display: flex;
                align-items: center;
                margin: 15px 0;
                flex-wrap: wrap;
                gap: 10px;
            }

            .array-label {
                font-weight: bold;
                color: #4a5568;
                min-width: 120px;
                font-size: 1.1em;
            }

            .array-box {
                width: 50px;
                height: 50px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 1.1em;
                border-radius: 8px;
                transition: all 0.3s ease;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }

            .original {
                background: linear-gradient(135deg, #4299e1, #2b77cb);
                color: white;
            }
            .normalized {
                background: linear-gradient(135deg, #48bb78, #38a169);
                color: white;
            }
            .marked {
                background: linear-gradient(135deg, #ed8936, #dd6b20);
                color: white;
            }
            .positive {
                background: linear-gradient(135deg, #e53e3e, #c53030);
                color: white;
            }
            .negative {
                background: linear-gradient(135deg, #667eea, #553c9a);
                color: white;
            }

            .index {
                font-size: 0.8em;
                color: #666;
                margin-top: 5px;
            }

            .explanation {
                background: #f0fff4;
                border: 2px solid #68d391;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
                font-size: 1.05em;
            }

            .code-block {
                background: #2d3748;
                color: #e2e8f0;
                padding: 20px;
                border-radius: 10px;
                font-family: 'Courier New', monospace;
                overflow-x: auto;
                margin: 15px 0;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            }

            .highlight {
                background: rgba(255, 235, 59, 0.3);
                padding: 2px 4px;
                border-radius: 4px;
                font-weight: bold;
            }

            .complexity {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                padding: 20px;
                border-radius: 12px;
                margin: 25px 0;
                text-align: center;
                font-size: 1.1em;
                font-weight: bold;
            }

            .arrow {
                font-size: 2em;
                color: #667eea;
                text-align: center;
                margin: 10px 0;
            }

            button {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 25px;
                cursor: pointer;
                font-size: 1em;
                font-weight: bold;
                transition: all 0.3s ease;
                margin: 10px 5px;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }

            button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
            }

            .demo-controls {
                text-align: center;
                margin: 30px 0;
                padding: 20px;
                background: #f8f9fa;
                border-radius: 10px;
            }

            .step-counter {
                background: #667eea;
                color: white;
                border-radius: 50%;
                width: 40px;
                height: 40px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                margin-right: 15px;
                font-size: 1.2em;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>🔍 First Missing Positive アルゴリズム解析</h1>

            <div class="explanation">
                <strong>問題：</strong
                >ソートされていない整数配列から、存在しない最小の正の整数を見つける<br />
                <strong>制約：</strong>O(n)時間、O(1)空間で実装する
            </div>

            <div class="demo-controls">
                <h3>📊 デモンストレーション</h3>
                <button onclick="runExample([3, 4, -1, 1])">例1: [3, 4, -1, 1]</button>
                <button onclick="runExample([1, 2, 0])">例2: [1, 2, 0]</button>
                <button onclick="runExample([7, 8, 9, 11, 12])">例3: [7, 8, 9, 11, 12]</button>
                <button onclick="runExample([1, 2, 3, 4])">例4: [1, 2, 3, 4]</button>
            </div>

            <div id="demo-area"></div>

            <h2>🔧 アルゴリズムの詳細解説</h2>

            <div class="step">
                <div class="step-counter">1</div>
                <h3>Step 1: 値の正規化 (Normalization)</h3>
                <div class="code-block">
                    for (let i = 0; i < n; i++) { if (nums[i] <= 0 || nums[i] > n) { nums[i] = n +
                    1; // 範囲外の値を統一 } }
                </div>
                <div class="explanation">
                    <strong>目的：</strong>1からnの範囲外の値（0以下、n+1以上）をn+1に統一<br />
                    <strong>理由：</strong
                    >最小の欠けている正の整数は必ず1〜(n+1)の範囲にあるため、範囲外の値は無視できる
                </div>
            </div>

            <div class="step">
                <div class="step-counter">2</div>
                <h3>Step 2: 存在マーキング (Marking)</h3>
                <div class="code-block">
                    for (let i = 0; i < n; i++) { const val = Math.abs(nums[i]); if (val <= n) {
                    nums[val - 1] = -Math.abs(nums[val - 1]); } }
                </div>
                <div class="explanation">
                    <strong>目的：</strong>各数値の存在を配列の符号で記録<br />
                    <strong>仕組み：</strong
                    >値xが存在する場合、インデックス(x-1)の値を負にマーク<br />
                    <strong>ポイント：</strong>絶対値を使うことで元の値を保持しながらマーキング
                </div>
            </div>

            <div class="step">
                <div class="step-counter">3</div>
                <h3>Step 3: 結果の検出 (Detection)</h3>
                <div class="code-block">
                    for (let i = 0; i < n; i++) { if (nums[i] > 0) { return i + 1; //
                    最初の正の値のインデックス+1 } } return n + 1; // 全て存在する場合
                </div>
                <div class="explanation">
                    <strong>目的：</strong>最初の正の値を見つけて答えを返す<br />
                    <strong>論理：</strong>インデックスiが正 → 値(i+1)が存在しない → 答えは(i+1)<br />
                    <strong>特殊ケース：</strong>全て負の場合は1〜nが全て存在するため答えは(n+1)
                </div>
            </div>

            <h2>⚡ 計算量解析</h2>

            <div class="complexity">
                <div>⏱️ 時間複雑度: <span class="highlight">O(n)</span></div>
                <div style="margin-top: 10px">
                    💾 空間複雑度: <span class="highlight">O(1)</span>
                </div>
            </div>

            <div class="explanation">
                <strong>時間複雑度の内訳：</strong><br />
                • Step 1: O(n) - 全要素を1回スキャン<br />
                • Step 2: O(n) - 全要素を1回スキャン<br />
                • Step 3: O(n) - 最悪の場合全要素をスキャン<br />
                合計: O(n) + O(n) + O(n) = O(n)<br /><br />

                <strong>空間複雑度の説明：</strong><br />
                入力配列以外に追加のデータ構造を使用せず、定数個の変数のみ使用するためO(1)
            </div>

            <h2>🎯 アルゴリズムの核心アイデア</h2>

            <div class="step">
                <h3>🔑 Key Insight: 配列自体をハッシュテーブルとして活用</h3>
                <div class="explanation">
                    <strong>問題：</strong>O(1)空間制約でどうやって存在チェックを行う？<br />
                    <strong>解決策：</strong>配列のインデックスと値の対応関係を利用<br />
                    <strong>マッピング：</strong>値x → インデックス(x-1)の符号でマーク<br />
                    <strong>利点：</strong>追加メモリ不要、O(1)でアクセス可能
                </div>
            </div>
        </div>

        <script>
            function runExample(inputArray) {
                const demoArea = document.getElementById('demo-area');
                const nums = [...inputArray]; // コピーを作成
                const n = nums.length;

                let html = `
                <div class="step">
                    <h3>🚀 実行例: [${inputArray.join(', ')}]</h3>
                    <div class="array-container">
                        <div class="array-label">初期配列:</div>
                        ${nums
                            .map(
                                (num, i) => `
                            <div>
                                <div class="array-box original">${num}</div>
                                <div class="index">i=${i}</div>
                            </div>
                        `,
                            )
                            .join('')}
                    </div>
            `;

                // Step 1: 正規化
                const normalizedNums = [...nums];
                for (let i = 0; i < n; i++) {
                    if (normalizedNums[i] <= 0 || normalizedNums[i] > n) {
                        normalizedNums[i] = n + 1;
                    }
                }

                html += `
                    <div class="arrow">⬇️</div>
                    <div class="array-container">
                        <div class="array-label">Step 1 正規化:</div>
                        ${normalizedNums
                            .map(
                                (num, i) => `
                            <div>
                                <div class="array-box ${num === n + 1 ? 'normalized' : 'original'}">${num}</div>
                                <div class="index">i=${i}</div>
                            </div>
                        `,
                            )
                            .join('')}
                    </div>
            `;

                // Step 2: マーキング
                const markedNums = [...normalizedNums];
                const markingSteps = [];

                for (let i = 0; i < n; i++) {
                    const val = Math.abs(markedNums[i]);
                    if (val <= n) {
                        const targetIndex = val - 1;
                        const oldValue = markedNums[targetIndex];
                        markedNums[targetIndex] = -Math.abs(markedNums[targetIndex]);
                        markingSteps.push({
                            i,
                            val,
                            targetIndex,
                            oldValue,
                            newValue: markedNums[targetIndex],
                        });
                    }
                }

                html += `
                    <div class="arrow">⬇️</div>
                    <div class="array-container">
                        <div class="array-label">Step 2 マーキング:</div>
                        ${markedNums
                            .map(
                                (num, i) => `
                            <div>
                                <div class="array-box ${num < 0 ? 'negative' : 'positive'}">${num}</div>
                                <div class="index">i=${i}</div>
                            </div>
                        `,
                            )
                            .join('')}
                    </div>
            `;

                // マーキングの詳細
                html += `<div class="explanation"><strong>マーキングの詳細:</strong><br>`;
                markingSteps.forEach((step) => {
                    html += `値${step.val}が存在 → インデックス${step.targetIndex}を負にマーク (${step.oldValue} → ${step.newValue})<br>`;
                });
                html += `</div>`;

                // Step 3: 結果
                let result = n + 1;
                let resultIndex = -1;
                for (let i = 0; i < n; i++) {
                    if (markedNums[i] > 0) {
                        result = i + 1;
                        resultIndex = i;
                        break;
                    }
                }

                html += `
                    <div class="arrow">⬇️</div>
                    <div class="array-container">
                        <div class="array-label">Step 3 結果検出:</div>
                        ${markedNums
                            .map(
                                (num, i) => `
                            <div>
                                <div class="array-box ${i === resultIndex ? 'marked' : num < 0 ? 'negative' : 'positive'}">${num}</div>
                                <div class="index">i=${i}</div>
                            </div>
                        `,
                            )
                            .join('')}
                    </div>
                    
                    <div class="explanation">
                        <strong>🎯 答え: ${result}</strong><br>
                        ${
                            resultIndex !== -1
                                ? `インデックス${resultIndex}が最初の正の値 → 値${result}が欠けている`
                                : '全ての値が負 → 1からnまで全て存在 → 答えはn+1'
                        }
                    </div>
                </div>
            `;

                demoArea.innerHTML = html;
            }

            // 初期表示
            runExample([3, 4, -1, 1]);
        </script>
    </body>
</html>
