<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>雨水トラップアルゴリズム解析</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                margin: 0;
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                color: #333;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                background: rgba(255, 255, 255, 0.95);
                border-radius: 20px;
                padding: 30px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            }

            h1 {
                text-align: center;
                color: #2c3e50;
                margin-bottom: 30px;
                font-size: 2.5em;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            }

            .section {
                margin: 30px 0;
                padding: 25px;
                background: linear-gradient(145deg, #f8f9ff, #e6f3ff);
                border-radius: 15px;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
                border-left: 5px solid #3498db;
            }

            .chart-container {
                background: white;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
                box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
                position: relative;
                overflow: hidden;
            }

            .chart-container::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 4px;
                background: linear-gradient(90deg, #3498db, #2ecc71, #f39c12, #e74c3c);
            }

            .bar {
                display: inline-block;
                margin: 2px;
                position: relative;
                vertical-align: bottom;
                border-radius: 4px 4px 0 0;
                transition: all 0.3s ease;
            }

            .bar:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            }

            .height-bar {
                background: linear-gradient(135deg, #34495e, #2c3e50);
            }

            .water {
                background: linear-gradient(135deg, #3498db, #2980b9);
                opacity: 0.8;
                animation: wave 2s ease-in-out infinite;
            }

            @keyframes wave {
                0%,
                100% {
                    opacity: 0.8;
                }

                50% {
                    opacity: 0.6;
                }
            }

            .pointer {
                position: absolute;
                bottom: -30px;
                transform: translateX(-50%);
                font-weight: bold;
                padding: 5px 10px;
                border-radius: 15px;
                font-size: 12px;
            }

            .left-pointer {
                background: linear-gradient(135deg, #e74c3c, #c0392b);
                color: white;
            }

            .right-pointer {
                background: linear-gradient(135deg, #2ecc71, #27ae60);
                color: white;
            }

            .values {
                margin: 20px 0;
                padding: 15px;
                background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
                border-radius: 10px;
                font-family: 'Courier New', monospace;
            }

            .step-info {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 15px;
                margin: 20px 0;
            }

            .info-card {
                padding: 15px;
                border-radius: 10px;
                text-align: center;
                color: white;
                font-weight: bold;
                transition: transform 0.3s ease;
            }

            .info-card:hover {
                transform: scale(1.05);
            }

            .left-info {
                background: linear-gradient(135deg, #e74c3c, #c0392b);
            }

            .right-info {
                background: linear-gradient(135deg, #2ecc71, #27ae60);
            }

            .water-info {
                background: linear-gradient(135deg, #3498db, #2980b9);
            }

            .controls {
                text-align: center;
                margin: 20px 0;
            }

            button {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                border: none;
                padding: 12px 25px;
                margin: 5px;
                border-radius: 25px;
                cursor: pointer;
                font-size: 14px;
                font-weight: bold;
                transition: all 0.3s ease;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            }

            button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            }

            button:active {
                transform: translateY(0);
            }

            .algorithm-explanation {
                background: linear-gradient(135deg, #f8f9fa, #e9ecef);
                border-radius: 15px;
                padding: 25px;
                margin: 20px 0;
                border-left: 5px solid #6c5ce7;
            }

            .complexity {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                margin: 20px 0;
            }

            .complexity-card {
                padding: 20px;
                border-radius: 15px;
                text-align: center;
                color: white;
                font-size: 1.2em;
            }

            .time-complexity {
                background: linear-gradient(135deg, #fd79a8, #e84393);
            }

            .space-complexity {
                background: linear-gradient(135deg, #00b894, #00a085);
            }
        </style>
    </head>

    <body>
        <div class="container">
            <h1>🌧️ 雨水トラップアルゴリズム解析</h1>

            <div class="section">
                <h2>📊 アルゴリズムの可視化</h2>
                <div class="chart-container" id="chart">
                    <!-- ここに動的にチャートが生成されます -->
                </div>
                <div class="controls">
                    <button onclick="resetAnimation()">🔄 リセット</button>
                    <button onclick="nextStep()">➡️ 次のステップ</button>
                    <button onclick="runFullAnimation()">🎬 全体実行</button>
                    <button onclick="changeExample()">📝 例を変更</button>
                </div>
                <div class="step-info">
                    <div class="info-card left-info">
                        <div>左ポインタ</div>
                        <div id="leftPos">0</div>
                    </div>
                    <div class="info-card right-info">
                        <div>右ポインタ</div>
                        <div id="rightPos">11</div>
                    </div>
                    <div class="info-card water-info">
                        <div>累積水量</div>
                        <div id="waterTotal">0</div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>📈 ステップバイステップ解析</h2>
                <div id="stepDetails">
                    <!-- ここに各ステップの詳細が表示されます -->
                </div>
            </div>
            Ï
            <div class="section">
                <h2>🧮 アルゴリズムの詳細</h2>
                <div class="algorithm-explanation">
                    <h3>Two Pointer Approach の原理</h3>
                    <p>
                        <strong>核心概念:</strong>
                        各位置で水がトラップできる量は、その位置の左側と右側の最大高度の最小値から現在の高度を引いた値です。
                    </p>

                    <h4>🔍 処理の流れ</h4>
                    <ol>
                        <li><strong>初期化:</strong> 左右のポインタを配列の両端に設置</li>
                        <li><strong>比較:</strong> 左右の高度を比較し、低い方を処理対象とする</li>
                        <li><strong>更新:</strong> 最大高度を更新するか、水量を計算して加算</li>
                        <li><strong>移動:</strong> 処理したポインタを中央に向かって移動</li>
                        <li><strong>終了:</strong> 左右のポインタが交差するまで繰り返し</li>
                    </ol>

                    <h4>💡 なぜこの方法が正しいのか？</h4>
                    <p>
                        低い方の最大高度を基準にすることで、確実に水がトラップできる量を計算できます。高い方の側には必ずそれ以上の高度があることが保証されているため、低い方の制約が決定的になります。
                    </p>
                </div>
            </div>

            <div class="section">
                <h2>⚡ 計算量解析</h2>
                <div class="complexity">
                    <div class="complexity-card time-complexity">
                        <div>時間計算量</div>
                        <div><strong>O(n)</strong></div>
                        <small>配列を一度だけ走査</small>
                    </div>
                    <div class="complexity-card space-complexity">
                        <div>空間計算量</div>
                        <div><strong>O(1)</strong></div>
                        <small>定数個の変数のみ</small>
                    </div>
                </div>

                <div class="algorithm-explanation">
                    <h3>🎯 最適化のポイント</h3>
                    <ul>
                        <li>
                            <strong>単一パス:</strong>
                            配列を一度だけ走査することで最小の時間計算量を実現
                        </li>
                        <li><strong>定数空間:</strong> 追加の配列を使わず、数個の変数のみで解決</li>
                        <li><strong>早期終了:</strong> 無駄な計算を避け、効率的な処理</li>
                        <li>
                            <strong>キャッシュ効率:</strong>
                            線形アクセスパターンでCPUキャッシュを活用
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <script>
            let examples = [
                {
                    name: '例1: 基本パターン',
                    data: [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1],
                    expected: 6,
                },
                {
                    name: '例2: 複雑なパターン',
                    data: [4, 2, 0, 3, 2, 5],
                    expected: 9,
                },
                {
                    name: '例3: 単調増加',
                    data: [1, 2, 3, 4, 5],
                    expected: 0,
                },
                {
                    name: '例4: 単調減少',
                    data: [5, 4, 3, 2, 1],
                    expected: 0,
                },
            ];

            let currentExample = 0;
            let currentStep = 0;
            let animationSteps = [];
            let isAnimating = false;

            function generateSteps(height) {
                let steps = [];
                let left = 0;
                let right = height.length - 1;
                let leftMax = 0;
                let rightMax = 0;
                let water = 0;
                let processedWater = new Array(height.length).fill(0);

                steps.push({
                    left,
                    right,
                    leftMax,
                    rightMax,
                    water,
                    processedWater: [...processedWater],
                    action: '🚀 初期化',
                    description: `配列の両端にポインタを設置`,
                    detail: `左ポインタ(L) = ${left}, 右ポインタ(R) = ${right}`,
                    explanation:
                        'Two Pointerアプローチの開始点です。左右から同時に処理することで効率的に解を求めます。',
                });

                while (left < right) {
                    if (height[left] < height[right]) {
                        // 左側を処理
                        if (height[left] >= leftMax) {
                            leftMax = height[left];
                            steps.push({
                                left,
                                right,
                                leftMax,
                                rightMax,
                                water,
                                processedWater: [...processedWater],
                                action: '📈 左側最大値更新',
                                description: `位置${left}で左側最大高度を更新`,
                                detail: `height[${left}] = ${height[left]} ≥ leftMax(${leftMax - height[left] || 0}) → leftMax = ${leftMax}`,
                                explanation: `現在の高度が左側の最大値以上なので、左側最大値を更新します。この位置では水はトラップされません。`,
                            });
                        } else {
                            let trapped = leftMax - height[left];
                            water += trapped;
                            processedWater[left] = trapped;
                            steps.push({
                                left,
                                right,
                                leftMax,
                                rightMax,
                                water,
                                processedWater: [...processedWater],
                                action: '💧 左側で水をトラップ',
                                description: `位置${left}で${trapped}単位の水をトラップ`,
                                detail: `leftMax(${leftMax}) - height[${left}](${height[left]}) = ${trapped}単位`,
                                explanation: `左側最大値の方が現在の高度より高いため、その差分だけ水がトラップされます。右側には必ずleftMax以上の高さがあることが保証されています。`,
                            });
                        }
                        left++;
                    } else {
                        // 右側を処理
                        if (height[right] >= rightMax) {
                            rightMax = height[right];
                            steps.push({
                                left,
                                right,
                                leftMax,
                                rightMax,
                                water,
                                processedWater: [...processedWater],
                                action: '📈 右側最大値更新',
                                description: `位置${right}で右側最大高度を更新`,
                                detail: `height[${right}] = ${height[right]} ≥ rightMax(${rightMax - height[right] || 0}) → rightMax = ${rightMax}`,
                                explanation: `現在の高度が右側の最大値以上なので、右側最大値を更新します。この位置では水はトラップされません。`,
                            });
                        } else {
                            let trapped = rightMax - height[right];
                            water += trapped;
                            processedWater[right] = trapped;
                            steps.push({
                                left,
                                right,
                                leftMax,
                                rightMax,
                                water,
                                processedWater: [...processedWater],
                                action: '💧 右側で水をトラップ',
                                description: `位置${right}で${trapped}単位の水をトラップ`,
                                detail: `rightMax(${rightMax}) - height[${right}](${height[right]}) = ${trapped}単位`,
                                explanation: `右側最大値の方が現在の高度より高いため、その差分だけ水がトラップされます。左側には必ずrightMax以上の高さがあることが保証されています。`,
                            });
                        }
                        right--;
                    }
                }

                steps.push({
                    left,
                    right,
                    leftMax,
                    rightMax,
                    water,
                    processedWater: [...processedWater],
                    action: '✅ 完了',
                    description: `アルゴリズム完了！総水量: ${water}単位`,
                    detail: `左右のポインタが交差(L=${left}, R=${right})したため処理終了`,
                    explanation: `全ての位置を処理し終わりました。最終的に${water}単位の雨水がトラップされました。`,
                });

                return steps;
            }

            function renderChart(step = null) {
                const chart = document.getElementById('chart');
                const height = examples[currentExample].data;
                const maxHeight = Math.max(...height);
                const barWidth = Math.max(30, Math.min(60, 700 / height.length));

                let html =
                    '<div style="position: relative; display: flex; align-items: end; justify-content: center; height: ' +
                    (maxHeight * 25 + 80) +
                    'px; padding: 20px 0;">';

                // 水の高さを事前計算
                let waterHeights = new Array(height.length).fill(0);
                if (step) {
                    for (let i = 0; i < height.length; i++) {
                        if (step.processedWater && step.processedWater[i] !== undefined) {
                            waterHeights[i] = step.processedWater[i];
                        }
                    }
                }

                for (let i = 0; i < height.length; i++) {
                    const barHeight = height[i] * 25;
                    const waterHeight = waterHeights[i] * 25;

                    // 現在処理中の位置をハイライト
                    let highlightClass = '';
                    if (step && (i === step.left || i === step.right)) {
                        highlightClass = 'style="box-shadow: 0 0 15px rgba(255, 193, 7, 0.8);"';
                    }

                    html += `
                    <div style="position: relative; margin: 0 2px; display: flex; flex-direction: column; align-items: center;">
                        <div style="position: absolute; top: -25px; font-size: 11px; color: #666; font-weight: bold;">${height[i]}</div>
                        <div class="bar height-bar" ${highlightClass} style="width: ${barWidth}px; height: ${barHeight}px; position: relative; z-index: 1;"></div>
                        ${waterHeight > 0 ? `<div class="bar water" style="position: absolute; bottom: 20px; width: ${barWidth}px; height: ${waterHeight}px; z-index: 2;"></div>` : ''}
                        <div style="position: absolute; bottom: -15px; font-size: 10px; font-weight: bold; color: #333;">${i}</div>
                `;

                    if (step && i === step.left && step.left <= step.right) {
                        html += `<div class="pointer left-pointer" style="bottom: -50px;">L:${step.left}</div>`;
                    }
                    if (step && i === step.right && step.left <= step.right) {
                        html += `<div class="pointer right-pointer" style="bottom: -50px;">R:${step.right}</div>`;
                    }

                    html += '</div>';
                }

                html += '</div>';
                chart.innerHTML = html;

                // 値の更新
                if (step) {
                    document.getElementById('leftPos').textContent = step.left;
                    document.getElementById('rightPos').textContent = step.right;
                    document.getElementById('waterTotal').textContent = step.water;

                    // ステップ詳細の更新
                    updateStepDetails(step, currentStep);
                }
            }

            function updateStepDetails(step, stepIndex) {
                const stepDetails = document.getElementById('stepDetails');
                const height = examples[currentExample].data;

                // 現在の配列状態を視覚的に表示
                let arrayDisplay = '';
                for (let i = 0; i < height.length; i++) {
                    let cellStyle =
                        'padding: 8px; border: 2px solid #ddd; margin: 2px; display: inline-block; min-width: 30px; text-align: center; border-radius: 5px;';

                    if (i === step.left && step.left <= step.right) {
                        cellStyle +=
                            'background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; font-weight: bold;';
                    } else if (i === step.right && step.left <= step.right) {
                        cellStyle +=
                            'background: linear-gradient(135deg, #2ecc71, #27ae60); color: white; font-weight: bold;';
                    } else if (step.processedWater && step.processedWater[i] > 0) {
                        cellStyle +=
                            'background: linear-gradient(135deg, #3498db, #2980b9); color: white;';
                    } else {
                        cellStyle += 'background: #f8f9fa;';
                    }

                    arrayDisplay += `<span style="${cellStyle}">${height[i]}</span>`;
                }

                // 水の量の表示
                let waterDisplay = '';
                if (step.processedWater) {
                    for (let i = 0; i < height.length; i++) {
                        let cellStyle =
                            'padding: 8px; border: 2px solid #ddd; margin: 2px; display: inline-block; min-width: 30px; text-align: center; border-radius: 5px;';

                        if (step.processedWater[i] > 0) {
                            cellStyle +=
                                'background: linear-gradient(135deg, #3498db, #2980b9); color: white; font-weight: bold;';
                            waterDisplay += `<span style="${cellStyle}">${step.processedWater[i]}</span>`;
                        } else {
                            cellStyle += 'background: #ecf0f1; color: #95a5a6;';
                            waterDisplay += `<span style="${cellStyle}">0</span>`;
                        }
                    }
                }

                stepDetails.innerHTML = `
                <div class="algorithm-explanation">
                    <h3>ステップ ${stepIndex + 1}: ${step.action}</h3>
                    <p><strong>🎯 処理内容:</strong> ${step.description}</p>
                    <p><strong>📊 詳細:</strong> ${step.detail}</p>
                    <p><strong>💡 解説:</strong> ${step.explanation}</p>
                    
                    <div style="margin: 20px 0;">
                        <h4>📋 配列の状態</h4>
                        <div style="margin: 10px 0;">
                            <strong>高度:</strong><br>
                            ${arrayDisplay}
                        </div>
                        <div style="margin: 10px 0;">
                            <strong>水量:</strong><br>
                            ${waterDisplay}
                        </div>
                    </div>
                    
                    <div class="values">
                        <strong>📈 現在の変数状態:</strong><br>
                        🔴 Left = ${step.left} (${step.left < height.length ? `高度: ${height[step.left]}` : '範囲外'})<br>
                        🟢 Right = ${step.right} (${step.right >= 0 ? `高度: ${height[step.right]}` : '範囲外'})<br>
                        📊 LeftMax = ${step.leftMax}<br>
                        📊 RightMax = ${step.rightMax}<br>
                        💧 累積水量 = ${step.water} 単位
                    </div>
                    
                    <div style="background: linear-gradient(135deg, #fff3cd, #ffeaa7); padding: 15px; border-radius: 10px; margin-top: 15px; border-left: 4px solid #f39c12;">
                        <strong>🤔 なぜこの処理？</strong><br>
                        ${getStepRationale(step, height)}
                    </div>
                </div>
            `;
            }

            function getStepRationale(step, height) {
                if (step.action.includes('初期化')) {
                    return 'Two Pointerアプローチでは、配列の両端から同時に処理を開始します。これにより O(n) の時間計算量で解を求められます。';
                } else if (step.action.includes('左側最大値更新')) {
                    return `左側の現在位置の高度(${height[step.left]})が、これまでの左側最大値以上なので、最大値を更新します。壁が高くなったので、水はここでは溜まりません。`;
                } else if (step.action.includes('右側最大値更新')) {
                    return `右側の現在位置の高度(${height[step.right]})が、これまでの右側最大値以上なので、最大値を更新します。壁が高くなったので、水はここでは溜まりません。`;
                } else if (step.action.includes('左側で水をトラップ')) {
                    return `左側の高度(${height[step.left]})が左側最大値(${step.leftMax})より低いため、差分の水がトラップされます。右側にはより高い壁があることが保証されているので、確実に水が溜まります。`;
                } else if (step.action.includes('右側で水をトラップ')) {
                    return `右側の高度(${height[step.right]})が右側最大値(${step.rightMax})より低いため、差分の水がトラップされます。左側にはより高い壁があることが保証されているので、確実に水が溜まります。`;
                } else if (step.action.includes('完了')) {
                    return `左右のポインタが交差したため、全ての位置の処理が完了しました。各位置で確実にトラップできる水の量を累積した結果が最終答えです。`;
                }
                return '';
            }

            function resetAnimation() {
                currentStep = 0;
                animationSteps = generateSteps(examples[currentExample].data);
                renderChart(animationSteps[0]);
                isAnimating = false;
            }

            function nextStep() {
                if (currentStep < animationSteps.length - 1) {
                    currentStep++;
                    renderChart(animationSteps[currentStep]);
                }
            }

            function runFullAnimation() {
                if (isAnimating) return;
                isAnimating = true;

                let step = 0;
                const interval = setInterval(() => {
                    renderChart(animationSteps[step]);
                    step++;

                    if (step >= animationSteps.length) {
                        clearInterval(interval);
                        isAnimating = false;
                    }
                }, 1000);
            }

            function changeExample() {
                currentExample = (currentExample + 1) % examples.length;
                currentStep = 0;
                animationSteps = generateSteps(examples[currentExample].data);
                renderChart(animationSteps[0]);

                // 例の情報を更新
                updateExampleInfo();
            }

            function updateExampleInfo() {
                const chart = document.getElementById('chart');

                // 既存の例情報を削除
                const existingInfo = chart.parentNode.querySelector('.example-info');
                if (existingInfo) {
                    existingInfo.remove();
                }

                // 新しい例情報を表示
                const exampleInfo = document.createElement('div');
                exampleInfo.className = 'values example-info';
                exampleInfo.style.marginBottom = '20px';
                exampleInfo.innerHTML = `
                <strong>${examples[currentExample].name}</strong><br>
                📊 配列: [${examples[currentExample].data.join(', ')}]<br>
                🎯 期待値: ${examples[currentExample].expected}単位<br>
                📏 配列長: ${examples[currentExample].data.length}
            `;
                chart.parentNode.insertBefore(exampleInfo, chart);
            }

            // 初期化
            window.onload = function () {
                animationSteps = generateSteps(examples[currentExample].data);
                updateExampleInfo();
                renderChart(animationSteps[0]);
            };
        </script>
    </body>
</html>
