では、`mod P` 上の逆元を **繰り返し二乗法**（フェルマーの小定理に基づく）で求める処理について、**図とステップごとの解析付きで詳しく説明**します。

---

## 🎯 問題設定の復習

### 与えられたもの：

* 素数 `P`
* 数列 `q_1, q_2, ..., q_Q`（各 q\_i < P）

### 求めたいもの：

* 各 `q_i` に対して、mod P 上の逆元 `q_i^{-1}` を求める。

---

## ✅ 解法概要

### ✅ フェルマーの小定理の活用

もし `P` が素数なら、任意の `a`（0 < a < P）に対して：

$$
a^{P-1} \equiv 1 \pmod{P} \Rightarrow a^{-1} \equiv a^{P-2} \pmod{P}
$$

これを使って、逆元は次のように求まります：

$$
q_i^{-1} \equiv q_i^{P-2} \mod P
$$

---

## 🔁 繰り返し二乗法の具体例（図付き）

### 例：

* $a = 3$, $P = 5$
* 求めるのは：

$$
3^{-1} \mod 5 = 3^{3} \mod 5
$$

---

### ▶️ Step-by-Step 計算

繰り返し二乗法は指数を2進数で分解して高速に指数計算する方法です。

---

### ❶ 指数の2進数表現

指数 $e = 3$ を2進数で表す：

```
e = 3 = (011)_2
```

---

### ❷ ステップごとの状態

| Step | e (bit) | result               | base                 | 計算内容                      |
| ---- | ------- | -------------------- | -------------------- | ------------------------- |
| 0    | 1       | 1                    | 3                    | 初期値                       |
| 1    | 1       | 1×3 = 3 (mod 5) = 3  | 3×3 = 9 (mod 5) = 4  | 1ビット目が1 → result \*= base |
| 2    | 1       | 3                    | 4                    | base = 4                  |
| 3    | 0       | 3×4 = 12 (mod 5) = 2 | 4×4 = 16 (mod 5) = 1 | 2ビット目が1 → result \*= base |

最終結果：

$$
3^{-1} \mod 5 = 2
$$

---

### 📊 図解

```
指数: 3 → 011（二進数）

     exponent bits: 0b011
            ↑
            |
            └── 右から読み取り（LSB -> MSB）

  [bit 0] → result = 1 × 3 = 3
            base = 3 × 3 = 9 % 5 = 4

  [bit 1] → result = 3 × 4 = 12 % 5 = 2
            base = 4 × 4 = 16 % 5 = 1

完成: result = 2 → 3 の逆元
```

---

## 🧠 全体の処理フロー（構造図）

```
main()
├── 入力: P, [q_1, q_2, ..., q_Q]
├── Solution().modularInverses(P, nums)
│   ├── 各 q_i に対して:
│   │   └── modPow(q_i, P - 2, P)
│   │       ├── while exp > 0:
│   │       │   ├── if exp % 2 == 1 → result *= base
│   │       │   ├── base *= base
│   │       │   └── exp //= 2
│   └── 結果リスト return
└── 出力: q_i の逆元（空白区切り）
```

---

## ⏱ 時間・空間計算量の可視化

### 計算量：

* 各逆元計算：`O(log P)`
* 全体：`O(Q log P)`

```
時間 complexity: Q × log(P)

Q = 200000  ← 最大
P ≈ 2×10^9 ← 約31bit
    ↓
最大ループ回数 ≈ 200000 × 31 = 約620万回
```

---

## ✅ 補足：逆元の正当性確認

例えば、出力された値が正しい逆元かは以下で確認できます：

```python
# 例: q = 3, P = 5
(3 * 2) % 5 == 1  # True → 正しい逆元
```

---

## 🧩 まとめ

* `modPow()` は **指数を2進法で分解** → **各bitごとに累積積**
* `q_i^{-1} ≡ q_i^{P−2} mod P` を効率的に計算
* 大規模データでも `O(log P)` の効率で処理可能
* メモリ消費は結果リストと数個の変数のみ

---

他の例（大きな素数や複数クエリ）での動作確認や、**拡張ユークリッド互除法版**での解法と比較した図も必要でしたら対応可能です。
