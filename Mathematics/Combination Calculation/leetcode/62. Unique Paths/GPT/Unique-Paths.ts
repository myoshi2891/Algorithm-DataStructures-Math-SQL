// ## 1. 問題の分析

// ### 競技プログラミング視点

// * **入力**: `m` 行 × `n` 列 (1 ≤ m,n ≤ 100)
// * **出力**: 左上から右下までに移動する経路数（右または下のみ移動可能）
// * **制約**: 答え ≤ 2×10^9 → 32bit int に収まる
// * **最適解**: 組み合わせ数 `C(m+n-2, m-1)` を逐次計算する方法 → O(min(m,n)) 時間、O(1) 空間

// ### 業務開発視点

// * **型安全性**: m, n が整数かつ制約範囲内であることを型＋実行時チェック
// * **保守性**: 数学的アプローチ（組み合わせ計算）はシンプルで再利用しやすい
// * **エラーハンドリング**: 型違反、範囲外入力を検出して例外を投げる

// ### TypeScript特有の考慮点

// * **型推論**で関数利用時の型補完を効率化
// * **readonly引数**で副作用防止
// * **strictモード**で null/undefined を排除
// * **ジェネリクス**は本問題では不要だが、再利用性を考えれば適用可能

// ---

// ## 2. アルゴリズムアプローチ比較

// | アプローチ        | 時間計算量        | 空間計算量 | TS実装コスト | 型安全性 | 可読性 | 備考           |
// | ------------ | ------------ | ----- | ------- | ---- | --- | ------------ |
// | DP (2D配列)    | O(mn)        | O(mn) | 中       | 高    | 高   | わかりやすいがメモリ無駄 |
// | DP (1D配列最適化) | O(mn)        | O(n)  | 中       | 中    | 中   | 高速だがやや複雑     |
// | 組み合わせ数 (数学的) | O(min(m, n)) | O(1)  | 低       | 高    | 高   | 最速・最省メモリ     |

// ---

// ## 3. 実装方針

// * **選択したアプローチ**: 組み合わせ計算 `C(m+n-2, m-1)`
// * **理由**:

//   * 最小の計算量・空間量
//   * JavaScript の浮動小数誤差を避けるため、逐次掛け算・割り算で精度確保
//   * TypeScript の型安全性で入力制約を明示
// * **TS特有の最適化ポイント**:

//   * `number` 型を使用（問題制約内で安全）
//   * 型ガードで入力を検証
//   * `readonly` 修飾で副作用を防止

// ---

// ## 4. コード実装

// ```typescript
/**
 * グリッド上のユニークパス数を計算する
 * @param m - グリッドの行数 (1 <= m <= 100)
 * @param n - グリッドの列数 (1 <= n <= 100)
 * @returns 経路数 (2 * 10^9 以下の整数)
 * @throws {TypeError} m, n が整数でない場合
 * @throws {RangeError} m, n が範囲外の場合
 * @complexity Time: O(min(m, n)), Space: O(1)
 */
export function uniquePaths(m: number, n: number): number {
    // 入力検証
    if (!Number.isInteger(m) || !Number.isInteger(n)) {
        throw new TypeError('Inputs must be integers');
    }
    if (m < 1 || n < 1 || m > 100 || n > 100) {
        throw new RangeError('Inputs must satisfy 1 <= m, n <= 100');
    }

    // 組み合わせ計算: C(m+n-2, m-1)
    const totalSteps = m + n - 2;
    const k = Math.min(m - 1, n - 1);
    let result = 1;

    for (let i = 1; i <= k; i++) {
        result = (result * (totalSteps - k + i)) / i;
    }

    return Math.round(result); // 浮動小数誤差対策
}

// ---- 使用例 ----
console.log(uniquePaths(3, 7)); // 28
console.log(uniquePaths(3, 2)); // 3
// ```

// ---

// ## 5. 計算量まとめ

// * **時間計算量**: O(min(m, n)) （最大でも100回程度のループ）
// * **空間計算量**: O(1)
// * **コンパイル時検証**: strictモードにより型安全性を担保
// * **実測**: 入力最大ケースでも瞬時に計算可能
// * **TSオーバーヘッド**: 型チェック・コンパイルのみ。実行時性能は純JSと同等

// ---

// ## TypeScript固有の最適化観点

// 1. **型安全性の活用**

//    * `number` 型を限定し、`RangeError` で入力検証
//    * `readonly` 引数（副作用防止）

// 2. **コンパイル時最適化**

//    * 型推論を利用 → コード量削減
//    * 定数計算はコンパイル時に最適化される

// 3. **開発効率と保守性**

//    * IntelliSense による関数利用補助
//    * 型定義がドキュメント代わりになる
//    * 小規模〜大規模まで拡張しやすい

// ---

// ✅ 以上の実装は **競技プログラミングの速度要件** と **業務開発の型安全性・保守性** を両立しています。

// ---
