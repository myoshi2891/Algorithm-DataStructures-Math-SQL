ここでは **n=4, k=9** のケースを例に、実際の処理を **図解付き** で具体的に説明します。

---

## 問題設定

* 入力: `n=4, k=9`
* 目標: `[1,2,3,4]` の全ての順列 (4! = 24個) を辞書順に並べたとき、**9番目** の順列を返す。

---

## ステップ1: 階乗の計算

```ts
factorial[i] = i!
```

| i | factorial\[i] |
| - | ------------- |
| 0 | 1             |
| 1 | 1             |
| 2 | 2             |
| 3 | 6             |
| 4 | 24            |

---

## ステップ2: 候補リストの準備

```ts
numbers = ["1", "2", "3", "4"]
```

---

## ステップ3: k を 0-indexed に調整

```ts
k = 9 - 1 = 8
```

---

## ステップ4: 順列の構築

### ループ 1回目 (i=4)

* `idx = Math.floor(8 / factorial[3]) = Math.floor(8 / 6) = 1`
* numbers\[1] = `"2"` を選ぶ
* `result = "2"`
* 候補更新: `numbers = ["1", "3", "4"]`
* `k = 8 % 6 = 2`

```
選んだ: 2
残り候補: [1, 3, 4]
```

---

### ループ 2回目 (i=3)

* `idx = Math.floor(2 / factorial[2]) = Math.floor(2 / 2) = 1`
* numbers\[1] = `"3"` を選ぶ
* `result = "23"`
* 候補更新: `numbers = ["1", "4"]`
* `k = 2 % 2 = 0`

```
選んだ: 3
残り候補: [1, 4]
```

---

### ループ 3回目 (i=2)

* `idx = Math.floor(0 / factorial[1]) = Math.floor(0 / 1) = 0`
* numbers\[0] = `"1"` を選ぶ
* `result = "231"`
* 候補更新: `numbers = ["4"]`
* `k = 0 % 1 = 0`

```
選んだ: 1
残り候補: [4]
```

---

### ループ 4回目 (i=1)

* `idx = Math.floor(0 / factorial[0]) = 0`
* numbers\[0] = `"4"` を選ぶ
* `result = "2314"`
* 候補更新: `numbers = []`

```
選んだ: 4
残り候補: []
```

---

## ステップ5: 結果

```
result = "2314"
```

---

## 全体の流れ（図解）

```
初期:
numbers = [1,2,3,4], k=8

↓ i=4
[1, (2), 3, 4] → 選択 "2" → result="2" → k=2

↓ i=3
[1, (3), 4] → 選択 "3" → result="23" → k=0

↓ i=2
[(1), 4] → 選択 "1" → result="231" → k=0

↓ i=1
[(4)] → 選択 "4" → result="2314"
```

---

## 処理の特徴

* **処理時間 O(n^2)**:
  各ループで `numbers.splice` に O(n) かかり、それを n 回繰り返す。
* **メモリ O(n)**:
  `factorial` と `numbers` 配列だけを保持。

---

👉 以上の流れで **9番目の順列は "2314"** と求まります。

なるほどですね 👍
「どうしてこのアルゴリズムで k 番目の順列が求まるのか？」という **理屈** と、
「なぜ計算量が O(n^2)、メモリが O(n) なのか？」という **計算量評価** を整理して説明します。

---

## 1. アルゴリズムの考え方

順列を「辞書順に並べた k 番目」を求めたいとき、
**「最初の要素が何か？」は、(n-1)! ごとにブロックが変わる** という性質を利用します。

### 例: n=4 の場合

全順列の数 = 4! = 24

* **最初が 1 の順列**: 6 個 (残り 3! = 6)
* **最初が 2 の順列**: 6 個
* **最初が 3 の順列**: 6 個
* **最初が 4 の順列**: 6 個

つまり、`k` を `(n-1)!` で割ることで
「どのブロックに属するか (最初の文字は何か)」が分かります。

その後、残りの数字に対して同じ処理を繰り返すことで、
逐次的に順列を決定できるわけです。

---

## 2. 具体的な処理の流れ

### ステップ1: factorial 配列を準備

`factorial[i] = i!` を持っておくことで、
「ブロックのサイズ」をすぐに求められる。

---

### ステップ2: 候補配列 numbers

最初は `[1,2,3,...,n]`
選んだ数は取り除いていく。

---

### ステップ3: k を 0-indexed にする

`k--` とすることで配列インデックスとして扱える。

---

### ステップ4: 各桁を決定

ループを回しながら以下を繰り返す:

1. `idx = Math.floor(k / factorial[i-1])`
   → 「この桁で何番目の数字を選ぶか」を決定
2. `result += numbers[idx]`
   → 実際にその数字を結果に追加
3. `numbers.splice(idx, 1)`
   → 選んだ数字を候補から除去
4. `k = k % factorial[i-1]`
   → 次のステップでの残りの順位を更新

---

## 3. 計算量の理由

### (1) 時間計算量 O(n^2)

* ループは n 回 (桁数ぶん) 回す。
* 各ループで `numbers.splice(idx, 1)` を呼ぶが、これは内部的に配列をシフトするため **O(n)** かかる。
* よって合計で **O(n^2)**。

※ n ≤ 9 なので、LeetCode の制約では十分高速。

---

### (2) 空間計算量 O(n)

* `factorial`: 長さ n+1 の配列
* `numbers`: 長さ n の配列
* `result`: 長さ n の文字列

これらしか使わないので、追加メモリは **O(n)**。

---

## 4. まとめ図

```
例: n=4, k=9

factorial = [1,1,2,6,24]
numbers   = [1,2,3,4]
k=8 (0-indexed)

i=4 → idx=8/6=1 → "2" を選ぶ
numbers=[1,3,4], k=2

i=3 → idx=2/2=1 → "3" を選ぶ
numbers=[1,4], k=0

i=2 → idx=0/1=0 → "1" を選ぶ
numbers=[4], k=0

i=1 → idx=0/1=0 → "4" を選ぶ
numbers=[], 完了

結果: "2314"
```

---

👉 つまり **「順列のブロックサイズが階乗で決まる」** ことと、
**「候補を一つずつ消していくことで、順列の k 番目を直に構築できる」** のがポイントです。

---

**数学的根拠**を腰を据えて説明します。鍵は「**階乗進法（factoradic）／レーマーコード（Lehmer code）**」と「**辞書順のブロック構造**」です。

---

# 1) 辞書順は“階乗サイズのブロック”に分かれる

集合 $[1,2,\dots,n]$ の順列を**辞書順**で並べると、
先頭要素が同じものが**連続的に**現れ、各ブロックの大きさは $(n-1)!$ 個になります。

* 先頭が $1$ の順列：$(n-1)!$ 個
* 先頭が $2$ の順列：$(n-1)!$ 個
* …
* 先頭が $n$ の順列：$(n-1)!$ 個

**理由（補題）：**
辞書順は左から比較します。先頭が $x$ である順列は、残り $n-1$ 個の並べ方（$(n-1)!$ 通り）を辞書順で並べた列と一致し、それらは先頭が $x$ でない順列よりも常に先（or 後）にまとまって並びます。よって“先頭固定の列”が連続し、個数は $(n-1)!$。

---

# 2) 最初の文字は「$\left\lfloor\frac{k-1}{(n-1)!}\right\rfloor$ 番目」の候補

辞書順で **$k$ 番目**（1-indexed）を求めたいとき、0-indexed で $K:=k-1$ とおくと

$$
q \;=\; \left\lfloor \frac{K}{(n-1)!} \right\rfloor, 
\qquad r \;=\; K \bmod (n-1)!
$$

* $q$ は「**どの先頭ブロック**か」を表します（0 始まり）。
  つまり、残っている候補（昇順）から **$q$ 番目**（0-indexed）の数字が先頭。
* 残りの順位は **$r$** になります。
  以後は「残り $n-1$ 個」に対する **$r+1$ 番目**（また 1-indexed）を再び同じ論理で求めればよい。

これを**各桁で繰り返す**と、毎回「その桁でのブロックサイズ」が $(i-1)!$（後述の $i$ は残り長）なので、先頭から順に正しい要素が選べます。
この「割って商がインデックス、余りが次の順位」という構造が、まさに**階乗進法**そのものです。

---

# 3) 階乗進法（factoradic）とレーマーコード（Lehmer code）

0 以上 $n!-1$ 以下の整数 $K$ は一意に

$$
K \;=\; c_{n-1}\cdot (n-1)! \;+\; c_{n-2}\cdot (n-2)! \;+\; \cdots \;+\; c_{1}\cdot 1! \;+\; c_{0}\cdot 0!
$$

と表せます。ただし係数は

$$
0 \le c_{i} \le i
$$

を満たします（**階乗進法**）。

この $(c_{n-1}, c_{n-2}, \dots, c_0)$ を**レーマーコード**と呼び、次の生成規則があります：

* 左から順に、**未使用の数字の昇順リスト**から「$c_{n-1}$-番目」「$c_{n-2}$-番目」…を取っていく（0-indexed）。
* 取った数字はリストから除外して次へ。

すると得られる順列は、**辞書順におけるランクが**

$$
\text{rank} \;=\; 1 + \sum_{i=0}^{n-1} c_i\cdot i!
$$

に**ちょうど一致**します（1-indexed）。
逆に、任意の順列 $\pi$ から、各位置で「未使用の要素のうち $\pi$ より小さい要素の個数」を数えていくと $(c_{n-1},\dots,c_0)$ が得られ、上式でランクが計算できます。
よって **「ランク」と「レーマーコード（≒階乗進法）」は完全に同値** であり、**双方向の全単射**です。

> つまり、コード内の
> `idx = Math.floor(k / factorial[i-1])` と `k %= factorial[i-1]`
> はそのまま **$K$ を階乗進法に展開**して「その桁の $c_{i-1}$ を読む」操作です。
> `numbers[idx]` を取り、削除して次へ進むのは **レーマーコード → 順列** の復元規則です。

---

# 4) 帰納法での正当性証明（スケッチ）

**命題：** アルゴリズムは辞書順 $k$ 番目の順列を返す。

* **基底（$n=1$**）：順列は $[1]$ のみ。明らかに正しい。
* **帰納法の仮定**：長さ $n-1$ まで正しいと仮定。
* **帰納ステップ（$n$**）：
  0-indexed $K=k-1$ とし、
  $q=\lfloor K/(n-1)!\rfloor$, $r=K \bmod (n-1)!$。
  補題より、先頭が各値のブロックは $(n-1)!$ 個ずつの連続区間。
  よって $q$ は「先頭ブロックの番号」そのもので、先頭は未使用リストの $q$-番目。
  残りは「未使用 $n-1$ 個」に対する **$r+1$ 番目**の辞書順順列。
  これは帰納法の仮定により正しく再構成できる。
  よって全体も正しい。

---

# 5) 例：$n=4,\;k=9$

$K=k-1=8$ を階乗進法へ：

* $8 / 3! = 1$ 余り $2$ ⇒ $c_3=1$
* $2 / 2! = 1$ 余り $0$ ⇒ $c_2=1$
* $0 / 1! = 0$ 余り $0$ ⇒ $c_1=0$
* $0 / 0! = 0$ ⇒ $c_0=0$

$(c_3,c_2,c_1,c_0)=(1,1,0,0)$。

未使用リスト $[1,2,3,4]$ から順に
0-indexed で 1番目 → **2**、
次は残り $[1,3,4]$ から 1番目 → **3**、
次は $[1,4]$ から 0番目 → **1**、
次は $[4]$ から 0番目 → **4**。
結果 **2314**（辞書順9番目）です。

---

# 6) 端のケースも説明がつく

* $k=1$ → $K=0$ → すべての $c_i=0$ → 常に先頭（0番目）を選ぶ → **昇順**「123…n」。
* $k=n!$ → $K=n!-1$ → $c_{n-1}=n-1,\;c_{n-2}=n-2,\dots,c_1=1,c_0=0$ → 毎回末尾を選ぶ → **降順**「n…321」。

---

# 7) まとめ（直観と形式の一致）

* **直観**：辞書順は“先頭固定の塊”が $(n-1)!$ 個ずつ並ぶ。割り算の**商**が“どの塊か”、**余り**が“塊の中での順位”。
* **形式**：$K$ の**階乗進法展開**の各桁 $c_{i}$ が、その桁で選ぶインデックスを**一意に**与える。
* **結論**：本アルゴリズムは「**rank ↔ permutation**」の既知の全単射（レーマーコード）をそのまま実装しているため、**常に正しい**。
