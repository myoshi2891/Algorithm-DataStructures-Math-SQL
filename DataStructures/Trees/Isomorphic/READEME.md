## 🎯 問題の本質

「2つの木 T1, T2 が **同型（isomorphic）** かどうかを判定する」問題です。

---

## 🌳 木の例（入力例1）

```
T1:
6
1 2
1 3
2 4
4 5
4 6

T2:
6
2 3
2 4
3 5
5 6
5 1
```

---

## ✅ 処理の流れ（ステップ別解説）

---

### Step 1️⃣ 入力の読み取りとグラフの構築

```js
const N1 = parseInt(lines[index++]);
// T1 の辺リストを構築
for (let i = 0; i < N1 - 1; i++) {
    const [a, b] = lines[index++].split(' ').map(Number);
    edges1.push([a - 1, b - 1]); // 0-indexed
}
```

#### 📌 グラフ T1 の可視化：

```
       1
     /   \
    2     3
   /
  4
 / \
5   6
```

（T1: 6頂点、5本の辺）

→ JavaScript では 0-indexed にするので、1は0、2は1...として扱います。

---

### Step 2️⃣ 順列生成（全写像の列挙）

```js
const permute = (arr) => {
    /* 再帰で順列生成 */
};
const permutations = permute([...Array(N).keys()]);
```

#### 🔁 どうして全パターンを試す？

「写像 f: V1 → V2 の一対一対応」が **全ての順列のこと** だからです。

例えば V1 = \[0, 1, 2] のとき、可能な f の写像（順列）は：

```
[0,1,2], [0,2,1], [1,0,2], [1,2,0], [2,0,1], [2,1,0]
```

---

### Step 3️⃣ 辺集合の比較（写像を元にT1をT2に変換）

```js
const mappedEdges = edges1.map(([a, b]) => {
    const ma = perm[a];
    const mb = perm[b];
    return ma < mb ? [ma, mb] : [mb, ma];
});
```

#### 🧠 どうやって「写像後のT1」を得てる？

たとえば T1 において (1,2) → \[0,1] を perm = \[1,2,3,...] のような f(x)=y で置き換えます。

```text
T1の辺 (1,2) = [0,1]
perm[0]=2, perm[1]=3 → 対応先 = (2,3)
```

その後、順序を揃えるために \[小さい順] に並べ、全体のエッジリストをソートして比較可能にします。

---

### Step 4️⃣ 一致判定

```js
if (mappedEdges === normalizedEdges2) {
    console.log('YES');
    return;
}
```

写像されたT1の辺集合（= mappedEdges）と、T2の辺集合を比較。

---

## 🖼️ 図解：構造が同型な2つの木

### 🔷 T1 の構造（入力の辺から構成）

```
       1
     /   \
    2     3
   /
  4
 / \
5   6
```

### 🔷 T2 の構造（実際には形が違って見えるが同じ）

```
       5
      /
     2
    / \
   3   4
      / \
     6   1
```

このT2は、T1と形が違って見えるが、**頂点番号の割り当てを変えれば完全に一致**します。

---

## 🔄 同型判定とは？

- 形が違って見えても、**「節（ノード）のつながり方」が同じ**ならOK。
- 頂点番号はどうでもよくて、「構造が一致するか？」が重要。

---

## ✅ 最終的に出力されるのは：

```
YES
```

---

## 🔚 結論：このコードはこういう問題に適している！

- 頂点数が最大8なので、全写像を試す brute-force（全探索）が可能。
- グラフの同型性チェックは、一般には難しいが、**小さなサイズ**であれば実用的。

---
