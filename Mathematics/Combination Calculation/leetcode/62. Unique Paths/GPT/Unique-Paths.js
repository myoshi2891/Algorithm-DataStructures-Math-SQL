// ## 1. 問題の分析

// ### 競技プログラミング視点

// * **ゴール**: ロボットが右 or 下にしか進めない場合、左上から右下までの経路数を求める。
// * **解法候補**:

//   1. DP (Dynamic Programming) → O(mn) 時間・O(n) 空間最適化可能。
//   2. 組み合わせ数 (数学的解法) → 経路数 = C(m+n-2, m-1)。
// * **制約**: m, n ≤ 100、結果 ≤ 2e9 → 32-bit 整数で収まる。
// * **速度**: O(1) の組み合わせ計算が最速。

// ### 業務開発視点

// * DP は可読性・直感的理解に優れる。
// * 数学的アプローチは高速かつ省メモリで保守性も高い。
// * エラーハンドリング: m, n が整数か？範囲チェック。

// ### JavaScript特有の考慮点

// * JS は整数オーバーフローがない（NumberはIEEE754倍精度浮動小数）。
// * ただし安全に計算するため、組み合わせ計算は逐次掛け算・割り算で精度を保つ。
// * V8最適化:

//   * `for` ループで配列アクセスを避ける
//   * プリミティブ数値計算を維持

// ---

// ## 2. アルゴリズムアプローチ比較

// | アプローチ     | 時間計算量       | 空間計算量 | JS実装コスト | 可読性 | 備考            |
// | --------- | ----------- | ----- | ------- | --- | ------------- |
// | DP (2D配列) | O(mn)       | O(mn) | 中       | 高   | 直感的だが不要にメモリ使用 |
// | DP (1D配列) | O(mn)       | O(n)  | 中       | 中   | 効率的だがDP知識必要   |
// | 組み合わせ計算   | O(min(m,n)) | O(1)  | 低       | 高   | 最速・最省メモリ      |

// ---

// ## 3. 選択したアルゴリズムと理由

// * **選択**: 組み合わせ計算
// * **理由**:

//   * 計算量 O(min(m, n)) で十分小さい
//   * O(1) メモリ
//   * JS で安全に実装可能（逐次計算方式）

// ---

// ## 4. コード実装

// ```javascript
/**
 * ユニークパスの総数を計算する
 * @param {number} m - グリッドの行数 (1 <= m <= 100)
 * @param {number} n - グリッドの列数 (1 <= n <= 100)
 * @returns {number} - 経路数 (<= 2*10^9)
 * @throws {TypeError} - 引数が整数でない場合
 * @throws {RangeError} - 引数が範囲外の場合
 * @complexity Time: O(min(m,n)), Space: O(1)
 */
function uniquePaths(m, n) {
    // 入力検証
    if (!Number.isInteger(m) || !Number.isInteger(n)) {
        throw new TypeError('Inputs must be integers');
    }
    if (m < 1 || n < 1 || m > 100 || n > 100) {
        throw new RangeError('Inputs must be in range 1 <= m, n <= 100');
    }

    // 組み合わせ計算: C(m+n-2, m-1)
    const totalSteps = m + n - 2;
    const k = Math.min(m - 1, n - 1);
    let result = 1;

    // 逐次計算でオーバーフロー回避
    for (let i = 1; i <= k; i++) {
        result = (result * (totalSteps - k + i)) / i;
    }

    return Math.round(result); // 浮動小数誤差の切り捨て
}

// --- 使用例 ---
// console.log(uniquePaths(3, 7)); // 28
// console.log(uniquePaths(3, 2)); // 3
// ```

// ---

// ## 5. JavaScript固有の最適化観点

// * **V8最適化**:

//   * `for` ループ利用（`forEach` より高速）
//   * プリミティブ数値演算のみ使用
// * **GC負荷軽減**:

//   * 配列生成を回避（逐次計算）
//   * 不要なオブジェクト生成なし
// * **安全性**:

//   * 浮動小数演算の誤差を `Math.round` で調整

// ---

// ✅ この解法は **競技プログラミング視点でも最速** であり、
// ✅ **業務開発視点でも明快で保守性が高い** 実装になっています。
