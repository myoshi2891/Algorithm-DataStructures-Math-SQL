では、先ほどの `strStr` 関数（KMP法による文字列探索）の**各処理ステップを図解とともに具体的に解析・説明**します。

---

## 🔍 **問題概要**

- `haystack` から `needle` が **最初に現れる位置（インデックス）** を返す。
- 見つからなければ `-1` を返す。

例:

```
haystack = "sadbutsad"
needle   = "sad"
出力: 0
```

---

## ✅ **KMP法 全体の流れ**

### ステップ1: `needle` から **LPS配列（部分一致テーブル）** を作る

### ステップ2: `haystack` を走査し、`needle` とマッチングする

---

## 📘 ステップ1: LPS 配列の構築

### ✅ 目的：

- パターンの途中で不一致が起きたとき、比較を**最初からやり直さずに済む**ようにする
- LPS = `Longest Prefix which is also Suffix`

---

### 🎯 例:

```text
needle = "ababc"
```

#### LPS 配列の構築ステップ

| i   | needle\[0\:i] | LPS\[i] | 説明                                                  |
| --- | ------------- | ------- | ----------------------------------------------------- |
| 0   | "a"           | 0       | 最初の文字なので LPS=0                                |
| 1   | "ab"          | 0       | "a" ≠ "b" なので 0                                    |
| 2   | "aba"         | 1       | "a" で prefix=suffix -> 長さ1                         |
| 3   | "abab"        | 2       | "ab" で prefix=suffix -> 長さ2                        |
| 4   | "ababc"       | 0       | "c" ≠ "a", "c" ≠ "b" -> 一致するprefix/suffix無し → 0 |

```
最終LPS = [0, 0, 1, 2, 0]
```

📌 **この配列は失敗時にどこまで戻ればよいかを示すテーブル**です。

---

## 📘 ステップ2: `haystack` の走査

### ✅ 目的：

- LPS配列を使って `haystack` を効率よく走査
- 一致しない時に `needle` のどこから再比較すればよいかを判断する

---

### 🎯 例:

```text
haystack = "abxabcabcaby"
needle   = "abcaby"
```

#### LPS（事前計算済み）:

```
needle = "a b c a b y"
LPS    = [0 0 0 1 2 0]
```

---

### 🔄 マッチング処理ステップ（図で追跡）：

```text
haystack: a b x a b c a b c a b y
needle  : a b c a b y
                     ↑
```

#### 比較の様子：

| i (haystack) | j (needle) | 一致？ | 説明                           |
| ------------ | ---------- | ------ | ------------------------------ |
| 0            | 0          | ✅     | 'a'=='a' → i++, j++            |
| 1            | 1          | ✅     | 'b'=='b' → i++, j++            |
| 2            | 2          | ❌     | 'x' ≠ 'c' → j = LPS\[j-1] = 0  |
| 2            | 0          | ❌     | 'x' ≠ 'a' → i++, j stays at 0  |
| ...          | ...        |        | 同様の比較とジャンプが続く     |
| 6            | 0\~5       | ✅     | すべて一致 → i=12, j=6（完了） |
| 出力:        |            |        | i - j = 12 - 6 = 6 が解        |

---

## 🎯 ビジュアル図（イメージ）

```
haystack:  a b x a b c a b c a b y
                  ↑↑↑↑↑↑       ← ここでneedle完全一致（6文字）

needle  :      a b c a b y
```

---

## 🧠 KMP法が効率的な理由

- **部分一致までの情報をLPSに持っている**ので、無駄に戻らない
- 文字列長が最大1万でも `O(n + m)` で探索できる（`find`より効率よい場合あり）

---

## ✅ 補足まとめ

| ステップ     | 内容                        | 時間計算量   | 空間計算量 |
| ------------ | --------------------------- | ------------ | ---------- |
| LPS構築      | 部分一致テーブルの準備      | O(m)         | O(m)       |
| haystack走査 | LPSを用いて文字列マッチング | O(n)         | O(1)       |
| 合計         |                             | **O(n + m)** | O(m)       |

---

ご希望であれば「比較の様子を表に拡張」や「より長い文字列の可視化」も可能です。お気軽にどうぞ！
