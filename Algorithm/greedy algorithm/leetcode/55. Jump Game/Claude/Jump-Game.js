// この問題は「Jump Game」と呼ばれる典型的な貪欲法（Greedy）の問題です。各位置から最大どこまで到達できるかを追跡していく方法で効率的に解けます。この解法のポイント：

// **アルゴリズムの説明：**
// 1. `maxReach`変数で現在到達可能な最大インデックスを追跡
// 2. 各位置`i`で、`i > maxReach`の場合は到達不可能なので`false`を返す
// 3. 各位置から`i + nums[i]`まで到達可能なので、`maxReach`を更新
// 4. `maxReach`が最後のインデックス以上になれば`true`を返す

// **最適化のポイント：**
// - **時間計算量**: O(n) - 配列を一度だけ走査
// - **空間計算量**: O(1) - 追加メモリは定数のみ
// - **早期終了**: 最後まで到達可能が確定したら即座に`true`を返す
// - **不要な計算を回避**: 到達不可能が判明したら即座に`false`を返す

// この貪欲法のアプローチにより、LeetCodeでの実行時間とメモリ使用量を最小限に抑えることができます。

/**
 * 配列の最後のインデックスに到達できるかどうかを判定する関数
 *
 * @param {number[]} nums - 各位置での最大ジャンプ長を表す整数配列
 * @return {boolean} - 最後のインデックスに到達できる場合はtrue、そうでなければfalse
 *
 * 時間計算量: O(n) - 配列を一度だけ走査
 * 空間計算量: O(1) - 定数の追加メモリのみ使用
 */
function canJump(nums) {
    // 現在到達可能な最大インデックスを追跡
    let maxReach = 0;

    // 配列の各要素を順番に処理
    for (let i = 0; i < nums.length; i++) {
        // 現在の位置が到達可能範囲を超えている場合、最後まで到達不可能
        if (i > maxReach) {
            return false;
        }

        // 現在の位置から到達可能な最大インデックスを更新
        maxReach = Math.max(maxReach, i + nums[i]);

        // 既に最後のインデックス以上に到達可能な場合、早期終了
        if (maxReach >= nums.length - 1) {
            return true;
        }
    }

    // ループが完了した場合、最後のインデックスに到達可能
    return true;
}
