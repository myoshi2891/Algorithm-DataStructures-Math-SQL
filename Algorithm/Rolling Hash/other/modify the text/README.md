以下にて、あなたのPythonコードに含まれる主要な処理を **図解・段階的に詳細に解析** します。

---

## 🔍 問題の背景

与えられた文字列 `S` の各位置に対して **一文字更新**が行われた後、ハッシュ値 `H(S)` を高速に求め直す問題です。

---

## 📘 ハッシュ値の定義

### ハッシュ計算式：

$$
H(S) = \sum_{i=1}^{N} T_i \cdot X^{N-i} \mod P
$$

- $T_i$：`S[i]` を英大文字 A〜Z → 1〜26 に変換した整数
- $X$：基数
- $P$：素数（mod）
- 文字列 S = "HELLO" の例では：

```
T = [8, 5, 12, 12, 15]  // A=1, B=2,... Z=26
pow_table = [X^4, X^3, X^2, X^1, X^0]
```

### 図1：ハッシュ計算（初期）

```
S     = H   E   L   L   O
Ti    = 8   5  12  12  15
pow   = X^4 X^3 X^2 X^1 X^0
H(S) = 8·X^4 + 5·X^3 + 12·X^2 + 12·X + 15
```

---

## 🧮 ステップ1：累乗の事前計算

### 処理内容：

```python
pow_table[i] = X^(N-i-1) % P
```

### 理由：

- クエリで **再計算** を高速にするため
- 更新対象 `S[i]` の影響は `T_i × X^{N - i - 1}` の1項のみ

### 図2：累乗テーブル pow_table の構築（N=5, X=3）

```
i        0    1    2    3    4
pow[i] = X^4  X^3  X^2  X^1  X^0
        = 81   27   9    3    1
```

---

## 🧮 ステップ2：初期ハッシュの構築

```python
hash_val = Σ (char_to_val(S[i]) * pow_table[i]) % P
```

### 図3：初期ハッシュ計算（例：S="HELLO"）

```
hash_val = 8·X^4 + 5·X^3 + 12·X^2 + 12·X + 15
```

---

## 🧩 ステップ3：1クエリごとの更新処理

```python
hash_val = (hash_val + (new_val - old_val) * pow_table[i]) % P
```

### 概要：

- 差分 `(new_val - old_val)` を計算し
- 元のハッシュに `(差分 × pow_table[i])` を加算

### 図4：差分更新（例：i=2のLをC=3に変更）

```
変更前：T[2] = 12（L）
変更後：T[2] = 3（C）

差分: 3 - 12 = -9
hash_val += -9 × pow_table[2]  // X^2の重みを持つ項の差分
```

---

## 📘 クエリ処理の流れ

### 図5：クエリ `"2 D"` を処理するステップ（例）

```
1. S = "HELLO"
2. i = 2, 文字 D (→ val = 4)

3. old_val = 12 (L)
   new_val = 4 (D)

4. 差分 = (4 - 12) = -8
5. hash_val += -8 × pow_table[2]
6. hash_val %= P
```

---

## 🔁 最後に全体の流れを図でまとめる

### 図6：全体フロー（簡略図）

```
              ┌────────────┐
              │ 入力読み込み │
              └────┬───────┘
                   ↓
           ┌────────────┐
           │ pow_table 構築 │←──── X^(N-i-1)を事前計算
           └────┬───────┘
                   ↓
           ┌────────────┐
           │ 初期ハッシュ計算 │←──── Σ T_i × pow[i]
           └────┬───────┘
                   ↓
        ┌─────────────────────┐
        │ 各クエリ i の変更処理 │←──── 差分更新
        └────────┬────────┘
                 ↓
        ┌─────────────────────┐
        │ 更新後ハッシュを出力 │
        └─────────────────────┘
```

---

## 🧠 結論：なぜ高速なのか？

- **全クエリで再ハッシュしない**（O(N×Q)ではなくO(Q)）
- **pow_table によって、各変更の影響をO(1)で特定**
- Pythonの `pow()` も事前計算すればループ内不要

---

## ご希望あれば...

- `pow()` の都度計算版（メモリ削減）
- `ファイル入力` への変更
- **図をSVGや画像で出力**

などにも対応できます。必要であればお知らせください。
