以下に、先ほどの **TypeScript 実装** の各処理について、**図解付きで具体的に解析・説明** します。
対象コードは以下です。

```typescript
function nextPermutation(nums: number[]): void {
    // 1. 後ろから転換点を探す
    let i: number = nums.length - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }

    if (i >= 0) {
        // 2. 後ろから nums[i] より大きい要素を探す
        let j: number = nums.length - 1;
        while (j >= 0 && nums[j] <= nums[i]) {
            j--;
        }
        // 3. スワップ
        [nums[i], nums[j]] = [nums[j], nums[i]];
    }

    // 4. i+1 以降を反転
    let left: number = i + 1;
    let right: number = nums.length - 1;
    while (left < right) {
        [nums[left], nums[right]] = [nums[right], nums[left]];
        left++;
        right--;
    }
}
```

---

## **アルゴリズム解析と図解**

次の順列を求める標準アルゴリズムは以下のステップで進行します。

---

### **例1:** `nums = [1, 2, 3]`

#### **Step 1: 転換点の探索**

- **右端から探索して、`nums[i] < nums[i+1]` を満たす i を探す**

```
Index: 0   1   2
Value: 1   2   3
               ↑
             (右端)
```

- `i = 1` のとき
  `nums[1] = 2` < `nums[2] = 3` ✅
  → **転換点 i = 1**

---

#### **Step 2: 転換点より右で、nums\[i] より大きい最小の要素を探す**

- `nums[i] = 2` より大きい要素を **右から探索**

```
Index: 0   1   2
Value: 1   2   3
                ↑ j
```

- `nums[2] = 3` は `2` より大きい → j = 2

---

#### **Step 3: スワップ**

- `nums[i]` と `nums[j]` を交換

```
Before: [1, 2, 3]
Swap 2 and 3
After : [1, 3, 2]
```

---

#### **Step 4: 転換点以降を反転**

- `i+1` 以降 (`index 2 ~ end`) を反転

```
Current: [1, 3, 2]
i+1以降: [2] (長さ1なので反転しても同じ)
Result : [1, 3, 2]
```

✅ **次の順列は \[1,3,2]**

---

### **例2:** `nums = [3, 2, 1]` （最後の順列）

#### **Step 1: 転換点の探索**

```
Index: 0   1   2
Value: 3   2   1
```

- `i = 1`: `2 >= 1` ❌
- `i = 0`: `3 >= 2` ❌
- `i = -1` で終了 → **転換点なし**

---

#### **Step 2 & 3 はスキップ**（i < 0）

---

#### **Step 4: 配列全体を反転**

```
Before: [3, 2, 1]
Reverse all
After : [1, 2, 3]
```

✅ **最小の順列に戻る**

---

### **例3:** `nums = [1, 1, 5]`

#### **Step 1: 転換点の探索**

```
Index: 0   1   2
Value: 1   1   5
```

- `i = 1`: `1 < 5` ✅ → 転換点 i=1

---

#### **Step 2: 転換点より右で、nums\[i] より大きい要素を探す**

```
nums[i] = 1
右端から探索:
Index 2 -> 5 > 1 ✅
```

- j = 2

---

#### **Step 3: スワップ**

```
Before: [1, 1, 5]
Swap nums[1] and nums[2]
After : [1, 5, 1]
```

---

#### **Step 4: i+1 以降を反転**

- i+1 = 2 以降 `[1]` は長さ1 → 反転しても同じ

✅ **次の順列は \[1, 5, 1]**

---

## **処理時間・メモリ解析**

- **時間計算量**:
    1. 転換点探索 O(n)
    2. 後ろから j 探索 O(n)
    3. スワップ O(1)
    4. 末尾反転 O(n)
       → **O(n)** （n ≤ 100 なので高速）

- **メモリ使用量**:
    - 定数個の変数のみ使用
    - 配列は **in-place** 更新
      → **O(1)**

---

このアルゴリズムは **辞書順で次の順列を得る標準解法** であり、

- 最後の順列なら昇順に戻す
- それ以外は転換点を1回スワップ＋反転で達成

---

以下に、先ほどの日本語解説に **図解を付けて理解しやすくしたバージョン** を作成しました。
ASCII図で処理の流れや辞書順の関係が視覚的に分かるようにしています。

---

# **次の順列（Next Permutation）の解説（図解付き）**

## 1️⃣ 順列（Permutation）とは？

整数配列の**順列**とは、
配列の要素を並び替えて作られるあらゆるパターンを指します。

例えば、`arr = [1,2,3]` の順列は次の6通りです：

```
1. [1, 2, 3]
2. [1, 3, 2]
3. [2, 1, 3]
4. [2, 3, 1]
5. [3, 1, 2]
6. [3, 2, 1]
```

図にすると、次のように辞書順に並びます（小さい順 → 大きい順）：

```
辞書順(昇順)
[1,2,3] → [1,3,2] → [2,1,3] → [2,3,1] → [3,1,2] → [3,2,1]
```

---

## 2️⃣ 次の順列（Next Permutation）とは？

**次の順列**とは、
**辞書順で今より大きい並びの中で最も小さいもの**を指します。

### 例1： `[1, 2, 3]` の次の順列

```
現状: [1,2,3]
次の順列: [1,3,2]
```

図解：

```
[1,2,3] → [1,3,2] → ...
 ↑現在       ↑次の順列
```

---

### 例2： `[3, 2, 1]` の次の順列

```
現状: [3,2,1]
これは辞書順で最大なので次は最小の順列
次の順列: [1,2,3]
```

図解：

```
... → [3,1,2] → [3,2,1]
                       ↑現在(最後)
最小に戻る →          [1,2,3]
```

---

### 例3： `[1, 1, 5]` の次の順列

```
現状: [1,1,5]
次の順列: [1,5,1]
```

図解：

```
[1,1,5] → [1,5,1] → [5,1,1]
```

---

## 3️⃣ アルゴリズムの図解（手順）

次の順列を求める標準的な方法は次の4ステップです。

---

### **Step 1: 転換点を探す**

右端から左に向かって探索し、
**「左の値 < 右の値」** となる位置を見つけます。

例：`[1, 2, 3]`

```
Index: 0   1   2
Value: 1   2   3
                 ↑右端
nums[1] = 2 < nums[2] = 3 なので i = 1 が転換点
```

---

### **Step 2: 転換点より右で、nums\[i] より大きい最小の要素を探す**

右から探索して、`nums[i]` より大きい要素を探します。

```
[1, 2, 3]
 i=1    j=2
```

---

### **Step 3: スワップ**

見つけた2つを入れ替えます。

```
Before: [1, 2, 3]
Swap(2, 3)
After : [1, 3, 2]
```

---

### **Step 4: 転換点以降を反転**

`i+1` 以降の部分を反転（昇順化）します。

```
i+1以降は [2] → 反転しても同じ
結果: [1, 3, 2]
```

---

## 4️⃣ 処理時間・メモリ解析

- **処理時間**:
    - 転換点探索 O(n)
    - 右端からの探索 O(n)
    - 部分反転 O(n)
      → 合計 **O(n)**

- **メモリ消費**:
    - 配列をその場で変更（in-place）
    - 追加メモリは数個の変数のみ
      → **O(1)**

---

この手順を使えば、最大 100 要素でも高速に次の順列を求められます。

---
