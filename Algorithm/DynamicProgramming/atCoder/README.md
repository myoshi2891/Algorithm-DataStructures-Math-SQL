ダイクストラ法またはDP（動的計画法）を用いることで、この問題を効率的に解くことができます。  
ここでは、DPを用いて解く方法を示します。  

### **アプローチ**
1. `dp[i]` を部屋 `i` に到達するまでの最短時間とする。
2. `dp[1] = 0` （スタート地点）
3. 遷移式：
   - `dp[i] = min(dp[i-1] + A[i], dp[i-2] + B[i])`（ `i ≥ 3` の場合）
   - `dp[i] = dp[i-1] + A[i]`（ `i = 2` の場合）
4. `dp[N]` が求める答え。

この方法では、`O(N)` の計算量で解を求められ、 `N` が最大 `100000` の場合でも高速に動作します。

### **コード（JavaScript）**
```javascript
function minTimeToReachRoomN(N, A, B) {
    let dp = new Array(N + 1).fill(Infinity);
    dp[1] = 0;  // スタート地点

    for (let i = 2; i <= N; i++) {
        dp[i] = Math.min(dp[i], dp[i - 1] + A[i - 2]); // i-1 からの移動
        if (i > 2) {
            dp[i] = Math.min(dp[i], dp[i - 2] + B[i - 3]); // i-2 からの移動
        }
    }
    return dp[N];
}

// 入力処理
function main(input) {
    let lines = input.trim().split("\n");
    let N = parseInt(lines[0]);
    let A = lines[1].split(" ").map(Number);
    let B = lines.length > 2 ? lines[2].split(" ").map(Number) : [];

    console.log(minTimeToReachRoomN(N, A, B));
}

// 標準入力からの読み込み
process.stdin.resume();
process.stdin.setEncoding("utf-8");
let inputData = "";
process.stdin.on("data", function (chunk) {
    inputData += chunk;
});
process.stdin.on("end", function () {
    main(inputData);
});
```

### **コードの説明**
1. **`minTimeToReachRoomN(N, A, B)`**
   - `dp` 配列を用意して、部屋 `1` から `N` までの最短時間を求める。
   - `dp[1] = 0` とし、`dp[2]` 以降を `A` や `B` を用いて更新していく。
   - `dp[N]` を返す。

2. **`main(input)`**
   - 入力を処理し、`N, A, B` の配列を抽出。
   - `minTimeToReachRoomN` を呼び出して結果を出力。

3. **標準入力の処理**
   - `process.stdin` を使って、競技プログラミング向けの入力処理を実装。

### **計算量**
- 各 `dp[i]` は `O(1)` で更新されるので、全体の計算量は **`O(N)`**。
- `N` が `100000` でも高速に動作可能。

### **テスト**
#### **入力**
```
5
2 4 1 3
5 3 7
```
#### **出力**
```
8
```
#### **入力**
```
10
1 19 75 37 17 16 33 18 22
41 28 89 74 98 43 42 31
```
#### **出力**
```
157
```

### **入力例 1**
```
5
2 4 1 3
5 3 7
```
この入力を図で表すと、以下のようになります。

```
(部屋1) → (部屋2) → (部屋3) → (部屋4) → (部屋5)
      A2=2   A3=4   A4=1   A5=3
       ↘        ↘      ↘
        B3=5    B4=3   B5=7
```

それぞれの部屋 `i` から、次の部屋 `i+1` または `i+2` に移動できます。

---

### **ステップごとの計算**
`dp[i]` を部屋 `i` に到達するまでの最短時間とする。

1. **初期状態**
   ```
   dp[1] = 0  (スタート地点)
   dp[2] = dp[1] + A2 = 0 + 2 = 2
   ```

2. **部屋3への遷移**
   ```
   dp[3] = min(dp[2] + A3, dp[1] + B3)
         = min(2 + 4, 0 + 5)
         = min(6, 5)
         = 5
   ```

3. **部屋4への遷移**
   ```
   dp[4] = min(dp[3] + A4, dp[2] + B4)
         = min(5 + 1, 2 + 3)
         = min(6, 5)
         = 5
   ```

4. **部屋5への遷移**
   ```
   dp[5] = min(dp[4] + A5, dp[3] + B5)
         = min(5 + 3, 5 + 7)
         = min(8, 12)
         = 8
   ```

**答え： `dp[5] = 8`**

---

### **図による遷移の確認**
#### **ステップ1**
```
(部屋1) --[2]--> (部屋2)
```
- `dp[2] = 2`

#### **ステップ2**
```
(部屋1) --[5]--> (部屋3)
(部屋2) --[4]--> (部屋3)
```
- `dp[3] = 5`

#### **ステップ3**
```
(部屋2) --[3]--> (部屋4)
(部屋3) --[1]--> (部屋4)
```
- `dp[4] = 5`

#### **ステップ4**
```
(部屋3) --[7]--> (部屋5)
(部屋4) --[3]--> (部屋5)
```
- `dp[5] = 8`

---

### **まとめ**
このように、**動的計画法（DP）を用いることで最短時間 `8` を求めることができます。**