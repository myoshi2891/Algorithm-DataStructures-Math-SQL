
---

## 🧩 問題の本質：塗れるのは「**3連続の同色のみ**」

### 操作可能なアクション：

* 「任意の位置から連続3つのタイルを、赤（R）または青（B）で塗る」
  → つまり、盤面上に `[x, x+1, x+2]` に対して同じ色を適用することしかできません。

---

## 🎯 ゴール：タイル列を最終的に `S` に一致させる

---

## ✅ 正しい判定条件：

「S に `RRR` または `BBB` のように**3つ連続で同じ色が存在するか？**」を確認するだけで十分です。

なぜなら、逆に「そのような 3 連が**一度も現れない**場合」は、どんなに操作しても `S` は作れません。

---

## 🖼️ 図で理解しよう

### 例1：`S = "RBRBR"`（R と B が交互）

```
位置:     0   1   2   3   4
        +---+---+---+---+---+
S[i]:   | R | B | R | B | R |
        +---+---+---+---+---+
```

このような構造では「3つ連続して同じ色」になる位置が**どこにもありません**。

* 操作では `[i, i+1, i+2]` をすべて同じ色にしかできない。
* つまり、**操作の結果、RBRやBRBのような構造を作ることは不可能**です。

**結論：No**

---

### 例2：`S = "BBRRRBB"`

```
位置:     0   1   2   3   4   5   6
        +---+---+---+---+---+---+---+
S[i]:   | B | B | R | R | R | B | B |
        +---+---+---+---+---+---+---+
                  ↑   ↑   ↑
               ←―RRR―→ がある！
```

この場合、`S[2] === S[3] === S[4] === 'R'` なので、**3つ連続で同じ色が存在します**。

このことから、「塗る操作によってこの状態を作ることが可能」であると判断できます。

**結論：Yes**

---

## ✅ 実際のコードの動き

```javascript
function canPaintTiles(N, S) {
  for (let i = 0; i <= N - 3; i++) {
    if (S[i] === S[i + 1] && S[i + 1] === S[i + 2]) {
      return "Yes";
    }
  }
  return "No";
}
```

### 流れ：

1. 文字列 `S` の先頭から末尾-2 まで `i` をループ。
2. 各位置 `i` で `S[i] == S[i+1] == S[i+2]` を確認。
3. 一致したらすぐ `Yes`。
4. 1箇所もなければ `No`。

---

## 💡 補足：なぜそれだけで良いのか？

* 操作は「**3連続の同色**しか作れない」＝3連続の同色が **必要条件**
* また、同色3連があれば、それを起点にうまく繋げて全体を作れる（十分条件）
* このことから、「3連続の同色の有無」を見るだけで正否が判定可能

---

## ✅ 時間・空間計算量

* 時間：**O(N)**（最大20万文字でも高速）
* 空間：**O(1)**（余分な配列なし）

---

## ✨ 最後に：まとめ

| ポイント   | 説明                                 |
| ------ | ---------------------------------- |
| 操作内容   | 3マス同色に塗るのみ                         |
| 作れる形   | `RRR`, `BBB` を組み合わせた構造のみ           |
| チェック方法 | `S[i] == S[i+1] == S[i+2]` の場所があるか |
| 成功条件   | どこか1箇所でも3連同色が存在すればOK               |

---
