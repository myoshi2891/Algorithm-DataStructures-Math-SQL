了解しました ✅
では、TypeScript 実装を基に「**各処理を図解付きで解析・説明**」します。
入力例として **`nums = [1,1,2]`** を使います。

---

# 1. ソート処理

```ts
nums.sort((a, b) => a - b);
```

* 入力: `[1,1,2]`
* 出力: `[1,1,2]`（既にソート済み）

ソートすることで「重複判定（同じ数が連続して出てくるかどうか）」が簡単になります。

```
[ 1 , 1 , 2 ]
   ↑   ↑   ↑
  index=0,1,2
```

---

# 2. 使用状態管理

```ts
const used: boolean[] = new Array(nums.length).fill(false);
```

* `used = [false, false, false]`
  → 各インデックスの要素が「順列に使われたか」を管理する配列。

```
nums = [1, 1, 2]
used = [F, F, F]
```

---

# 3. バックトラッキング開始

初期状態:

```
path = []        （現在の構築中の順列）
res = []         （完成した順列のリスト）
```

---

# 4. 再帰探索の流れ

## (1) 1つ目の数字選択

* i=0 → `nums[0] = 1` を選択
* `used = [T, F, F]`
* `path = [1]`

```
path = [1]
used = [T, F, F]
```

---

## (2) 2つ目の数字選択

* i=0 → skip（既に used\[0]=true）

* i=1 → `nums[1] = 1` を選択
  （注意: i=1 の数字は i=0 と同じ "1" だが、i=0 が使われているので選択可能）

* `used = [T, T, F]`

* `path = [1, 1]`

```
path = [1, 1]
used = [T, T, F]
```

---

## (3) 3つ目の数字選択

* i=0, i=1 → skip（使用済み）

* i=2 → `nums[2] = 2` を選択

* `used = [T, T, T]`

* `path = [1, 1, 2]` → 完成！

```
✅ 完成: [1,1,2]
```

---

# 5. バックトラック（戻る）

* 最後の要素 `2` を外す
* `path = [1,1]` → `path = [1]` → `path = []` へ戻る
* `used` も順に `false` に戻す

```
探索の木構造（例 nums=[1,1,2]）

               []
        ┌──────┼──────┐
       [1]    [1]    [2]
       (i=0)  (i=1)  (i=2)
        │       │      │
      [1,1]  [1,2]  [2,1]
        │       │      │
    [1,1,2] [1,2,1] [2,1,1]
     完成!   完成!   完成!
```

---

# 6. 重複回避の仕組み

```ts
if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) continue;
```

例:

* nums = `[1,1,2]`
* i=1 の "1" を選ぶときに、直前の "1"（i=0）が未使用ならスキップ
  → `[1@i=1, 1@i=0]` のように「順序だけ違う同じ数字のパターン」を防止できる

図で示すと:

```
nums = [1, 1, 2]

探索 i=1 のとき
 └── nums[1] == nums[0] && !used[0] → skip
```

---

# 7. 結果

探索完了後:

```
res = [
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

---

# 処理のまとめ

1. **ソート** → 重複検出が容易になる
2. **used 配列** → どの要素を使用中か管理
3. **バックトラッキング** → 再帰的に順列を構築
4. **重複スキップ条件** → 同じ値の無駄な探索を排除
5. **全探索木** をたどってユニークな順列を生成

---

👉 次は、この処理の「**実行時のスタックの動き（再帰呼び出しの流れ）**」を図解しましょうか？
