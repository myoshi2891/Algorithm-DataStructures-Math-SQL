以下では、**Rolling Hashを用いた文字列一致ペア数カウント処理**の全体的な処理フローを、**ステップごとに図とともに詳しく解説**します。

---

# 🔄 処理全体の流れ

```
           +------------------------+
           |  入力：N個の文字列 S_i |
           +------------------------+
                       |
                       v
          +----------------------------+
          | Rolling Hash 値を2種計算   |
          | (mod P1, base X1),         |
          | (mod P2, base X2)          |
          +----------------------------+
                       |
                       v
        +-----------------------------------+
        | ハッシュペア (h1, h2) を dict に保存 |
        +-----------------------------------+
                       |
                       v
       +----------------------------------------+
       | dict に格納されたカウントで組合せ数を集計 |
       |    nC2 = n(n-1)/2                       |
       +----------------------------------------+
                       |
                       v
               +------------------+
               |    結果を出力     |
               +------------------+
```

---

## ① 入力読み込み

```python
n: int = int(input_lines[0])
strings: List[str] = input_lines[1:n+1]
```

### 🔸図解：

```
入力: n = 6
文字列リスト:
[
  "NANA",
  "HELLO",
  "KAKA",
  "HELLO",
  "NANA",
  "NANA"
]
```

---

## ② Rolling Hash 計算（`compute_rolling_hash`）

```python
def compute_rolling_hash(s: str, p: int, x: int) -> int:
    hash_val = 0
    for c in s:
        hash_val = (hash_val * x + ord(c)) % p
    return hash_val
```

### 🔸図解：Rolling Hashの動作例（P = 10^9+7, X = 911）

対象: `"NANA"`

```
文字      ASCII     Hashの計算
----     ------     ------------------------------
 'N'       78     → 0 * 911 + 78 = 78
 'A'       65     → 78 * 911 + 65 = 71123
 'N'       78     → 71123 * 911 + 78 = ...
 'A'       65     → ... → h1 = 最終値 mod P
```

この操作を P1, X1 と P2, X2 の2回行い、以下のようなペアを得ます：

```
"NANA" → (h1, h2)
```

---

## ③ ハッシュマップへ格納

```python
hash_map: dict[Tuple[int, int], int] = {}

key = (h1, h2)
hash_map[key] = hash_map.get(key, 0) + 1
```

### 🔸図解：dict による文字列の分布管理

```
hash_map:  (h1, h2) -> 出現回数

{
  (1234, 4321): 3  ← "NANA"
  (5678, 8765): 2  ← "HELLO"
  (9999, 1111): 1  ← "KAKA"
}
```

---

## ④ ペアの個数を計算

```python
for freq in hash_map.values():
    if freq >= 2:
        count += freq * (freq - 1) // 2
```

### 🔸図解：nC2（組合せ）を使って重複ペアを数える

| 文字列     | 出現回数 | ペア数 = nC2 |
| ------- | ---- | --------- |
| "NANA"  | 3    | 3C2 = 3   |
| "HELLO" | 2    | 2C2 = 1   |
| "KAKA"  | 1    | -         |
|         | 合計   | **4**     |

---

## ⑤ 処理時間とメモリの計測

```python
start_time = time.perf_counter()
tracemalloc.start()
...
end_time = time.perf_counter()
current, peak = tracemalloc.get_traced_memory()
```

### 🔸図解：

```
処理時間: end - start
メモリ使用量: peak
```

---

## 🔚 出力結果

```python
print(result)        # → 4
print(stderr出力)     # → 処理時間・メモリ
```

---

# 📊 処理性能まとめ

| 項目      | 内容                        |
| ------- | ------------------------- |
| 時間計算量   | O(N \* L) （N:文字列数, L:平均長） |
| 空間計算量   | O(N) （ユニーク文字列の数）          |
| 衝突対策    | 2つのハッシュ関数（P1,X1とP2,X2）を併用 |
| メモリ使用量  | 数MB程度（文字列が多くても圧縮管理）       |
| 処理時間（例） | 約 5ms（N = 50000程度）        |

---

## ✍️ 補足：衝突対策の必要性

ハッシュ衝突が起きると、**異なる文字列が同一と誤判定される**可能性があります。

例：

```
H("PAIZA") == H("HELLO") → 偽陽性ペアがカウントされてしまう
```

### 解決策：

* 大きな素数を使った mod
* 複数の hash 関数を組み合わせる（今回の実装）

---

ご希望があれば：

* 🔧 Rolling Hash の可視化（アニメーション/段階別図）
* 🧪 ユニットテスト
* 📝 高速版のC++移植

も可能です。お気軽にご依頼ください。
