// この問題は「雨水をトラップする」典型的なアルゴリズム問題ですね。効率的な解法として、左右から2つのポインタを使うアプローチを実装します。この解法の特徴とメリット：

// **アルゴリズムの詳細:**
// 1. **Two Pointer Approach**: 左右から同時にポインタを進めることで、1回の走査で解決
// 2. **最適化のポイント**: より低い最大高度を持つ側から処理することで、確実に水がトラップできる量を計算
// 3. **メモリ効率**: 追加の配列を使わず、変数のみで解決

// **計算量:**
// - 時間計算量: O(n) - 配列を一度だけ走査
// - 空間計算量: O(1) - 定数個の変数のみ使用

// **動作例 (height = [0,1,0,2,1,0,1,3,2,1,2,1]):**
// - 左右のポインタが中央に向かって進みながら、各位置で水がトラップできるかを判定
// - leftMaxとrightMaxを更新しながら、現在の高さとの差分を累積
// - 結果として6単位の水がトラップされる

// この実装はLeetCodeでの実行において、時間・メモリ両方で効率的な解法となります。

/**
 * 雨水をトラップする量を計算する関数
 * 
 * @param {number[]} height - 各位置の高さを表す配列（非負整数）
 * @return {number} - トラップできる雨水の総量
 * 
 * 時間計算量: O(n) - 配列を一度だけ走査
 * 空間計算量: O(1) - 追加の配列を使用しない
 * 
 * アルゴリズム:
 * 1. 左右から2つのポインタを使用
 * 2. 各ポインタで現在までの最大高度を追跡
 * 3. より低い最大高度を持つ側から処理を進める
 * 4. 現在の高さが最大高度より低い場合、差分が水の量
 */
function trap(height) {
    // 空配列または要素が1個以下の場合は水をトラップできない
    if (!height || height.length <= 2) {
        return 0;
    }
    
    let left = 0;                    // 左ポインタ
    let right = height.length - 1;   // 右ポインタ
    let leftMax = 0;                 // 左側の最大高度
    let rightMax = 0;                // 右側の最大高度
    let water = 0;                   // トラップされた水の総量
    
    // 左右のポインタが交差するまで処理を続ける
    while (left < right) {
        // 左側の高さが右側より低い場合
        if (height[left] < height[right]) {
            // 左側の最大高度を更新するか、水をトラップ
            if (height[left] >= leftMax) {
                leftMax = height[left];
            } else {
                // 現在の高さが最大高度より低い場合、差分が水の量
                water += leftMax - height[left];
            }
            left++;
        } else {
            // 右側の高さが左側以上の場合
            // 右側の最大高度を更新するか、水をトラップ
            if (height[right] >= rightMax) {
                rightMax = height[right];
            } else {
                // 現在の高さが最大高度より低い場合、差分が水の量
                water += rightMax - height[right];
            }
            right--;
        }
    }
    
    return water;
}