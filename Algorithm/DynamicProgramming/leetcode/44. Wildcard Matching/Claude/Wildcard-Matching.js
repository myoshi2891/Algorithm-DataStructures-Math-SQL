// この問題はワイルドカードパターンマッチングの実装です。動的プログラミングを使用して効率的に解決します。この解法の特徴：

// 1. **動的プログラミング**: 2次元のDPテーブルを使用して、部分問題の結果を保存し再利用します。

// 2. **時間計算量**: O(s.length × p.length) - 各セルを一度だけ計算します。

// 3. **空間計算量**: O(s.length × p.length) - DPテーブルのサイズです。

// 4. **最適化のポイント**:
//    - ベースケースを適切に設定（空文字列と`*`の連続の処理）
//    - `*`の処理では2つのケースを論理和で結合
//    - 不必要な条件分岐を避けてシンプルな実装

// 5. **パターンの処理**:
//    - `'?'`: 任意の1文字にマッチ
//    - `'*'`: 空文字列または任意の文字列にマッチ
//    - 通常の文字: 完全一致のみ

// この実装はLeetCodeの制約（文字列長 ≤ 2000）に対して十分効率的で、メモリ使用量も最適化されています。

/**
 * ワイルドカードパターンマッチングを実装する関数
 * @param {string} s - 入力文字列
 * @param {string} p - パターン文字列（'?'と'*'を含む可能性あり）
 * @return {boolean} - パターンが文字列全体にマッチするかどうか
 */
function isMatch(s, p) {
    const sLen = s.length;
    const pLen = p.length;

    // DPテーブル: dp[i][j] = s[0...i-1]とp[0...j-1]がマッチするかどうか
    const dp = Array(sLen + 1)
        .fill()
        .map(() => Array(pLen + 1).fill(false));

    // ベースケース: 空文字列と空パターンはマッチ
    dp[0][0] = true;

    // パターンの先頭が'*'の連続の場合、空文字列ともマッチする可能性がある
    for (let j = 1; j <= pLen; j++) {
        if (p[j - 1] === '*') {
            dp[0][j] = dp[0][j - 1];
        }
    }

    // DPテーブルを埋める
    for (let i = 1; i <= sLen; i++) {
        for (let j = 1; j <= pLen; j++) {
            const sChar = s[i - 1];
            const pChar = p[j - 1];

            if (pChar === '*') {
                // '*'は以下のケースでマッチ:
                // 1. '*'を空文字列として扱う: dp[i][j-1]
                // 2. '*'を1文字以上として扱う: dp[i-1][j]
                dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
            } else if (pChar === '?' || pChar === sChar) {
                // '?'は任意の1文字、または文字が完全一致
                dp[i][j] = dp[i - 1][j - 1];
            }
            // それ以外の場合はfalse（既に初期化済み）
        }
    }

    return dp[sLen][pLen];
}
