[A09 - Winter in ALGO Kingdom](https://atcoder.jp/contests/tessoku-book/tasks/tessoku_book_i)

この問題は「2次元累積和」や「差分配列」を利用すると効率的に解くことができます。各操作を単純にループで処理すると時間がかかりすぎるため、差分配列を用いて効率化します。

### アプローチ

1. **差分配列を作成**:  
   操作のたびに直接マス目を更新するのではなく、差分配列を用いて範囲加算を行います。具体的には、範囲の左上と右下のポイントに値を加減して、後で累積和を取ることで最終的な結果を得ます。

2. **累積和を計算**:  
   差分配列を基に、最終的な積雪量を計算します。

### 実装ステップ

1. 差分配列 `diff` を `(H+2) x (W+2)` のサイズで初期化（範囲外アクセス防止のため）。
2. 各日の範囲更新を差分配列に反映。
3. 縦方向と横方向に累積和を取って最終的な積雪量を求める。

### JavaScript のコード

```javascript
const fs = require('fs');

// 標準入力の読み込み
const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\n');
const [H, W, N] = input[0].split(' ').map(Number);

// 差分配列の初期化 (H+2 x W+2)
const diff = Array.from({ length: H + 2 }, () => Array(W + 2).fill(0));

// 差分配列への更新
for (let i = 1; i <= N; i++) {
    let [A, B, C, D] = input[i].split(' ').map(Number);

    // 差分の反映
    diff[A][B] += 1;
    diff[C + 1][B] -= 1;
    diff[A][D + 1] -= 1;
    diff[C + 1][D + 1] += 1;
}

// 縦方向の累積和
for (let i = 1; i <= H; i++) {
    for (let j = 1; j <= W; j++) {
        diff[i][j] += diff[i - 1][j];
    }
}

// 横方向の累積和
for (let i = 1; i <= H; i++) {
    for (let j = 1; j <= W; j++) {
        diff[i][j] += diff[i][j - 1];
    }
}

// 結果の出力
let result = [];
for (let i = 1; i <= H; i++) {
    result.push(diff[i].slice(1, W + 1).join(' '));
}
console.log(result.join('\n'));
```

### 説明

1. **差分配列の更新**:
    - `diff[A][B] += 1`：左上の点に1を加える。
    - `diff[C + 1][B] -= 1`：下に1つ外れた位置に-1。
    - `diff[A][D + 1] -= 1`：右に1つ外れた位置に-1。
    - `diff[C + 1][D + 1] += 1`：右下の外れた角に+1。

2. **累積和**:
    - 最初に縦方向の累積和を計算して、次に横方向の累積和を計算します。これで最終的な積雪量が求められます。

### 入力例と出力例

**入力:**

```
5 5 2
1 1 3 3
2 2 4 4
```

**出力:**

```
1 1 1 0 0
1 2 2 1 0
1 2 2 1 0
0 1 1 1 0
0 0 0 0 0
```

差分配列を \((H+2) \times (W+2)\) のサイズで初期化する理由について

### 1. **範囲外アクセス防止のため**

差分配列を使う際には、元の配列の範囲外にアクセスする場面が出てきます。特に、右端や下端に対して差分を適用する場合に、配列の外側に影響を与えるためです。

#### 具体例で説明

例えば、元のグリッドサイズが \( H \times W \) の場合、次のように差分を適用します。

1. **範囲加算の基本操作**:
    - 雪が降る範囲が \((A, B)\) から \((C, D)\) までの長方形だとします。
    - 差分配列 `diff` に対して以下の操作を行います。

    ```
    diff[A][B] += 1;
    diff[C + 1][B] -= 1;
    diff[A][D + 1] -= 1;
    diff[C + 1][D + 1] += 1;
    ```

2. **範囲外アクセスが発生するケース**:
    - `diff[C + 1][B]` や `diff[A][D + 1]`、`diff[C + 1][D + 1]` で \( C+1 \) や \( D+1 \) が \( H \) や \( W \) を超える場合、範囲外アクセスが発生します。
    - これを防ぐために、配列サイズを \( H+2 \) および \( W+2 \) にしておくと、どんな場合でも安全にアクセスできます。

---

### 2. **なぜ +2 なのか？**

- **+1 だけでは足りない理由**:
    - \( C+1 \) や \( D+1 \) にアクセスするために +1 するだけでは、累積和を取る際に端の要素の計算が不完全になる可能性があります。特に、最後の行や列に対して累積和を計算する際、1行・1列分の余裕が必要です。

- **+2 することで全てのケースをカバー**:
    - **1つ目の +1** は範囲外にアクセスするための余裕。
    - **2つ目の +1** は累積和の計算時に端の処理が簡単になるための余裕です。

### 図でイメージ

例えば \( H = 5, W = 5 \) の場合:

```
元のグリッド:      差分配列:
(1,1)-(5,5)         (0,0)-(7,7)  ← 余分に2行2列の余裕
```

- **実際に使う部分**は (1,1) から (5,5) までですが、更新操作で (6,6) にアクセスする可能性があるため、(7,7) まで確保します。

---

### 3. **まとめ**

- 差分配列を \( H+2 \times W+2 \) で初期化することで、範囲外アクセスの心配がなくなり、コードがシンプルでエラーの少ないものになります。
- 境界条件を気にせずに処理できるため、特に大規模なデータを扱うときに効率的です。

### 結果

| 言語                             | コード長  | 実行時間 | メモリ    |
| -------------------------------- | --------- | -------- | --------- |
| Go (go 1.20.6)                   | 1388 Byte | 326 ms   | 47284 KB  |
| PHP (php 8.2.8)                  | 953 Byte  | 353 ms   | 56860 KB  |
| TypeScript 5.1 (Node.js 18.16.1) | 1195 Byte | 317 ms   | 154336 KB |
