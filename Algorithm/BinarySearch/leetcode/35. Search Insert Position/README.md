以下に、`searchInsert` 関数の各処理を **図解付きで具体的に解析** します。

対象は TypeScript 実装です。

---

## 1. 問題設定

入力配列 `nums` は **昇順にソート済みかつ重複なし**。

例:

```
nums   = [1, 3, 5, 6]
target = 5
```

探索対象は **`5`** です。

---

## 2. 初期設定

```typescript
let left = 0;
let right = nums.length - 1;
```

- `left = 0`
- `right = 3` (配列長4なので `3`)

**図1: 初期ポインタ位置**

```
index : 0   1   2   3
nums  : 1   3   5   6
         ^           ^
       left        right
```

---

## 3. 中央インデックス計算

```typescript
const mid = left + ((right - left) >> 1);
```

- 1回目: `mid = 0 + ((3-0) >> 1) = 1`

**図2: mid計算後**

```
index : 0   1   2   3
nums  : 1   3   5   6
         ^   M       ^
       left mid    right
```

---

## 4. 比較処理

```typescript
if (nums[mid] === target) { ... }
else if (nums[mid] < target) { ... }
else { ... }
```

1回目:

- `nums[mid] = 3`
- `target = 5`
- `3 < 5` なので **右半分を探索**

```typescript
left = mid + 1; // left = 2
```

**図3: 範囲更新後**

```
index : 0   1   2   3
nums  : 1   3   5   6
                 ^   ^
               left right
```

---

## 5. 2回目ループ

```typescript
mid = left + ((right-left)>>1)
    = 2 + ((3-2)>>1)
    = 2
```

- `nums[mid] = 5`
- `target = 5`

```typescript
if (nums[mid] === target) return mid;
```

**図4: 発見**

```
index : 0   1   2   3
nums  : 1   3   5   6
                 M
                 ↑
               target発見
```

戻り値は **2**。

---

## 6. targetが存在しない場合

例:

```
nums   = [1,3,5,6]
target = 2
```

処理の変化を図示:

1. 初期

```
nums  : 1   3   5   6
         ^           ^
       left        right
```

2. 1回目 `mid=1` → `nums[1]=3` > 2 → 左探索

```
nums  : 1   3   5   6
         ^ L         ^
         0           0
left=0, right=0
```

3. 2回目 `mid=0` → `nums[0]=1` < 2 → 右探索

```
nums  : 1   3   5   6
             L
left=1, right=0
```

- ループ終了 (`left=1 > right=0`)
- 挿入位置は `left=1` → `[1, 2, 3, 5, 6]` となる

---

## 7. 計算量とメモリ解析

- **ループ回数**は最大で `log2(n)` 回
    - `n=10^4` の場合でも最大約 14回

- **メモリ消費**
    - 使用変数: `left`, `right`, `mid` のみ → O(1)

---

この図解をつけることで、二分探索の挙動と **挿入位置が `left` になる理由** が直感的に理解できます。

---

この可視化ツールでは、Binary Search アルゴリズムの各処理を段階的に解析できます：

## 🔍 **主要な解析ポイント**

### **1. アルゴリズムの流れ**

- **初期化**: `left=0`, `right=n-1` で検索範囲を設定
- **中点計算**: オーバーフロー防止のため `left + ⌊(right-left)/2⌋` を使用
- **比較処理**: `nums[mid]` と `target` を比較
- **範囲更新**: 条件に応じて検索範囲を半分に削減

### **2. 視覚的な理解**

- **青色 (L)**: Left ポインター
- **紫色 (R)**: Right ポインター
- **オレンジ (M)**: Mid ポインター
- **緑色**: ターゲット発見
- **グレー**: 除外された範囲

### **3. 時間計算量 O(log n) の理由**

各ステップで検索範囲を半分に削減するため：

- n=4 → 最大3回の比較
- n=1000 → 最大10回の比較
- n=1,000,000 → 最大20回の比較

### **4. 挿入位置の自動決定**

ターゲットが見つからない場合、`left` ポインターが：

- 常に「ターゲット以上の最小要素の位置」を維持
- 自然に正しい挿入位置を指す

上記の可視化ツールで3つの例を試すことで、アルゴリズムの動作原理を完全に理解できます！
