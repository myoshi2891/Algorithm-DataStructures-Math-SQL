以下では、TypeScript で実装した `countAndSay(n)` 関数の各処理について、**図解・具体例**を使って詳細に解析・説明します。

---

## ✅ 基本概要（復習）

**Count-and-Say シーケンス**は次のように定義されます：

```
countAndSay(1) = "1"
countAndSay(n) = countAndSay(n - 1) に対するランレングス圧縮（RLE）
```

---

## ✅ TypeScript 実装の再掲

```typescript
function countAndSay(n: number): string {
  if (n === 1) return "1";

  let result: string = "1";

  for (let i = 2; i <= n; i++) {
    let temp: string[] = [];
    let count: number = 1;

    for (let j = 1; j <= result.length; j++) {
      if (result[j] === result[j - 1]) {
        count++;
      } else {
        temp.push(count.toString());
        temp.push(result[j - 1]);
        count = 1;
      }
    }

    result = temp.join("");
  }

  return result;
}
```

---

## ✅ 処理フロー図解：n = 5 の場合

### ステップ 1: 初期化

```
n = 1 → "1"
```

```
result = "1"
```

---

### ステップ 2: 2回目（i = 2）

**入力**: `"1"`
**処理**:

```
1文字目: '1'
→ 次の文字が undefined → 出力に "1" 個の '1' = "11"
```

```
temp = ["1", "1"]
result = "11"
```

---

### ステップ 3: 3回目（i = 3）

**入力**: `"11"`
**処理フロー図**:

```
Index:     0   1
文字列:    1   1
               ↑ (次の文字が違う or 終端 → 出力)
→ "2個の1" → "21"
```

```
temp = ["2", "1"]
result = "21"
```

---

### ステップ 4: 4回目（i = 4）

**入力**: `"21"`
**処理フロー図**:

```
Index:     0   1
文字列:    2   1
         ↑ ↑（異なる文字 → 出力）
→ "1個の2" → "12"
→ "1個の1" → "11"
→ 合計: "1211"
```

```
temp = ["1", "2", "1", "1"]
result = "1211"
```

---

### ステップ 5: 5回目（i = 5）

**入力**: `"1211"`
**処理フロー図**:

```
Index:     0   1   2   3
文字列:    1   2   1   1
         ↑   ↑   ↑   ↑
         │   │   └─同じ→2個の1
         │   └─出力: 1個の2
         └─出力: 1個の1
→ "111221"
```

```
temp = ["1", "1", "1", "2", "2", "1"]
result = "111221"
```

---

## ✅ 各ループ内の動作を図で再現（文字列 `"1211"` の解析）

| `j` | `result[j]` | `result[j - 1]` | `count` | 操作内容            | tempの中身                          |
| --- | ----------- | --------------- | ------- | --------------- | -------------------------------- |
| 1   | `'2'`       | `'1'`           | 1       | 出力: `"1" + "1"` | `["1", "1"]`                     |
| 2   | `'1'`       | `'2'`           | 1       | 出力: `"1" + "2"` | `["1", "1", "1", "2"]`           |
| 3   | `'1'`       | `'1'`           | 2       | 出力: `"2" + "1"` | `["1", "1", "1", "2", "2", "1"]` |

---

## ✅ 全体のイメージ（シーケンス図）

```text
n=1   : "1"
n=2   : "11"       (one 1)
n=3   : "21"       (two 1s)
n=4   : "1211"     (one 2, one 1)
n=5   : "111221"   (one 1, one 2, two 1s)
n=6   : "312211"   (three 1s, two 2s, one 1)
```

---

## ✅ 時間・空間解析（図式）

### 時間計算量 O(n \* m)

```
各ステップで前の文字列を1文字ずつ読む → O(m)
これを n 回繰り返す → O(n * m)
```

例：

```text
n = 1 : length 1
n = 2 : length 2
n = 3 : length 2
n = 4 : length 4
n = 5 : length 6
n = 6 : length 6
...
```

### 空間計算量 O(m)

```text
temp: 新しい文字列の配列 → 毎回文字列長分だけ保持
```

---

## ✅ まとめ

| 観点    | 内容                          |
| ----- | --------------------------- |
| 方法    | 文字列を1文字ずつ走査し、RLE圧縮          |
| データ構造 | `string`, `string[]`        |
| 時間計算量 | O(n \* m)（n: 回数, m: 出力文字列長） |
| 空間計算量 | O(m)（出力文字列を一時保存）            |
| 図解    | 各ループの流れや処理が明確に見える構造化        |

---

図や構造をさらに視覚化して画像化することも可能です。必要であればリクエストしてください。
