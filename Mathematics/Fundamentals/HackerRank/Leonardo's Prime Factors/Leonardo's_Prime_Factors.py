# 以下は **HackerRank 形式**（I/O なし・関数実装のみ、型付き）での回答です。
# ※ 複数クエリ環境ではジャッジ側が `primeCount(n: int) -> int` を都度呼び出します。

# ---

# # 1. 問題分析（要点）

# * 任意の (n) 以下で**相異なる素因数の個数**を最大化する数は、**小さい素数から順に掛け合わせた積（Primorial）** になる。
#   例：(2,\ 2\cdot3,\ 2\cdot3\cdot5,\ 2\cdot3\cdot5\cdot7,\ldots)

# * よって、求める値は
#   **最大の (k)（(k\ge 0)）であって (\prod_{i=1}^{k} p_i \le n)** を満たすもの。
#   （ここで (p_i) は第 (i) 素数、空積は 1 とし (k=0) で値 1）

# * 実運用上、(n\le 10^{10}) 程度なら (k) は 10 程度、(n\le 10^{18}) でも 15 前後で頭打ち。
#   ⇒ **素数を小さい順に生成し、累積積が (n) を超えるまで増やすだけ**で高速。

# ---

# # 2. アルゴリズム比較表

# | アプローチ | 概要                             |                       時間計算量 |  空間計算量 | 実装コスト | 可読性 | CPython 観点 | 備考                   |
# | ----- | ------------------------------ | --------------------------: | -----: | ----: | --- | ---------- | -------------------- |
# | 方法A   | 素数を逐次生成（試し割り）しつつ Primorial を更新 | (O(k\sqrt{p_k})) だが (k) が極小 | (O(k)) |     低 | 高   | 小さなループのみ   | 本解法                  |
# | 方法B   | 小さな素数をタプルで**ハードコード**           |                      (O(k)) | (O(1)) |     低 | 中   | ブランチ少なく高速  | 上限を見積もって 100 まで用意でも可 |

# > 実務視点：保守性と安全性から **方法A** を採用（入力上限が変わっても壊れない）。
# > 競プロ視点：どちらでも十分高速。

# ---

# # 3. Python 最適化ポイント

# * ループは `while`／`for` を素直に。桁外れに大きな (n) でも `k` が小さいためオーバーヘッドは無視可。
# * 試し割りの上限は `d*d <= x`。奇数のみ走査。
# * 例外や重いバリデーションは省略（競技プラットフォーム前提）。

# ---

# # 4. 採用実装（HackerRank 用関数のみ）

# ```python
# from typing import Final


def primeCount(n: int) -> int:
    """
    Return the maximum number of distinct prime factors of any number in [1, n].
    Strategy: count how many consecutive small primes we can multiply before exceeding n.
    """
    if n < 2:
        return 0  # 1 以下には素因数を 1 個以上持つ数は存在しない

    # 小さい素数を順に供給するジェネレータ
    def primes():
        yield 2
        p: int = 3
        # 必要な分だけ動的生成（k は非常に小さいためこの試し割りで十分）
        while True:
            if _is_prime(p):
                yield p
            p += 2  # 偶数はスキップ

    def _is_prime(x: int) -> bool:
        if x < 2:
            return False
        if x % 2 == 0:
            return x == 2
        d: int = 3
        while d * d <= x:
            if x % d == 0:
                return False
            d += 2
        return True

    count: int = 0
    prod: int = 1
    for p in primes():
        # 次の素数を掛けたときに n を超えるかを確認
        if prod * p > n:
            break
        prod *= p
        count += 1
    return count


# ```

# ---

# # 5. 検証の観点（抜粋）

# * 境界：`n=1 -> 0`, `n=2 -> 1`, `n=3 -> 1`, `n=6 -> 2`, `n=30 -> 3`。
# * 例：`n=500 -> 4（2*3*5*7=210 <= 500, 次の*11で2310>500）`、`n=10_000_000_000 -> 10`（サンプル一致）。
# * 型：`int` のみ、I/O 無し（HackerRank 仕様準拠）。

# ---

# ## 付録：競技／業務それぞれの観点

# * **競技**：この実装で TLE/MLE の心配はほぼゼロ。`n` の桁が増えても `k` は非常に小さく、`_is_prime` の総コストも小さい。
# * **業務**：将来の上限変更にも壊れにくい。必要なら方法B（小素数のタプルを固定）に切替可能。
