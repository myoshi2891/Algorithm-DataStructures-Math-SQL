では、先ほど提示した **TypeScript版 `combinationSum`** の処理を、
図を使って流れを「見える化」しながら解析していきます。

---

## 1. 問題イメージ

**入力例**

```
candidates = [2, 3, 6, 7]
target = 7
```

**求めたい出力**

```
[[2, 2, 3], [7]]
```

* 同じ数字は何度も使える
* 組み合わせの順序は問わない（\[2,3,2] は \[2,2,3] と同じ）
* 同じ組み合わせを2度返さないようにする

---

## 2. DFS（深さ優先探索）＋バックトラッキングの流れ

### 全体構造

```
dfs(startIndex, currentSum)
    ↓
候補を順に試す
    ↓
    if sum === target → 結果に追加
    if sum > target → 中止（枝刈り）
    else → 再帰で探索を続ける
```

---

## 3. 実行フローの図解（例: candidates = \[2, 3, 6, 7], target = 7）

### ステップ 0: 初期状態

```
res = []
path = []
dfs(0, 0) 開始
```

---

### ステップ 1: i = 0（候補: 2）

```
path = [2], sum = 2
↓
dfs(0, 2)  ← 同じ2を再利用できる
```

---

### ステップ 2: i = 0（候補: 2）

```
path = [2, 2], sum = 4
↓
dfs(0, 4)
```

---

### ステップ 3: i = 0（候補: 2）

```
path = [2, 2, 2], sum = 6
↓
dfs(0, 6)
```

---

### ステップ 4: i = 0（候補: 2）

```
sum = 8 (> target) → 枝刈り → 戻る
path = [2, 2] に戻る
```

---

### ステップ 5: i = 1（候補: 3）

```
path = [2, 2, 3], sum = 7
sum === target → res に追加
res = [[2, 2, 3]]
↓
戻って path = [2, 2]
```

---

### ステップ 6: i = 2（候補: 6）

```
sum = 10 (> target) → 枝刈り
```

---

### ステップ 7: i = 3（候補: 7）

```
sum = 11 (> target) → 枝刈り
↓
戻って path = [2]
```

---

### ステップ 8: i = 1（候補: 3）

```
path = [2, 3], sum = 5
↓
dfs(1, 5)
```

---

### ステップ 9: i = 1（候補: 3）

```
sum = 8 (> target) → 枝刈り
```

---

### ステップ 10: i = 2（候補: 6）

```
sum = 11 (> target) → 枝刈り
```

---

### ステップ 11: i = 3（候補: 7）

```
sum = 12 (> target) → 枝刈り
↓
戻って path = []
```

---

### ステップ 12: i = 3（候補: 7）

```
path = [7], sum = 7
sum === target → res に追加
res = [[2, 2, 3], [7]]
```

---

## 4. 探索ツリー図

```
start(0,0)
├─ 2 → (0,2)
│   ├─ 2 → (0,4)
│   │   ├─ 2 → (0,6)
│   │   │   ├─ 2 → 8 ✗
│   │   │   ├─ 3 → 7 ✓
│   │   │   ├─ 6 → 12 ✗
│   │   │   └─ 7 → 13 ✗
│   │   ├─ 3 → 9 ✗
│   │   ├─ 6 → 10 ✗
│   │   └─ 7 → 11 ✗
│   ├─ 3 → (1,5)
│   │   ├─ 3 → 8 ✗
│   │   ├─ 6 → 11 ✗
│   │   └─ 7 → 12 ✗
│   ├─ 6 → 8 ✗
│   └─ 7 → 9 ✗
├─ 3 → (1,3) ...
└─ 7 → (3,7) ✓
```

---

## 5. 処理のポイント

* **インデックス`start`を使う理由**

  * 同じ数字の順序違いを防止（\[2,3,2]と\[2,2,3]を重複させない）
* **枝刈り (`if nextSum > target`)**

  * 無駄な探索を早期終了
* **`path`を使ったバックトラッキング**

  * 配列をコピーして結果に保存後、最後の要素を削除して戻る
