では、先ほどの **TypeScript 実装 `myPow(x, n)`** の各処理について、**図を使ってステップごとに解析・説明**していきます。
例として `x = 2.0, n = 10` を用います。

---

## 1. 入力と前処理

```ts
let N: number = n;
if (N < 0) {
    x = 1 / x;
    N = -N;
}
```

- `n` が負のときは、逆数に変換して **正の指数に直す**。
- 今回は `n = 10` なのでそのまま。

```
入力: x = 2.0, n = 10
N = 10 (正なので変換不要)
```

---

## 2. 初期化

```ts
let result: number = 1.0;
let base: number = x;
```

- `result` は最終的な答えを蓄積していく変数。最初は 1。
- `base` は累乗計算に使う基数。最初は `x`（= 2）。

```
result = 1
base   = 2
N      = 10
```

---

## 3. while ループ処理（Exponentiation by Squaring）

ループ条件: `while (N > 0)`

### 1回目（N = 10, 偶数）

```
N = 10 → 偶数
  → result そのまま
  → base = base^2 = 2^2 = 4
  → N = N / 2 = 10 / 2 = 5
```

```
result = 1
base   = 4
N      = 5
```

---

### 2回目（N = 5, 奇数）

```
N = 5 → 奇数
  → result *= base = 1 * 4 = 4
  → base = base^2 = 4^2 = 16
  → N = N // 2 = 5 // 2 = 2
```

```
result = 4
base   = 16
N      = 2
```

---

### 3回目（N = 2, 偶数）

```
N = 2 → 偶数
  → result そのまま
  → base = base^2 = 16^2 = 256
  → N = N / 2 = 2 / 2 = 1
```

```
result = 4
base   = 256
N      = 1
```

---

### 4回目（N = 1, 奇数）

```
N = 1 → 奇数
  → result *= base = 4 * 256 = 1024
  → base = base^2 = 256^2 = 65536
  → N = N // 2 = 1 // 2 = 0
```

```
result = 1024
base   = 65536
N      = 0
```

---

## 4. ループ終了 & 出力

```ts
return result; // 1024
```

最終的に答えは **1024**。

---

## 🔎 処理フローの図解

```
初期状態:
 result = 1, base = 2, N = 10

Step1: (N=10 偶数)
 result = 1, base = 4, N = 5

Step2: (N=5 奇数)
 result = 4, base = 16, N = 2

Step3: (N=2 偶数)
 result = 4, base = 256, N = 1

Step4: (N=1 奇数)
 result = 1024, base = 65536, N = 0

終了: result = 1024
```

---

## ⚡ 計算量とメモリ解析

- **時間計算量:**
    - 各ループで `N` を半分にするため、反復回数は `O(log |n|)`。
    - 例: `n = 10^9` でも約 30 回で終了。

- **空間計算量:**
    - ループ内で使うのは定数個の変数 (`result`, `base`, `N`) のみ。
    - 再帰を使わないため **O(1)**。

---

👉 次のステップとして、このアルゴリズムを **負の指数 (例: x=2, n=-2)** でも図解してみましょうか？
了解しました ✅
では、先ほどの **TypeScript 実装 `myPow(x, n)`** の各処理について、**図を使ってステップごとに解析・説明**していきます。
例として `x = 2.0, n = 10` を用います。

---

## 1. 入力と前処理

```ts
let N: number = n;
if (N < 0) {
    x = 1 / x;
    N = -N;
}
```

- `n` が負のときは、逆数に変換して **正の指数に直す**。
- 今回は `n = 10` なのでそのまま。

```
入力: x = 2.0, n = 10
N = 10 (正なので変換不要)
```

---

## 2. 初期化

```ts
let result: number = 1.0;
let base: number = x;
```

- `result` は最終的な答えを蓄積していく変数。最初は 1。
- `base` は累乗計算に使う基数。最初は `x`（= 2）。

```
result = 1
base   = 2
N      = 10
```

---

## 3. while ループ処理（Exponentiation by Squaring）

ループ条件: `while (N > 0)`

### 1回目（N = 10, 偶数）

```
N = 10 → 偶数
  → result そのまま
  → base = base^2 = 2^2 = 4
  → N = N / 2 = 10 / 2 = 5
```

```
result = 1
base   = 4
N      = 5
```

---

### 2回目（N = 5, 奇数）

```
N = 5 → 奇数
  → result *= base = 1 * 4 = 4
  → base = base^2 = 4^2 = 16
  → N = N // 2 = 5 // 2 = 2
```

```
result = 4
base   = 16
N      = 2
```

---

### 3回目（N = 2, 偶数）

```
N = 2 → 偶数
  → result そのまま
  → base = base^2 = 16^2 = 256
  → N = N / 2 = 2 / 2 = 1
```

```
result = 4
base   = 256
N      = 1
```

---

### 4回目（N = 1, 奇数）

```
N = 1 → 奇数
  → result *= base = 4 * 256 = 1024
  → base = base^2 = 256^2 = 65536
  → N = N // 2 = 1 // 2 = 0
```

```
result = 1024
base   = 65536
N      = 0
```

---

## 4. ループ終了 & 出力

```ts
return result; // 1024
```

最終的に答えは **1024**。

---

## 🔎 処理フローの図解

```
初期状態:
 result = 1, base = 2, N = 10

Step1: (N=10 偶数)
 result = 1, base = 4, N = 5

Step2: (N=5 奇数)
 result = 4, base = 16, N = 2

Step3: (N=2 偶数)
 result = 4, base = 256, N = 1

Step4: (N=1 奇数)
 result = 1024, base = 65536, N = 0

終了: result = 1024
```

---

## ⚡ 計算量とメモリ解析

- **時間計算量:**
    - 各ループで `N` を半分にするため、反復回数は `O(log |n|)`。
    - 例: `n = 10^9` でも約 30 回で終了。

- **空間計算量:**
    - ループ内で使うのは定数個の変数 (`result`, `base`, `N`) のみ。
    - 再帰を使わないため **O(1)**。

---

👉 次のステップとして、このアルゴリズムを **負の指数 (例: x=2, n=-2)** でも図解してみましょうか？
