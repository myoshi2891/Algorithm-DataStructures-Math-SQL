<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>文字列掛け算アルゴリズムの詳細解析</title>
        <style>
            body {
                font-family: 'Arial', sans-serif;
                line-height: 1.6;
                margin: 0;
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: #333;
                min-height: 100vh;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                background: white;
                border-radius: 15px;
                padding: 30px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            }

            h1 {
                color: #4a5568;
                text-align: center;
                margin-bottom: 30px;
                font-size: 2.5em;
                background: linear-gradient(45deg, #667eea, #764ba2);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }

            h2 {
                color: #2d3748;
                border-bottom: 3px solid #667eea;
                padding-bottom: 10px;
                margin-top: 40px;
            }

            .step-container {
                background: #f7fafc;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
                border-left: 5px solid #667eea;
            }

            .grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
                gap: 2px;
                margin: 15px 0;
                max-width: 600px;
            }

            .cell {
                background: #e2e8f0;
                border: 2px solid #cbd5e0;
                padding: 10px;
                text-align: center;
                font-weight: bold;
                border-radius: 5px;
                transition: all 0.3s ease;
            }

            .cell.highlight {
                background: #fed7d7;
                border-color: #f56565;
                transform: scale(1.05);
            }

            .cell.result {
                background: #c6f6d5;
                border-color: #38a169;
            }

            .cell.carry {
                background: #fbb6ce;
                border-color: #d53f8c;
            }

            .multiplication-table {
                background: white;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .process-flow {
                display: flex;
                align-items: center;
                margin: 20px 0;
                flex-wrap: wrap;
            }

            .process-step {
                background: #667eea;
                color: white;
                padding: 15px 20px;
                border-radius: 25px;
                margin: 5px;
                font-weight: bold;
                box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
            }

            .arrow {
                font-size: 24px;
                color: #667eea;
                margin: 0 10px;
            }

            .example-box {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                padding: 25px;
                border-radius: 15px;
                margin: 20px 0;
            }

            .code-block {
                background: #2d3748;
                color: #e2e8f0;
                padding: 20px;
                border-radius: 10px;
                font-family: 'Courier New', monospace;
                margin: 15px 0;
                overflow-x: auto;
            }

            .complexity-badge {
                display: inline-block;
                background: #38a169;
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-weight: bold;
                margin: 5px;
            }

            .interactive-demo {
                background: #f7fafc;
                padding: 25px;
                border-radius: 15px;
                margin: 20px 0;
                border: 2px dashed #667eea;
            }

            input {
                padding: 12px;
                border: 2px solid #cbd5e0;
                border-radius: 8px;
                margin: 10px 5px;
                font-size: 16px;
                width: 120px;
            }

            button {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 25px;
                cursor: pointer;
                font-weight: bold;
                font-size: 16px;
                transition: transform 0.2s ease;
            }

            button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(102, 126, 234, 0.3);
            }

            #result {
                font-size: 20px;
                font-weight: bold;
                color: #38a169;
                margin-top: 15px;
            }

            .visualization {
                background: white;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }
        </style>
    </head>

    <body>
        <div class="container">
            <h1>文字列掛け算アルゴリズムの詳細解析</h1>

            <h2>🎯 アルゴリズム概要</h2>
            <div class="step-container">
                <p>
                    このアルゴリズムは<strong>筆算の掛け算</strong>を模倣して、文字列として表現された大きな数の掛け算を実現します。
                </p>
                <div class="process-flow">
                    <div class="process-step">入力検証</div>
                    <span class="arrow">→</span>
                    <div class="process-step">配列初期化</div>
                    <span class="arrow">→</span>
                    <div class="process-step">桁ごと掛け算</div>
                    <span class="arrow">→</span>
                    <div class="process-step">繰り上がり処理</div>
                    <span class="arrow">→</span>
                    <div class="process-step">文字列変換</div>
                </div>
            </div>

            <h2>📊 具体例での動作解析：123 × 456</h2>
            <div class="example-box">
                <h3>Step 1: 初期化</h3>
                <p>num1 = "123" (長さ 3), num2 = "456" (長さ 3)</p>
                <p>結果配列サイズ: 3 + 3 = 6</p>
            </div>

            <div class="visualization">
                <h3>Step 2: 配列のインデックス構造</h3>
                <div class="grid" style="grid-template-columns: repeat(6, 1fr)">
                    <div class="cell">0</div>
                    <div class="cell">1</div>
                    <div class="cell">2</div>
                    <div class="cell">3</div>
                    <div class="cell">4</div>
                    <div class="cell">5</div>
                </div>
                <p><strong>result[0] result[1] result[2] result[3] result[4] result[5]</strong></p>
                <p>初期値: [0, 0, 0, 0, 0, 0]</p>
            </div>

            <div class="multiplication-table">
                <h3>Step 3: 筆算の掛け算処理</h3>
                <div style="font-family: monospace; font-size: 18px; line-height: 1.8">
                    <div style="text-align: center; margin-bottom: 20px">
                        <div style="color: #667eea">1 2 3</div>
                        <div style="color: #764ba2">× 4 5 6</div>
                        <div style="border-bottom: 2px solid #333">─────────</div>
                    </div>
                </div>

                <h4>各桁の掛け算とインデックス計算:</h4>
                <div class="code-block">
                    i=2, j=2: 3×6=18 → p1=4, p2=5 → result[5]=8, result[4]=1 i=2, j=1: 3×5=15 →
                    p1=3, p2=4 → sum=15+1=16 → result[4]=6, result[3]=1 i=2, j=0: 3×4=12 → p1=2,
                    p2=3 → sum=12+1=13 → result[3]=3, result[2]=1 i=1, j=2: 2×6=12 → p1=3, p2=4 →
                    sum=12+6=18 → result[4]=8, result[3]=4 i=1, j=1: 2×5=10 → p1=2, p2=3 →
                    sum=10+4=14 → result[3]=4, result[2]=2 i=1, j=0: 2×4=8 → p1=1, p2=2 → sum=8+2=10
                    → result[2]=0, result[1]=1 i=0, j=2: 1×6=6 → p1=2, p2=3 → sum=6+4=10 →
                    result[3]=0, result[2]=1 i=0, j=1: 1×5=5 → p1=1, p2=2 → sum=5+1=6 → result[2]=6,
                    result[1]=1 i=0, j=0: 1×4=4 → p1=0, p2=1 → sum=4+1=5 → result[1]=5, result[0]=0
                </div>
            </div>

            <div class="visualization">
                <h3>Step 4: 最終結果配列</h3>
                <div class="grid" style="grid-template-columns: repeat(6, 1fr)">
                    <div class="cell">0</div>
                    <div class="cell result">5</div>
                    <div class="cell result">6</div>
                    <div class="cell result">0</div>
                    <div class="cell result">8</div>
                    <div class="cell result">8</div>
                </div>
                <p>先頭の0を除去: "56088"</p>
            </div>

            <h2>🔍 詳細な処理フロー</h2>

            <div class="step-container">
                <h3>1. 特殊ケース処理</h3>
                <div class="code-block">
                    if (num1 === "0" || num2 === "0") { return "0"; // 早期終了でパフォーマンス向上
                    }
                </div>
            </div>

            <div class="step-container">
                <h3>2. インデックス計算ロジック</h3>
                <p><strong>重要:</strong> 筆算での桁の位置を配列インデックスにマッピング</p>
                <div class="code-block">
                    p1 = i + j // 上位桁（繰り上がり先） p2 = i + j + 1 // 下位桁（現在の結果） 例:
                    i=1, j=2 の場合 p1 = 1 + 2 = 3 p2 = 1 + 2 + 1 = 4
                </div>
            </div>

            <div class="step-container">
                <h3>3. 繰り上がり処理</h3>
                <div class="code-block">
                    const sum = mul + result[p2]; // 現在の値に加算 result[p2] = sum % 10; //
                    1桁のみ保持 result[p1] += Math.floor(sum / 10); // 繰り上がりを加算
                </div>
            </div>

            <h2>⚡ パフォーマンス分析</h2>
            <div class="step-container">
                <h3>計算量</h3>
                <div class="complexity-badge">時間計算量: O(m × n)</div>
                <div class="complexity-badge">空間計算量: O(m + n)</div>

                <h4>最適化ポイント:</h4>
                <ul>
                    <li><strong>早期終了:</strong> "0" の特殊ケース処理</li>
                    <li><strong>効率的な配列操作:</strong> インデックス計算による直接アクセス</li>
                    <li><strong>最小限の文字列操作:</strong> 最後に一度だけ join() を実行</li>
                    <li><strong>メモリ効率:</strong> 固定サイズの配列使用</li>
                </ul>
            </div>

            <h2>🎮 インタラクティブデモ</h2>
            <div class="interactive-demo">
                <h3>実際に試してみましょう！</h3>
                <div>
                    <input type="text" id="num1" placeholder="数値1" value="123" />
                    <span>×</span>
                    <input type="text" id="num2" placeholder="数値2" value="456" />
                    <button onclick="demoMultiply()">計算実行</button>
                </div>
                <div id="result"></div>
                <div id="process"></div>
            </div>

            <h2>🔧 TypeScript実装の利点</h2>
            <div class="step-container">
                <h4>型安全性による利点:</h4>
                <ul>
                    <li><strong>コンパイル時チェック:</strong> 型エラーの事前検出</li>
                    <li><strong>IDE支援:</strong> 自動補完とリファクタリング</li>
                    <li><strong>保守性向上:</strong> 意図的でない型変換の防止</li>
                    <li><strong>ドキュメント化:</strong> 型注釈による仕様の明確化</li>
                </ul>
            </div>
        </div>

        <script>
            function multiply(num1, num2) {
                if (num1 === '0' || num2 === '0') {
                    return '0';
                }

                const m = num1.length;
                const n = num2.length;
                const result = new Array(m + n).fill(0);

                for (let i = m - 1; i >= 0; i--) {
                    for (let j = n - 1; j >= 0; j--) {
                        const mul = parseInt(num1[i]) * parseInt(num2[j]);
                        const p1 = i + j;
                        const p2 = i + j + 1;
                        const sum = mul + result[p2];

                        result[p2] = sum % 10;
                        result[p1] += Math.floor(sum / 10);
                    }
                }

                let start = 0;
                while (start < result.length && result[start] === 0) {
                    start++;
                }

                return result.slice(start).join('');
            }

            function demoMultiply() {
                const num1 = document.getElementById('num1').value;
                const num2 = document.getElementById('num2').value;

                if (!num1 || !num2 || !/^\d+$/.test(num1) || !/^\d+$/.test(num2)) {
                    document.getElementById('result').innerHTML =
                        '<span style="color: #e53e3e;">正の整数を入力してください</span>';
                    return;
                }

                const startTime = performance.now();
                const result = multiply(num1, num2);
                const endTime = performance.now();

                document.getElementById('result').innerHTML = `<strong>結果: ${result}</strong><br>
                 <small>計算時間: ${(endTime - startTime).toFixed(4)}ms</small>`;

                // プロセス表示
                let processHtml = '<h4 style="margin-top: 20px;">計算プロセス:</h4>';
                processHtml += `<div style="font-family: monospace;">`;
                processHtml += `配列サイズ: ${num1.length + num2.length}<br>`;
                processHtml += `ループ回数: ${num1.length} × ${num2.length} = ${num1.length * num2.length}<br>`;
                processHtml += `</div>`;

                document.getElementById('process').innerHTML = processHtml;
            }

            // 初期デモ実行
            window.onload = function () {
                demoMultiply();
            };
        </script>
    </body>
</html>
