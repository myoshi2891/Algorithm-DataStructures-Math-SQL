<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Card Query Algorithm Analysis</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                margin: 0;
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: #333;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                background: rgba(255, 255, 255, 0.95);
                border-radius: 15px;
                padding: 30px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            }

            h1 {
                text-align: center;
                color: #4a5568;
                margin-bottom: 30px;
                font-size: 2.5em;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            }

            h2 {
                color: #2d3748;
                border-left: 5px solid #667eea;
                padding-left: 15px;
                margin-top: 40px;
            }

            h3 {
                color: #4a5568;
                background: linear-gradient(90deg, #f7fafc, transparent);
                padding: 10px 15px;
                border-radius: 8px;
            }

            .algorithm-section {
                margin: 30px 0;
                padding: 20px;
                border: 2px solid #e2e8f0;
                border-radius: 10px;
                background: #f8f9fa;
            }

            .visualization {
                background: white;
                padding: 20px;
                border-radius: 10px;
                margin: 20px 0;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .array-container {
                display: flex;
                justify-content: center;
                margin: 20px 0;
                flex-wrap: wrap;
            }

            .array-element {
                width: 50px;
                height: 50px;
                border: 2px solid #667eea;
                display: flex;
                align-items: center;
                justify-content: center;
                margin: 2px;
                font-weight: bold;
                border-radius: 8px;
                transition: all 0.3s ease;
            }

            .array-element.highlight {
                background: #ffd700;
                border-color: #ff6b6b;
                transform: scale(1.1);
            }

            .array-element.target {
                background: #ff6b6b;
                color: white;
                border-color: #c92a2a;
            }

            .array-element.comparison {
                background: #74c0fc;
                border-color: #339af0;
            }

            .step-explanation {
                background: #e3f2fd;
                padding: 15px;
                border-radius: 8px;
                margin: 15px 0;
                border-left: 4px solid #2196f3;
            }

            .complexity-table {
                width: 100%;
                border-collapse: collapse;
                margin: 20px 0;
                background: white;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            }

            .complexity-table th,
            .complexity-table td {
                padding: 12px 15px;
                text-align: left;
                border-bottom: 1px solid #e2e8f0;
            }

            .complexity-table th {
                background: #667eea;
                color: white;
                font-weight: 600;
            }

            .complexity-table tr:hover {
                background: #f8f9fa;
            }

            .binary-search-demo {
                margin: 20px 0;
            }

            .search-step {
                margin: 15px 0;
                padding: 15px;
                background: #f1f8ff;
                border-radius: 8px;
                border-left: 4px solid #0066cc;
            }

            .pointer {
                font-size: 0.8em;
                color: #666;
                margin-top: 5px;
            }

            .insertion-demo {
                margin: 20px 0;
            }

            .before-after {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                margin: 20px 0;
            }

            .demo-section {
                background: white;
                padding: 15px;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            .arrow {
                text-align: center;
                font-size: 2em;
                color: #667eea;
                margin: 10px 0;
            }

            .legend {
                display: flex;
                justify-content: center;
                gap: 20px;
                margin: 20px 0;
                flex-wrap: wrap;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .legend-color {
                width: 20px;
                height: 20px;
                border-radius: 4px;
                border: 2px solid #333;
            }

            .interactive-demo {
                background: white;
                padding: 20px;
                border-radius: 10px;
                margin: 20px 0;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            }

            .demo-controls {
                display: flex;
                gap: 10px;
                margin: 15px 0;
                flex-wrap: wrap;
                justify-content: center;
            }

            .demo-button {
                padding: 10px 20px;
                background: #667eea;
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                transition: all 0.3s ease;
            }

            .demo-button:hover {
                background: #5a67d8;
                transform: translateY(-2px);
            }

            .demo-input {
                padding: 8px 12px;
                border: 2px solid #e2e8f0;
                border-radius: 6px;
                font-size: 16px;
            }

            .result-display {
                background: #f0fff4;
                padding: 15px;
                border-radius: 8px;
                margin: 15px 0;
                border: 2px solid #38a169;
                font-weight: bold;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <div class="container">
            <h1>🃏 Card Query Algorithm 詳細解析</h1>

            <div class="algorithm-section">
                <h2>📝 問題の概要</h2>
                <p><strong>目標：</strong> 以下の2種類のクエリを効率的に処理する</p>
                <ul>
                    <li><strong>クエリ1：</strong> 値xのカードを机に追加</li>
                    <li>
                        <strong>クエリ2：</strong> 値xと机上のカードとの差の絶対値の最小値を求める
                    </li>
                </ul>
            </div>

            <div class="algorithm-section">
                <h2>🔍 二分探索（Lower Bound）の動作原理</h2>
                <h3>アルゴリズムの概要</h3>
                <p>ソートされた配列で、target以上の値が最初に現れる位置を効率的に見つけます。</p>

                <div class="visualization">
                    <h4>例：配列 [10, 20, 30, 40, 50] で target = 25 を検索</h4>
                    <div class="binary-search-demo" id="binarySearchDemo">
                        <div class="search-step">
                            <strong>初期状態:</strong>
                            <div class="array-container">
                                <div class="array-element">10</div>
                                <div class="array-element">20</div>
                                <div class="array-element">30</div>
                                <div class="array-element">40</div>
                                <div class="array-element">50</div>
                            </div>
                            <div class="pointer">left=0, right=5, target=25</div>
                        </div>

                        <div class="search-step">
                            <strong>Step 1:</strong> mid = (0+5)/2 = 2, arr[2] = 30
                            <div class="array-container">
                                <div class="array-element">10</div>
                                <div class="array-element">20</div>
                                <div class="array-element highlight">30</div>
                                <div class="array-element">40</div>
                                <div class="array-element">50</div>
                            </div>
                            <div class="pointer">30 ≥ 25 なので right = 2</div>
                        </div>

                        <div class="search-step">
                            <strong>Step 2:</strong> mid = (0+2)/2 = 1, arr[1] = 20
                            <div class="array-container">
                                <div class="array-element">10</div>
                                <div class="array-element highlight">20</div>
                                <div class="array-element">30</div>
                                <div class="array-element">40</div>
                                <div class="array-element">50</div>
                            </div>
                            <div class="pointer">20 < 25 なので left=2</div>
                        </div>

                        <div class="search-step">
                            <strong>結果:</strong> left = right = 2 → 位置2に挿入
                            <div class="array-container">
                                <div class="array-element">10</div>
                                <div class="array-element">20</div>
                                <div class="array-element target">25</div>
                                <div class="array-element">30</div>
                                <div class="array-element">40</div>
                                <div class="array-element">50</div>
                            </div>
                            <div class="pointer">挿入後もソート順を保持</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="algorithm-section">
                <h2>➕ カード挿入（Insert Sorted）の動作</h2>
                <h3>処理の流れ</h3>

                <div class="visualization">
                    <h4>例：配列 [10, 30, 40] に値 25 を挿入</h4>
                    <div class="insertion-demo">
                        <div class="before-after">
                            <div class="demo-section">
                                <h5>挿入前</h5>
                                <div class="array-container">
                                    <div class="array-element">10</div>
                                    <div class="array-element">30</div>
                                    <div class="array-element">40</div>
                                </div>
                            </div>
                            <div class="demo-section">
                                <h5>挿入後</h5>
                                <div class="array-container">
                                    <div class="array-element">10</div>
                                    <div class="array-element target">25</div>
                                    <div class="array-element">30</div>
                                    <div class="array-element">40</div>
                                </div>
                            </div>
                        </div>
                        <div class="step-explanation">
                            <strong>手順:</strong>
                            <ol>
                                <li>二分探索で挿入位置を特定 (位置1)</li>
                                <li>Array.splice(1, 0, 25) で挿入実行</li>
                                <li>内部的に位置1以降の要素を右にシフト</li>
                            </ol>
                        </div>
                    </div>
                </div>
            </div>

            <div class="algorithm-section">
                <h2>🎯 最小差検索（Find Min Difference）の動作</h2>
                <h3>アルゴリズムの戦略</h3>
                <p>ソートされた配列の特性を活用し、target値に最も近い値を効率的に見つけます。</p>

                <div class="visualization">
                    <h4>例：配列 [10, 25, 30, 40] で target = 27 の最小差を検索</h4>
                    <div class="search-step">
                        <strong>Step 1:</strong> 二分探索で 27 以上の最初の位置を特定
                        <div class="array-container">
                            <div class="array-element">10</div>
                            <div class="array-element">25</div>
                            <div class="array-element highlight">30</div>
                            <div class="array-element">40</div>
                        </div>
                        <div class="pointer">pos = 2 (値30の位置)</div>
                    </div>

                    <div class="search-step">
                        <strong>Step 2:</strong> 候補となる値との差を計算
                        <div class="array-container">
                            <div class="array-element">10</div>
                            <div class="array-element comparison">25</div>
                            <div class="array-element comparison">30</div>
                            <div class="array-element">40</div>
                        </div>
                        <div class="pointer">
                            |30 - 27| = 3, |25 - 27| = 2<br />
                            最小値 = 2
                        </div>
                    </div>

                    <div class="step-explanation">
                        <strong>重要なポイント:</strong>
                        <ul>
                            <li>
                                ソートされた配列では、targetに最も近い値は必ずlowerBound位置かその直前にある
                            </li>
                            <li>他の全ての値をチェックする必要がない（O(1)で決定可能）</li>
                            <li>最大2回の比較で最小差を特定</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="algorithm-section">
                <h2>📊 計算量解析</h2>
                <table class="complexity-table">
                    <thead>
                        <tr>
                            <th>操作</th>
                            <th>時間計算量</th>
                            <th>空間計算量</th>
                            <th>説明</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>二分探索 (Lower Bound)</td>
                            <td>O(log n)</td>
                            <td>O(1)</td>
                            <td>配列を半分ずつ絞り込み</td>
                        </tr>
                        <tr>
                            <td>カード挿入</td>
                            <td>O(n)</td>
                            <td>O(1)</td>
                            <td>要素の右シフトが主なコスト</td>
                        </tr>
                        <tr>
                            <td>最小差検索</td>
                            <td>O(log n)</td>
                            <td>O(1)</td>
                            <td>二分探索 + 定数回の比較</td>
                        </tr>
                        <tr>
                            <td>全体（Q回のクエリ）</td>
                            <td>O(Q × n)</td>
                            <td>O(n)</td>
                            <td>最悪ケースでの総計算量</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="algorithm-section">
                <h2>🎮 インタラクティブデモ</h2>
                <div class="interactive-demo">
                    <h4>アルゴリズムを実際に動作させてみましょう！</h4>

                    <div class="demo-controls">
                        <input
                            type="number"
                            id="cardValue"
                            class="demo-input"
                            placeholder="カードの値"
                            value="25"
                        />
                        <button class="demo-button" onclick="addCard()">カード追加</button>
                        <input
                            type="number"
                            id="searchValue"
                            class="demo-input"
                            placeholder="検索する値"
                            value="27"
                        />
                        <button class="demo-button" onclick="findMinDiff()">最小差検索</button>
                        <button class="demo-button" onclick="resetDemo()">リセット</button>
                    </div>

                    <div class="visualization">
                        <h5>現在の配列:</h5>
                        <div class="array-container" id="currentArray">
                            <div style="color: #666; font-style: italic">カードがありません</div>
                        </div>
                        <div id="result" class="result-display" style="display: none"></div>
                    </div>

                    <div class="legend">
                        <div class="legend-item">
                            <div
                                class="legend-color"
                                style="background: #ffd700; border-color: #ff6b6b"
                            ></div>
                            <span>検索中の要素</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff6b6b"></div>
                            <span>挿入される値</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #74c0fc"></div>
                            <span>比較対象</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="algorithm-section">
                <h2>🚀 パフォーマンス最適化のポイント</h2>
                <div class="step-explanation">
                    <h4>1. データ構造の選択</h4>
                    <ul>
                        <li><strong>配列:</strong> メモリ効率が良く、二分探索に適している</li>
                        <li>
                            <strong>ソート維持:</strong>
                            挿入時にソート順を保持することで検索を高速化
                        </li>
                    </ul>
                </div>

                <div class="step-explanation">
                    <h4>2. アルゴリズムの工夫</h4>
                    <ul>
                        <li><strong>二分探索:</strong> O(log n)の検索により大量データでも高速</li>
                        <li><strong>最小差計算:</strong> 全要素をチェックせず、候補を2個に絞る</li>
                    </ul>
                </div>

                <div class="step-explanation">
                    <h4>3. メモリ効率</h4>
                    <ul>
                        <li><strong>単一配列:</strong> 余計なデータ構造を使わない</li>
                        <li><strong>インプレース操作:</strong> 追加のメモリ使用を最小限に抑制</li>
                    </ul>
                </div>
            </div>
        </div>

        <script>
            let cards = [];

            function updateArrayDisplay() {
                const container = document.getElementById('currentArray');
                container.innerHTML = '';

                if (cards.length === 0) {
                    container.innerHTML =
                        '<div style="color: #666; font-style: italic;">カードがありません</div>';
                    return;
                }

                cards.forEach((card) => {
                    const element = document.createElement('div');
                    element.className = 'array-element';
                    element.textContent = card;
                    container.appendChild(element);
                });
            }

            function lowerBound(arr, target) {
                let left = 0;
                let right = arr.length;

                while (left < right) {
                    const mid = Math.floor((left + right) / 2);
                    if (arr[mid] < target) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }

                return left;
            }

            function addCard() {
                const input = document.getElementById('cardValue');
                const value = parseInt(input.value);

                if (isNaN(value)) {
                    alert('有効な数値を入力してください');
                    return;
                }

                // 既存のカードがある場合はチェック
                if (cards.includes(value)) {
                    alert('そのカードは既に存在します');
                    return;
                }

                const pos = lowerBound(cards, value);
                cards.splice(pos, 0, value);

                updateArrayDisplay();

                // 挿入された要素をハイライト
                setTimeout(() => {
                    const elements = document.querySelectorAll('.array-element');
                    if (elements[pos]) {
                        elements[pos].classList.add('target');
                        setTimeout(() => {
                            elements[pos].classList.remove('target');
                        }, 1500);
                    }
                }, 100);

                document.getElementById('result').style.display = 'none';
                input.value = '';
            }

            function findMinDiff() {
                const input = document.getElementById('searchValue');
                const value = parseInt(input.value);

                if (isNaN(value)) {
                    alert('有効な数値を入力してください');
                    return;
                }

                if (cards.length === 0) {
                    showResult('結果: -1 (カードがありません)');
                    return;
                }

                const pos = lowerBound(cards, value);
                let minDiff = Infinity;
                let candidates = [];

                // pos位置の値をチェック
                if (pos < cards.length) {
                    const diff = Math.abs(cards[pos] - value);
                    if (diff < minDiff) {
                        minDiff = diff;
                    }
                    candidates.push(pos);
                }

                // pos-1位置の値をチェック
                if (pos > 0) {
                    const diff = Math.abs(cards[pos - 1] - value);
                    if (diff < minDiff) {
                        minDiff = diff;
                    }
                    candidates.push(pos - 1);
                }

                // 候補をハイライト
                const elements = document.querySelectorAll('.array-element');
                elements.forEach((el) => el.classList.remove('comparison', 'highlight'));

                candidates.forEach((idx) => {
                    if (elements[idx]) {
                        elements[idx].classList.add('comparison');
                    }
                });

                showResult(`結果: ${minDiff} (${value}との最小差)`);
            }

            function showResult(text) {
                const resultDiv = document.getElementById('result');
                resultDiv.textContent = text;
                resultDiv.style.display = 'block';
            }

            function resetDemo() {
                cards = [];
                updateArrayDisplay();
                document.getElementById('result').style.display = 'none';
                document.getElementById('cardValue').value = '';
                document.getElementById('searchValue').value = '';
            }

            // 初期化
            updateArrayDisplay();
        </script>
    </body>
</html>
