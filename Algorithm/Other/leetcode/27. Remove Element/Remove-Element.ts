// 以下は、LeetCode の仕様に準拠した TypeScript での解法です。クラスは使わず、純粋な関数として実装しています。TypeScript 5.1（Node.js 18.16.1）環境を前提とし、型アノテーションを明示しており、インプレースで配列を書き換え、`val` を取り除いた結果の要素数 `k` を返します。

// ---

// ### ✅ TypeScript 実装

// ```typescript
/**
 * 配列 nums から指定された値 val をインプレースで削除し、
 * val 以外の要素数（新しい長さ）を返します。
 *
 * @param nums - 入力配列（number[]）、参照により直接変更される
 * @param val - 削除する値（number）
 * @returns number - val を除いた後の要素数 k
 *
 * 時間計算量: O(n) - 配列を1回走査
 * 空間計算量: O(1) - 追加メモリは使わない
 */
function removeElement(nums: number[], val: number): number {
    let k: number = 0;

    for (let i = 0; i < nums.length; i++) {
        if (nums[i] !== val) {
            nums[k] = nums[i];
            k++;
        }
    }

    return k;
}
// ```

// ---

// ### ✅ 使用例（テスト）

// ```typescript
// const nums: number[] = [0, 1, 2, 2, 3, 0, 4, 2];
// const val: number = 2;

// const k: number = removeElement(nums, val);

// console.log("k:", k); // 出力: 5
// console.log("modified nums (first k elements):", nums.slice(0, k));
// // 例: [0, 1, 3, 0, 4] のように val を除いた5要素
// ```

// ---

// ### ✅ 解説：図解（処理のイメージ）

// #### 入力：

// ```
// nums = [0,1,2,2,3,0,4,2], val = 2
// ```

// #### 変化過程（`k` は新しい位置を指す）：

// | i | nums\[i] | 処理            | k | nums（途中）                         |
// | - | -------- | ------------- | - | -------------------------------- |
// | 0 | 0        | 0をnums\[0]に代入 | 1 | \[0, \_, \_, \_, \_, \_, \_, \_] |
// | 1 | 1        | 1をnums\[1]に代入 | 2 | \[0, 1, \_, \_, \_, \_, \_, \_]  |
// | 2 | 2        | スキップ（valと一致）  | 2 | \[0, 1, \_, \_, \_, \_, \_, \_]  |
// | 3 | 2        | スキップ          | 2 | \[0, 1, \_, \_, \_, \_, \_, \_]  |
// | 4 | 3        | 3をnums\[2]に代入 | 3 | \[0, 1, 3, \_, \_, \_, \_, \_]   |
// | 5 | 0        | 0をnums\[3]に代入 | 4 | \[0, 1, 3, 0, \_, \_, \_, \_]    |
// | 6 | 4        | 4をnums\[4]に代入 | 5 | \[0, 1, 3, 0, 4, \_, \_, \_]     |
// | 7 | 2        | スキップ          | 5 | \[0, 1, 3, 0, 4, \_, \_, \_]     |

// ---

// ### ✅ パフォーマンス分析

// | 項目     | 内容                        |
// | ------ | ------------------------- |
// | 時間計算量  | **O(n)**（配列の全要素に一度ずつアクセス） |
// | 空間計算量  | **O(1)**（追加メモリは使用しない）     |
// | 最大入力長さ | 100要素（制約上）                |

// ---

// ### ✅ 補足：LeetCode Judge における確認コードの対応

// LeetCodeのカスタムジャッジは以下のように配列先頭 `k` 個の内容をチェックします：

// ```typescript
// const expectedNums: number[] = [0, 1, 3, 0, 4].sort((a, b) => a - b);
// nums.sort((a, b) => a - b);
// for (let i = 0; i < k; i++) {
//   if (nums[i] !== expectedNums[i]) {
//     throw new Error("Mismatch!");
//   }
// }
// ```

// ---

// 必要であれば、型の詳細化やユニットテストコードの追加も可能です。
