DPの各処理を、「何をしているか → どう数が増えるか」を図で追いながら、できるだけ丁寧に解説します。最後に実装上の注意点（`/dev/stderr` の件も含む）も整理します。

---

# 全体像（データフロー）

```
標準入力      解析          DP初期化          遷移ループ                 出力
────────▶ [n, a, b] ──▶ dp[0]=1, 他0 ──▶ for i=1..n: dp[i]+=dp[i-a],dp[i-b] ──▶ dp[n]
```

- **目的**: 「順序を区別した」(例: 3→4 と 4→3 は別) 到達経路の総数を数える
- **カウント対象**: ちょうど `n` 段に到達する手順列（各手は `a` 段 or `b` 段）

---

# DP の定義と遷移（矢印図で直感）

## 状態定義

- `dp[i]` = 「**i 段目に到達する方法の数**」
- 基底: `dp[0] = 1`（何もしない 1 通り）

## 遷移

- `i-a` から `i` に **a段上がる**
- `i-b` から `i` に **b段上がる**

つまり：

```
(i-a) ──( +a段 )──▶ i
(i-b) ──( +b段 )──▶ i

dp[i] = (i-a >= 0 ? dp[i-a] : 0) + (i-b >= 0 ? dp[i-b] : 0)
```

## 直線ノード＆矢印（概念図）

例として a=3, b=4 のとき：

```
0──1──2──3──4──5──6──7──8──9──10──11
        ↑  ↑     ↑  ↑   ↑    ↑    ↑
       +3 +4    +3 +4  +3   +4   +3/4 …（それぞれ左からの到達を合算）
```

- ある位置 `i` に来るルートは、**左側の `i-a` と `i-b` からの2本**。
- それぞれの「来方の数」を足し算すれば、`i` に来る**総数**になる。

---

# 例1：n=11, a=3, b=4（出力 3）

## 表での遷移追跡（上書き式）

`dp[0]=1` から始め、`i=1..11` の順に更新します。

```
i   0  1  2  3  4  5  6  7  8  9  10 11
-----------------------------------------
dp  1  0  0  1  1  0  1  2  1  1   3  3
```

### どのように埋まったか（キー地点だけ矢印で）

- i=3:

    ```
    dp[3] = dp[0] + dp[-1]=1+0=1
    0 ─( +3 )→ 3
    ```

- i=4:

    ```
    dp[4] = dp[1] + dp[0]=0+1=1
    0 ─( +4 )→ 4
    ```

- i=6:

    ```
    dp[6] = dp[3] + dp[2]=1+0=1
    3 ─( +3 )→ 6
    ```

- i=7:

    ```
    dp[7] = dp[4] + dp[3]=1+1=2
    4 ─( +3 )→ 7   と   3 ─( +4 )→ 7
    （順序の違う 2 通り：3→4、4→3）
    ```

- i=10:

    ```
    dp[10] = dp[7] + dp[6]=2+1=3
    7 ─( +3 )→ 10   と   6 ─( +4 )→ 10
    ```

- i=11:

    ```
    dp[11] = dp[8] + dp[7]=1+2=3
    8 ─( +3 )→ 11   と   7 ─( +4 )→ 11
    ```

**結論**：`dp[11] = 3`

---

# 例2：答えが 0 になる場合（n=4, a=3, b=5）

```
i   0  1  2  3  4
-----------------
dp  1  0  0  1  0
```

- i=3 は `0→3`（+3）で 1 通り
- i=4 は `1` や `-1` から来る必要があるが、**不可能** → 0
- **到達不能**のため `dp[4]=0`

### （補足）到達可能性の数論的視点

- 一般に、`ma + nb = i (m,n ≥ 0整数)` が解を持つのは **gcd(a,b) | i** のとき
- **gcd(a,b) が n を割り切らない場合、必ず 0**
- DP はこの条件を自然に反映し、到達不能は 0 のまま残ります

---

# 正しさの理由（DAG の経路数カウント）

- 各段は**一方向**（増加）のみ：`0→…→n` の **DAG**（有向非巡回グラフ）
- `i` に入る辺は「`i-a` からの +a」と「`i-b` からの +b」の高々 2 本
- DAG の**入次数分解**で、`i` の経路数 = 入り口ノードの経路数の **和**
- `dp[0]=1` を基底に、`i=1..n` を左から右へ（トポロジカル順）評価することで、**重複なし・漏れなし**に数え上げられます

---

# 計算量とメモリ

- **時間計算量**: `O(n)`（各 `i` で高々 2 回の加算）
- **空間計算量**: `O(n)`（`dp[0..n]` を保持）
    - さらに節約するなら **`O(max(a,b))` のリングバッファ**でも可
      （`dp[i]` は直近 `max(a,b)` 以内しか参照しないため）

---

# 実装上の「各処理」解説（Node.js v16.17.1）

1. **入力の取得（fs + 標準入力）**

    ```js
    const fs = require('fs');
    const [n, a, b] = fs.readFileSync('/dev/stdin', 'utf8').trim().split(/\s+/).map(Number);
    ```

    - 余分な空白に強い `split(/\s+/)` を推奨
    - `Number` 化してから DP へ

2. **DP 初期化**

    ```js
    const dp = Array(n + 1).fill(0);
    dp[0] = 1;
    ```

3. **遷移ループ（左→右へ一方向）**

    ```js
    for (let i = 1; i <= n; i++) {
        if (i - a >= 0) dp[i] += dp[i - a];
        if (i - b >= 0) dp[i] += dp[i - b];
    }
    ```

    **矢印図（抽象）**

    ```
    dp[i-a] ──(+a)──▶ dp[i]
    dp[i-b] ──(+b)──▶ dp[i]
    ```

4. **結果出力（余計な文字や空行は出さない）**

    ```js
    console.log(dp[n]);
    ```

5. **処理時間・メモリ計測（任意・標準エラー出力へ）**
    - `/dev/stderr` への `fs.writeFileSync` は環境によって **権限エラー**（今回のランタイムエラーの原因）
    - **解決**: `console.error` を使う

    ```js
    const startTime = process.hrtime.bigint();
    const startMem = process.memoryUsage().heapUsed;

    // … DP 計算 …

    const endTime = process.hrtime.bigint();
    const endMem = process.memoryUsage().heapUsed;

    // 計測結果は stderr に出したいが、ファイルではなく console.error を使う
    console.error(
        `処理時間: ${Number(endTime - startTime) / 1e6} ms\n` +
            `メモリ増分: ${(endMem - startMem) / 1024} KB`,
    );
    ```

---

# よくある落とし穴（チェックリスト）

- [ ] `dp[0] = 1` を忘れて到達数が全て 0 になる
- [ ] `i-a` / `i-b` の **境界チェック**を忘れて負 index に触る
- [ ] **順序を区別**することを見落として独自に重複除外してしまう
- [ ] 出力に余計な文字（デバッグ行）を混ぜる
- [ ] `/dev/stderr` を直接書き込み → 権限エラー（`console.error` を使う）

---

# まとめ（要点再掲）

- `dp[i] = dp[i-a] + dp[i-b]` を **左→右**で埋めれば、順序付きの通り数が求まる
- `dp[0]=1` が基点
- 到達不能は自然に `0`（数論的には `gcd(a,b) ∤ n` のとき必ず 0）
- 計測ログは `console.error` で出す（`/dev/stderr` 直書きは NG 環境あり）

図と一緒に追うと、\*\*「左からの2本の矢印を足し込むだけ」\*\*というシンプルな構図が見えるはず。これで DP の各処理が腹落ちすると思います！
