## **挿入ソート（Insertion Sort）とは？**

挿入ソートは、**配列を部分的にソート済みの状態にしながら、新しい要素を適切な位置に挿入する** ソートアルゴリズムです。  
手持ちのカードを並べるように、一つずつ適切な位置に挿入していくイメージです。

---

## **挿入ソートのアルゴリズム**

### **手順**

1. **2番目の要素（インデックス 1）からスタートする。**
2. **その要素を、前の要素と比較しながら適切な位置に挿入する。**
3. **次の要素を取り、すでにソート済みの部分と比較しながら適切な位置に挿入する。**
4. **この操作をリストの最後まで繰り返す。**

---

## **擬似コード**

```plaintext
InsertionSort(A, n)
  for i = 1 to n-1 do
    key = A[i]
    j = i - 1
    while j >= 0 and A[j] > key do
      A[j + 1] = A[j]
      j = j - 1
    A[j + 1] = key
```

---

## **JavaScriptでの実装**

```javascript
function insertionSort(arr) {
    let n = arr.length;
    for (let i = 1; i < n; i++) {
        let key = arr[i]; // 挿入する要素
        let j = i - 1;

        // ソート済み部分を後ろにシフト
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key; // 正しい位置に挿入
    }
    return arr;
}

// 実行例
let arr = [64, 25, 12, 22, 11];
console.log(insertionSort(arr)); // [11, 12, 22, 25, 64]
```

このコードでは、**未ソート部分から要素を1つ取り出し、ソート済み部分の適切な位置に挿入** することで、配列を整列させています。

---

## **挿入ソートの時間計算量**

| ケース                             | 計算量     |
| ---------------------------------- | ---------- |
| **最悪ケース**                     | \(O(n^2)\) |
| **平均ケース**                     | \(O(n^2)\) |
| **最良ケース（すでにソート済み）** | \(O(n)\)   |

### **なぜ \(O(n^2)\) なのか？**

- **外側のループが \(n\) 回実行**
- **内側のループが最悪 \(n-1\) 回実行**
- **結果として \(O(n^2)\) になる**

しかし、データがほぼソート済みの場合は内側のループがほとんど動かないため、**最良ケースでは \(O(n)\) の時間で済む** という特長があります。

---

## **挿入ソートの特徴**

### **メリット**

✅ **実装が簡単**（初心者でも理解しやすい）  
✅ **追加メモリをほとんど使わない**（in-place ソート）  
✅ **すでにソート済みなら高速 \(O(n)\)**  
✅ **安定ソート（同じ値の順序が保持される）**

### **デメリット**

❌ **処理が遅い（最悪 \(O(n^2)\)）**  
❌ **大量データには不向き**

---

## **挿入ソートの改良**

### **二分探索を用いた挿入ソート**

通常の挿入ソートでは、挿入位置を見つけるために \(O(n)\) の比較を行いますが、**二分探索を使うと \(O(\log n)\) で挿入位置を見つけることが可能** です。

```javascript
function binaryInsertionSort(arr) {
    let n = arr.length;
    for (let i = 1; i < n; i++) {
        let key = arr[i];
        let left = 0,
            right = i - 1;

        // 二分探索で挿入位置を探す
        while (left <= right) {
            let mid = Math.floor((left + right) / 2);
            if (arr[mid] > key) right = mid - 1;
            else left = mid + 1;
        }

        // 挿入位置 left に key を入れる
        for (let j = i - 1; j >= left; j--) {
            arr[j + 1] = arr[j]; // 右にシフト
        }
        arr[left] = key; // 正しい位置に挿入
    }
    return arr;
}

// 実行例
let arr = [64, 25, 12, 22, 11];
console.log(binaryInsertionSort(arr)); // [11, 12, 22, 25, 64]
```

**二分探索で挿入位置を探す時間は \(O(\log n)\) ですが、挿入のためのシフトが \(O(n)\) かかるため、最悪ケースの計算量は変わらず \(O(n^2)\) です。**

---

## **他のソートアルゴリズムとの比較**

| ソートアルゴリズム | 最悪時間計算量  | 最良時間計算量  | 平均時間計算量  | 安定性 | 追加メモリ    |
| ------------------ | --------------- | --------------- | --------------- | ------ | ------------- |
| **バブルソート**   | \(O(n^2)\)      | \(O(n)\)        | \(O(n^2)\)      | ✅     | \(O(1)\)      |
| **選択ソート**     | \(O(n^2)\)      | \(O(n^2)\)      | \(O(n^2)\)      | ❌     | \(O(1)\)      |
| **挿入ソート**     | \(O(n^2)\)      | \(O(n)\)        | \(O(n^2)\)      | ✅     | \(O(1)\)      |
| **クイックソート** | \(O(n^2)\)      | \(O(n \log n)\) | \(O(n \log n)\) | ❌     | \(O(\log n)\) |
| **マージソート**   | \(O(n \log n)\) | \(O(n \log n)\) | \(O(n \log n)\) | ✅     | \(O(n)\)      |

### **どの場面で使うべき？**

✅ **データがほぼソート済みのとき（\(O(n)\) の高速ソートが可能）**  
✅ **小規模なデータのソート（100個以下）**  
✅ **安定ソートが必要な場合**  
❌ **大量データやランダムなデータには向かない（\(O(n^2)\) で遅い）**

---

## **まとめ**

- **挿入ソートは、リストの一部をソートしながら、適切な位置に要素を挿入するアルゴリズム。**
- **時間計算量は \(O(n^2)\) だが、すでにソート済みなら \(O(n)\) で高速。**
- **安定ソートで、追加メモリ不要なため、メモリ効率が良い。**
- **小規模データやほぼ整列済みのデータには適しているが、大規模データには向かない。**
