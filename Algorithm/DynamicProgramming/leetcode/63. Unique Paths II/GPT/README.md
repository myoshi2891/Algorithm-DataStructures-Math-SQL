同じ “配列を順に回す” でも、`for` / `forEach` / `map` はランタイムや最適化ポイントがかなり違います。
ここでは **なぜホットパスでは `for` を選ぶのか** を、V8（Node.js v18）寄りに整理します。

---

# ざっくり結論

- **パフォーマンス/GC/最適化の安定性**、**早期終了**、**メモリアロケーション抑制**の観点で、**ホットループは `for` が最有力**。
- `forEach` は **コールバック呼び出しのオーバーヘッド**と**クロージャ生成**で不利。
- `map` は **必ず新しい配列を生成**するため、**副作用目的の反復**には不適＆無駄な確保が入る。

---

# 項目別の違いと判断理由

## 1) 呼び出しコスト／インライン化

- **for**
    - 本体は同一フレーム内の単純なループ。JIT最適化（ループのアンロール・バウンダリチェック削減・型の単純化）が効きやすい。

- **forEach/map**
    - 各反復で**ユーザー定義コールバック**を呼ぶ → 呼び出し境界が増える。
    - コールバックが状況により**ポリモーフィック**（引数型・捕捉変数の違い）になりやすく、**インライン失敗**や**ディオプト**（最適化解除）を招きやすい。

**→ ホットパスでは関数呼び出しを挟まない `for` が有利。**

---

## 2) GC圧／アロケーション

- **for**
    - 原則**追加アロケーションなし**（自前で新配列を作らない限り）。
    - ループ変数はプリミティブで**単型**を保ちやすい。

- **forEach**
    - コールバックが**環境（クロージャ）**を捕捉すると、その**環境オブジェクト**がヒープに載り、GC対象が増える。
    - `thisArg` の指定や可変スコープの参照で、**隠れた割当**が増えやすい。

- **map**
    - **必ず出力用の新配列を確保**（長さ n）。計算結果が不要（副作用のみ）なら**完全な無駄確保**。

**→ 余計な割当・GCを避けたいので `for`。**

---

## 3) 早期終了（break / continue / return）

- **for**
    - `break` / `continue` / `return` が素直に使える。
    - DPや探索の **「条件を満たしたら即終了」** が簡単＆高速。

- **forEach/map**
    - **早期終了構文なし**。早期終了したい場合に例外で脱出する等の**不自然なテク**が必要 → 可読性低下 + 例外コスト。

**→ 早期終了の頻度が高いループは `for` 一択。**

---

## 4) 正しさ・意味論（副作用 vs 変換）

- **for**
    - 何でもできる（副作用・集計・条件分岐・索引操作）。

- **forEach**
    - **副作用志向**のユーティリティ。返り値なし。
    - 変換・集計など**値生成**が主目的の場合は向かない。

- **map**
    - **「要素を変換して新配列を返す」** が本来の意味。
    - 副作用だけの用途で使うと**意図とズレ**、レビューで必ず指摘される。

**→ DP/集計/短絡評価ベースの処理は `for` が自然。**

---

## 5) スパース配列（穴）と要素アクセス

- **for**
    - `for (let i=0; i<len; i++)` は**穴もインデックスとして走査**（`arr[i]` は `undefined`）。
    - “穴をスキップせず一定回数回す” のに向く。

- **forEach/map**
    - 仕様上、**存在するプロパティだけ**をコールバック（**穴はスキップ**）。
    - 穴スキップが意図と一致しないケースでは挙動差がバグ源になる。

**→ 穴を含む可能性があるなら `for` のほうが挙動が予測しやすい。**

---

## 6) 長さ・変異への耐性

- **for**
    - `const len = arr.length` を**先にキャッシュ**すれば、反復中の `push` の影響を受けず安定。
    - キャッシュしなければ、意図的に**変化を追従**することも可能。

- **forEach/map**
    - 開始時に長さを取得して固定のレンジを回す（途中の `push` は既定で無視）。
    - 落とし穴にはなりにくいが、**制御の自由度は低い**。

**→ 要件に応じて挙動を選べる `for` が柔軟。**

---

## 7) V8の型安定性（Elements Kind / Hidden Class）

- **for**
    - ループ本体が単純だと、**要素種別（Smi→Double→Object）**の遷移や、プロパティ形状の**安定化**が効きやすい。

- **forEach/map**
    - コールバック内部で型を揺らす（例：最初は整数、途中で文字列を返す／代入する）と、**メガモーフィック化**して性能劣化しやすい。

**→ 型・要素種別を固定しやすい `for` が安全。**

---

## 8) デバッグ/スタックトレース/プロファイル

- **for**
    - ヒット回数や境界判定を**1つのフレーム内**で観測でき、**プロファイルが読みやすい**。

- **forEach/map**
    - コールバックに飛ぶたびにスタックが深くなり、**ホットスポットの特定がやや面倒**。

**→ パフォーマンス解析も `for` が扱いやすい。**

---

# いつ `forEach` / `map` を使う？

- **`map`**: 「**全要素を純粋関数で変換し、新配列が欲しい**」とき（不変データ指向・表層変換）。
- **`forEach`**: 「**副作用だけ**を行う軽いループで、**早期終了が要らない**」とき（ただしホットでなければ）。

> それでも **性能が重要**・**早期終了の可能性**・**GCを抑えたい** 場合は `for` を選ぶのが無難です。

---

# まとめ

- **ホットパス**・**DP/集計**・**早期終了**・**余計な割当を避ける** → **`for`**
- **純粋変換で新配列が必要** → **`map`**
- **簡単な副作用・可読性重視（非ホット）** → **`forEach`**

今回の「Unique Paths II」のような **DP更新（`dp[j] += dp[j-1]`）** は、

- コールバック不要、
- 早期終了の可能性あり（障害物で `dp[j]=0` などの分岐多数）、
- 追加アロケーションを避けたい、
  という条件が揃っているため、**`for` が最適**という判断です。

---

# 🐍 Unique Paths II (Python解析付き)

## 📖 問題概要

ロボットが左上 `(0,0)` から右下 `(m-1,n-1)` に移動する。

- 移動は **右** または **下** のみ。
- `1` は障害物、`0` は通過可能。
- ロボットは障害物のあるマスを通れない。

👉 ゴールに到達できる **異なる経路数** を求める。

---

## 🧩 アルゴリズムの流れ

1. **DPテーブルを用意**
    - `dp[i][j] = (i,j) に到達できる経路数`

2. **初期化**
    - スタート地点 `(0,0)` に障害物がなければ `dp[0][0] = 1`

3. **遷移式**
    - `dp[i][j] = dp[i-1][j] + dp[i][j-1]`
    - ただし `(i,j)` が障害物なら `dp[i][j] = 0`

---

## 📊 図解

### 入力例

```python
obstacleGrid = [
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
```

### ステップ1: DPテーブル初期化

```
(0,0) スタートに置く
dp[0][0] = 1
```

```
dp テーブル:
[1, 0, 0]
[0, 0, 0]
[0, 0, 0]
```

---

### ステップ2: 1行目を処理

- 右にしか行けないので、障害物が出たら以降は 0

```
[1, 1, 1]
[0, 0, 0]
[0, 0, 0]
```

---

### ステップ3: 1列目を処理

- 下にしか行けないので、障害物が出たら以降は 0

```
[1, 1, 1]
[1, 0, 0]
[1, 0, 0]
```

---

### ステップ4: 内側のセルを計算

- (1,1) は障害物 → 0
- (1,2) = dp\[1]\[1] + dp\[0]\[2] = 0 + 1 = 1
- (2,1) = dp\[1]\[1] + dp\[2]\[0] = 0 + 1 = 1
- (2,2) = dp\[1]\[2] + dp\[2]\[1] = 1 + 1 = 2

```
[1, 1, 1]
[1, 0, 1]
[1, 1, 2]
```

👉 ゴール (2,2) = **2**

---

## 🐍 実装 (Python)

```python
from typing import List

class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        """
        DPを用いたロボットの経路数カウント
        Time Complexity: O(m*n)
        Space Complexity: O(n)  # 1次元DP最適化
        """
        m, n = len(obstacleGrid), len(obstacleGrid[0])

        # 1次元DPテーブル
        dp = [0] * n
        dp[0] = 1 if obstacleGrid[0][0] == 0 else 0

        for i in range(m):
            for j in range(n):
                if obstacleGrid[i][j] == 1:
                    dp[j] = 0  # 障害物がある → 経路ゼロ
                elif j > 0:
                    dp[j] += dp[j - 1]  # 左からの経路を加算
        return dp[-1]
```

---

## ⚖️ 計算量解析

- **時間計算量**: `O(m*n)`
    - 各マスを1度だけ処理

- **空間計算量**: `O(n)`
    - 1行分のDP配列のみ保持

---

## 🐍 Python特有の最適化ポイント

1. **1次元DP** を採用し、リストをインプレース更新 → メモリ削減
2. `list` のみ使用（`deque` 不要） → キャッシュ効率良し
3. `sum` や `any` を避け、**明示的なforループ** → Pythonのオーバーヘッド削減

---

## ✅ まとめ

- DPを用いることで **効率的に解ける**
- Pythonでは **1次元配列最適化** が有効
- 障害物は `dp[j] = 0` で即リセット

👉 出力: **2**
