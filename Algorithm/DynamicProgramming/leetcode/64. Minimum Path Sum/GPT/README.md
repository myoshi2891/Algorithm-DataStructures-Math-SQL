なるほど 👍
それでは **README.md 形式**で、図解を交えて「最小経路和 (Minimum Path Sum)」の処理を **1ステップずつ具体的に解析**して説明します。

---

# Minimum Path Sum (最小経路和)

## 問題概要

- **入力**: m × n グリッド (非負整数)
- **出力**: 左上から右下まで移動したときの最小経路和
- **移動制約**:
    - **右** または **下** のみ

例:

```
grid = [
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]
```

最小経路: `1 → 3 → 1 → 1 → 1 = 7`

---

## アルゴリズム（DP）

- **基本アイデア**
  各セル `(i, j)` の最小コストは **上から来る場合と左から来る場合の最小値** に自分の値を加えたもの。

    数式:

    ```
    dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])
    ```

- **境界条件**
    - 1行目: 左からのみ来れる
    - 1列目: 上からのみ来れる

---

## ステップ解析（図解付き）

### Step 1. 初期状態

```
1   3   1
1   5   1
4   2   1
```

スタート地点 `(0,0)` の値はそのまま。

---

### Step 2. 1行目を累積

- 左からしか来れないので累積和にする。

```
1   4   5
1   5   1
4   2   1
```

更新式:

```
grid[0][j] = grid[0][j] + grid[0][j-1]
```

---

### Step 3. 1列目を累積

- 上からしか来れないので累積和にする。

```
1   4   5
2   5   1
6   2   1
```

更新式:

```
grid[i][0] = grid[i][0] + grid[i-1][0]
```

---

### Step 4. DP更新（内部セル）

セル `(i, j)` の更新式:

```
grid[i][j] = grid[i][j] + min(grid[i-1][j], grid[i][j-1])
```

順番に更新していく。

#### (1,1) の更新

```
grid[1][1] = 5 + min(4, 2) = 7
```

#### (1,2) の更新

```
grid[1][2] = 1 + min(5, 7) = 6
```

#### (2,1) の更新

```
grid[2][1] = 2 + min(7, 6) = 8
```

#### (2,2) の更新

```
grid[2][2] = 1 + min(6, 8) = 7
```

---

### Step 5. 完了後のDPテーブル

```
1   4   5
2   7   6
6   8   7
```

右下 `(2,2)` の値 `7` が最小経路和。

---

## 経路の可視化

経路復元をすると以下になる:

```
(0,0)=1 → (0,1)=3 → (0,2)=1
           ↓
(1,2)=1
           ↓
(2,2)=1
```

合計 = 7

---

## 計算量解析

- **時間計算量**: `O(mn)`
    - 各セルを一度だけ計算。

- **空間計算量**: `O(1)`
    - `grid` を破壊的に更新。

---

## 実装例 (Python)

```python
from typing import List

class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        # 1列目
        for i in range(1, m):
            grid[i][0] += grid[i-1][0]

        # 1行目
        for j in range(1, n):
            grid[0][j] += grid[0][j-1]

        # 内部セル
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += min(grid[i-1][j], grid[i][j-1])

        return grid[m-1][n-1]
```

---

## まとめ

- **DPを用いると効率的** (O(mn), O(1)追加空間)
- **破壊的更新によりメモリ削減**
- **図を使った累積処理の理解が重要**

---
