了解です。DPの各処理を「図」で徹底的に分解して説明します。最後に実装の注意点（時間・メモリ）と、検算用の“数式解”も添えます。

---

# 1) DP設計（状態・遷移・初期条件）

## 状態の定義

```
dp[i] = ちょうど i 個のりんごを買うための最小金額
```

## 初期条件

```
dp[0] = 0        // 何も買わないなら0円
dp[1] = a        // 1個だけなら1個パックを買う
```

## 遷移（漸化式）

```
dp[i] = min( dp[i-1] + a , dp[i-2] + b )
```

- 最後に「1個パック」を買うなら：i-1個の最適 + a
- 最後に「2個パック」を買うなら：i-2個の最適 + b

> 問題で「a < b」なので、`dp[i-1] + b` のような「最後に2個買って1個余らせる」は常に無駄（1個で十分な時に高い2個を選ぶ必要がない）です。

---

# 2) 図で理解する：状態遷移

### i に対する遷移イメージ（矢印は“どこから来るか”）

```
 ...  dp[i-3]      dp[i-2]      dp[i-1]      dp[i]
             \        |            |
              \ +b <--+            +--> +a
                     \______________/
                        2個パック     1個パック
```

- `dp[i]` は「dp\[i-1]→+a」と「dp\[i-2]→+b」の2本から“安い方”を採用します。

---

# 3) 図で辿る：実例ステップ（n=7, a=120, b=200）

まず表を“段階的に”埋めていきます。

```
i    | dp[i-2] + b    dp[i-1] + a    dp[i] = min(...)
-----+-----------------------------------------------
0    |       -              -         0
1    |       -            0+120       120
2    |   0+200(=200)    120+120(=240) 200
3    | 120+200(=320)    200+120(=320) 320
4    | 200+200(=400)    320+120(=440) 400
5    | 320+200(=520)    400+120(=520) 520
6    | 400+200(=600)    520+120(=640) 600
7    | 520+200(=720)    600+120(=720) 720
```

### “図解”で1ステップを拡大（例：i=4）

```
dp[2] = 200 ---- +b(=200) ----> 400
                              ↘
dp[3] = 320 ---- +a(=120) ----> 440

dp[4] = min(400, 440) = 400
```

- `i` を1つ進めるごとに、**左右どちら（+a or +b）の線が安いか**を選ぶだけのシンプルな比較です。
- 表のように **左（dp\[i-2]+b）** と **右（dp\[i-1]+a）** を毎回比べます。

---

# 4) 図で理解する：計算順序（テーブルを左から右へ）

```
dp[0]  dp[1]  dp[2]  dp[3]  dp[4]  ...  dp[n]
 0  →  a  →   ?   →   ?   →   ?   →      ?
          ↑      ↑      ↑
   (この2マスを使って)順々に決めていく
```

- **前から順に**（小さい i から大きい i へ）埋める“前計算型DP”です。
- `dp[i]` は **dp\[i-1] と dp\[i-2]** しか参照しないため、**左から右**に1回なめればOK。

---

# 5) ローリング配列（O(1)メモリ）も図で

配列を持たず、直近2つだけを持つ最適化です。

```
i を進めるごとに値をずらすだけ

prev2(=dp[i-2])  prev1(=dp[i-1])   next(=dp[i])
      │                │                 │
      └───────+b───────┘                 │
                      └──────+a───────────┘

更新:
next = min(prev1 + a, prev2 + b)
prev2 = prev1
prev1 = next
```

- これで常に3つの変数だけで済み、**配列不要**（O(1)メモリ）。
- もちろん答えは同一です。

---

# 6) 余剰購入（n個以上OK）について

この問題では「1個パック」と「2個パック」があるので、**どんな n でも正確に n 個**を構成できます（奇数なら最後に1個、偶数なら全て2個＋α）。
そのため“n個以上でも良い”という条件は **結果に影響しません**。DPは常に **ちょうど n 個** の最小金額を返します。

---

# 7) 実装（復習）と処理量

### 実装のポイント

- 入力は `fs.readFileSync(0,"utf8")` で一括取得。
- `dp` 配列版と **O(1)メモリ版（推奨）** は同じ出力。
- 出力は **末尾に改行**（`console.log` でOK）。

### 時間計算量

- ループは `i=2..n` の **O(n)**、上限 n=1000 なので極めて軽量。

### メモリ計算量

- 配列版：`dp` は **(n+1) 要素 ≦ 1001 要素**。
  Node.js の number は 8バイト想定 → **約 8KB** + 配列オーバーヘッド（数十KB以内）。
- O(1)版：**定数個の変数のみ** → 数十バイト程度。

---

# 8) 実装（O(1)メモリ版：おまけ）

> 既に提示の配列版とまったく同じ答えです。検証・採点仕様が配列版を仮定していなければ、こちらが最も省メモリです。

```javascript
// Node.js v16.17.1
// O(1)メモリ最適化版（出力は同一）

const fs = require('fs');

/**
 * 最小金額をDP（ローリング）で計算
 * @param {number} n - 必要なりんご個数
 * @param {number} a - 1個パックの価格
 * @param {number} b - 2個パックの価格
 * @returns {number} 最小金額（ちょうどn個）
 */
function minAppleCostRolling(n, a, b) {
    if (n === 0) return 0; // 仕様上n>=1だが安全のため
    if (n === 1) return a;

    let prev2 = 0; // dp[0]
    let prev1 = a; // dp[1]

    for (let i = 2; i <= n; i++) {
        const next = Math.min(prev1 + a, prev2 + b); // dp[i]
        prev2 = prev1; // シフト
        prev1 = next; // シフト
    }
    return prev1; // dp[n]
}

// 入出力
const [n, a, b] = fs.readFileSync(0, 'utf8').trim().split(/\s+/).map(Number);
console.log(minAppleCostRolling(n, a, b));
```

---

# 9) “数式解”での検算（図の外の豆知識）

実はこの問題は“単価比較”でも解けます（**検算用**）。

- 2個パックの“1個あたり”は `b / 2`
- 1個パックの“1個あたり”は `a`

```
もし (b < 2a) … 2個パックがお得
    偶数: (n/2) * b
    奇数: floor(n/2) * b + a

もし (b >= 2a) … 1個パックの方が得（または同等）
    n * a
```

すなわち一般式：

```
min_cost = floor(n/2) * min(b, 2a) + (n % 2) * a
```

この値と DP の `dp[n]` が一致していれば、**実装の正しさを素早く検証**できます。

---

## まとめ

- **図**（矢印・表・ローリング）で見たとおり、DPは「直前2状態からの最小遷移」を左から右へ積み上げるだけ。
- 時間は **O(n)（≦1000）**、メモリは配列版でも **数KB**、O(1)版なら **定数**。
- “n個以上OK”条件は1・2パック構成では影響なし（常にちょうど n を達成可能）。
- **数式解**で簡易に検算できるのも安心ポイントです。
