<!DOCTYPE html>
<html lang="ja">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>カッコ列対応問題の詳細解析</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                margin: 0;
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                background: white;
                border-radius: 15px;
                padding: 30px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            }

            h1 {
                text-align: center;
                color: #2c3e50;
                margin-bottom: 30px;
                font-size: 2.5em;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            }

            h2 {
                color: #34495e;
                border-left: 5px solid #3498db;
                padding-left: 15px;
                margin-top: 40px;
            }

            .algorithm-step {
                background: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
                position: relative;
            }

            .step-title {
                background: #007bff;
                color: white;
                padding: 8px 15px;
                border-radius: 20px;
                display: inline-block;
                font-weight: bold;
                margin-bottom: 15px;
            }

            .bracket-visual {
                font-family: 'Courier New', monospace;
                font-size: 24px;
                text-align: center;
                margin: 20px 0;
                background: #2c3e50;
                color: white;
                padding: 15px;
                border-radius: 8px;
                letter-spacing: 8px;
            }

            .position-labels {
                font-family: 'Courier New', monospace;
                font-size: 14px;
                text-align: center;
                margin: 10px 0;
                color: #666;
                letter-spacing: 22px;
                padding-left: 11px;
            }

            .stack-visual {
                display: flex;
                justify-content: center;
                align-items: flex-end;
                margin: 20px 0;
                height: 150px;
            }

            .stack-container {
                display: flex;
                flex-direction: column-reverse;
                align-items: center;
                margin: 0 30px;
            }

            .stack-item {
                width: 60px;
                height: 40px;
                background: #e74c3c;
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                margin: 2px 0;
                border-radius: 5px;
                font-weight: bold;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            }

            .stack-label {
                margin-top: 10px;
                font-weight: bold;
                color: #2c3e50;
            }

            .pairs-visual {
                display: flex;
                flex-wrap: wrap;
                justify-content: center;
                gap: 15px;
                margin: 20px 0;
            }

            .pair-box {
                background: #27ae60;
                color: white;
                padding: 10px 20px;
                border-radius: 25px;
                font-weight: bold;
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
                animation: fadeIn 0.5s ease-in;
            }

            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(-20px);
                }

                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .complexity-box {
                background: linear-gradient(135deg, #ff6b6b, #4ecdc4);
                color: white;
                padding: 20px;
                border-radius: 15px;
                margin: 20px 0;
                text-align: center;
            }

            .complexity-item {
                margin: 10px 0;
                font-size: 18px;
            }

            .arrow {
                font-size: 30px;
                color: #e74c3c;
                text-align: center;
                margin: 10px 0;
            }

            .highlight {
                background: #fff3cd;
                border: 1px solid #ffeaa7;
                padding: 15px;
                border-radius: 8px;
                margin: 15px 0;
            }

            .process-flow {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                margin: 30px 0;
            }

            .flow-step {
                background: #f1c40f;
                padding: 20px;
                border-radius: 10px;
                text-align: center;
                color: #2c3e50;
                font-weight: bold;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
                transition: transform 0.3s ease;
            }

            .flow-step:hover {
                transform: translateY(-5px);
            }

            .detailed-trace {
                background: #ecf0f1;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
            }

            .trace-step {
                border-bottom: 1px solid #bdc3c7;
                padding: 15px 0;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr 2fr;
                gap: 20px;
                align-items: center;
            }

            .trace-step:last-child {
                border-bottom: none;
            }

            .trace-header {
                background: #34495e;
                color: white;
                font-weight: bold;
                padding: 15px;
                margin: -20px -20px 20px -20px;
                border-radius: 10px 10px 0 0;
                display: grid;
                grid-template-columns: 1fr 1fr 1fr 2fr;
                gap: 20px;
            }

            .current-char {
                font-size: 24px;
                font-weight: bold;
                color: #e74c3c;
            }

            .memory-usage {
                background: #9b59b6;
                color: white;
                padding: 15px;
                border-radius: 10px;
                margin: 20px 0;
                text-align: center;
            }
        </style>
    </head>

    <body>
        <div class="container">
            <h1>カッコ列対応問題の詳細解析</h1>

            <div class="highlight">
                <strong>問題:</strong> 対応の取れているカッコ列 <code>(())())</code> において、どの位置のカッコ同士が対応しているかを見つける
            </div>

            <h2>1. 入力データの可視化</h2>
            <div class="algorithm-step">
                <div class="step-title">入力文字列の構造</div>
                <div class="bracket-visual">(())())</div>
                <div class="position-labels">1234567</div>
                <p>各文字の位置を1-indexedで表示しています。文字列の長さは7文字です。</p>
            </div>

            <h2>2. アルゴリズムの処理フロー</h2>
            <div class="process-flow">
                <div class="flow-step">
                    1. 左から右へ<br>文字を走査
                </div>
                <div class="flow-step">
                    2. 開きカッコ'('<br>→スタックに位置を追加
                </div>
                <div class="flow-step">
                    3. 閉じカッコ')'<br>→スタックから取得
                </div>
                <div class="flow-step">
                    4. ペアを作成<br>→結果配列に追加
                </div>
            </div>

            <h2>3. ステップバイステップの詳細実行トレース</h2>
            <div class="detailed-trace">
                <div class="trace-header">
                    <div>位置</div>
                    <div>文字</div>
                    <div>スタック状態</div>
                    <div>作成されるペア / 処理内容</div>
                </div>

                <div class="trace-step">
                    <div><strong>1</strong></div>
                    <div class="current-char">(</div>
                    <div>[1]</div>
                    <div>開きカッコなので位置1をスタックにプッシュ</div>
                </div>

                <div class="trace-step">
                    <div><strong>2</strong></div>
                    <div class="current-char">(</div>
                    <div>[1, 2]</div>
                    <div>開きカッコなので位置2をスタックにプッシュ</div>
                </div>

                <div class="trace-step">
                    <div><strong>3</strong></div>
                    <div class="current-char">)</div>
                    <div>[1]</div>
                    <div style="color: #27ae60; font-weight: bold;">ペア作成: [2, 3] - 位置2をポップして位置3と組み合わせ</div>
                </div>

                <div class="trace-step">
                    <div><strong>4</strong></div>
                    <div class="current-char">)</div>
                    <div>[]</div>
                    <div style="color: #27ae60; font-weight: bold;">ペア作成: [1, 4] - 位置1をポップして位置4と組み合わせ</div>
                </div>

                <div class="trace-step">
                    <div><strong>5</strong></div>
                    <div class="current-char">(</div>
                    <div>[5]</div>
                    <div>開きカッコなので位置5をスタックにプッシュ</div>
                </div>

                <div class="trace-step">
                    <div><strong>6</strong></div>
                    <div class="current-char">)</div>
                    <div>[]</div>
                    <div style="color: #27ae60; font-weight: bold;">ペア作成: [5, 6] - 位置5をポップして位置6と組み合わせ</div>
                </div>
            </div>

            <h2>4. スタック操作の可視化</h2>
            <div class="algorithm-step">
                <div class="step-title">各ステップでのスタック状態</div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0;">

                    <div style="text-align: center;">
                        <h4>位置1: '(' 処理後</h4>
                        <div class="stack-visual" style="height: 80px;">
                            <div class="stack-container">
                                <div class="stack-item">1</div>
                                <div class="stack-label">スタック</div>
                            </div>
                        </div>
                    </div>

                    <div style="text-align: center;">
                        <h4>位置2: '(' 処理後</h4>
                        <div class="stack-visual" style="height: 100px;">
                            <div class="stack-container">
                                <div class="stack-item">2</div>
                                <div class="stack-item">1</div>
                                <div class="stack-label">スタック</div>
                            </div>
                        </div>
                    </div>

                    <div style="text-align: center;">
                        <h4>位置3: ')' 処理後</h4>
                        <div class="stack-visual" style="height: 80px;">
                            <div class="stack-container">
                                <div class="stack-item">1</div>
                                <div class="stack-label">スタック</div>
                            </div>
                        </div>
                        <div class="pair-box">ペア: [2, 3]</div>
                    </div>

                    <div style="text-align: center;">
                        <h4>位置4: ')' 処理後</h4>
                        <div class="stack-visual" style="height: 80px;">
                            <div class="stack-container">
                                <div class="stack-label">スタック(空)</div>
                            </div>
                        </div>
                        <div class="pair-box">ペア: [1, 4]</div>
                    </div>

                    <div style="text-align: center;">
                        <h4>位置5: '(' 処理後</h4>
                        <div class="stack-visual" style="height: 80px;">
                            <div class="stack-container">
                                <div class="stack-item">5</div>
                                <div class="stack-label">スタック</div>
                            </div>
                        </div>
                    </div>

                    <div style="text-align: center;">
                        <h4>位置6: ')' 処理後</h4>
                        <div class="stack-visual" style="height: 80px;">
                            <div class="stack-container">
                                <div class="stack-label">スタック(空)</div>
                            </div>
                        </div>
                        <div class="pair-box">ペア: [5, 6]</div>
                    </div>
                </div>
            </div>

            <h2>5. 発見されたペアの一覧</h2>
            <div class="algorithm-step">
                <div class="step-title">処理順序でのペア</div>
                <div class="pairs-visual">
                    <div class="pair-box">[2, 3]</div>
                    <div class="pair-box">[1, 4]</div>
                    <div class="pair-box">[5, 6]</div>
                </div>
                <p>スタックの性質により、内側のカッコから順にペアが作成されます。</p>
            </div>

            <h2>6. ソート処理の詳細解析</h2>
            <div class="algorithm-step">
                <div class="step-title">ソート条件: max(li, ri) < max(li+1, ri+1)</div>

                        <div style="background: #fff; padding: 20px; border: 2px solid #3498db; border-radius: 10px; margin: 15px 0;">
                            <h4>各ペアの最大値計算:</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <div style="text-align: center; padding: 15px; background: #ecf0f1; border-radius: 8px;">
                                    <div><strong>[2, 3]</strong></div>
                                    <div>max(2, 3) = <span style="color: #e74c3c; font-weight: bold;">3</span></div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #ecf0f1; border-radius: 8px;">
                                    <div><strong>[1, 4]</strong></div>
                                    <div>max(1, 4) = <span style="color: #e74c3c; font-weight: bold;">4</span></div>
                                </div>
                                <div style="text-align: center; padding: 15px; background: #ecf0f1; border-radius: 8px;">
                                    <div><strong>[5, 6]</strong></div>
                                    <div>max(5, 6) = <span style="color: #e74c3c; font-weight: bold;">6</span></div>
                                </div>
                            </div>
                        </div>

                        <div class="arrow">↓ ソート実行 ↓</div>

                        <div style="background: #d5f4e6; padding: 20px; border: 2px solid #27ae60; border-radius: 10px;">
                            <h4>ソート後の順序:</h4>
                            <div class="pairs-visual">
                                <div class="pair-box" style="background: #27ae60;">1位: [2, 3] (max=3)</div>
                                <div class="pair-box" style="background: #2980b9;">2位: [1, 4] (max=4)</div>
                                <div class="pair-box" style="background: #8e44ad;">3位: [5, 6] (max=6)</div>
                            </div>
                        </div>
                </div>

                <h2>7. 最終出力</h2>
                <div class="algorithm-step">
                    <div class="step-title">最終結果</div>
                    <div style="background: #2c3e50; color: white; padding: 20px; border-radius: 10px; font-family: 'Courier New', monospace; font-size: 18px;">
                        2 3<br>
                        1 4<br>
                        5 6
                    </div>
                </div>

                <h2>8. 計算量とメモリ使用量の分析</h2>
                <div class="complexity-box">
                    <div class="complexity-item">
                        <strong>時間計算量:</strong> O(n log n)
                        <br>
                        <small>• スタック操作: O(n) • ソート処理: O(n log n)</small>
                    </div>
                    <div class="complexity-item">
                        <strong>空間計算量:</strong> O(n)
                        <br>
                        <small>• スタック: 最大O(n/2) • ペア配列: O(n/2)</small>
                    </div>
                </div>

                <div class="memory-usage">
                    <h3>メモリ使用量の詳細</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px;">
                        <div>
                            <strong>スタック:</strong><br>
                            最悪の場合 n/2 要素<br>
                            (すべて開きカッコの場合)
                        </div>
                        <div>
                            <strong>ペア配列:</strong><br>
                            正確に n/2 要素<br>
                            (カッコのペア数)
                        </div>
                        <div>
                            <strong>入力文字列:</strong><br>
                            n 文字<br>
                            (最大200,000文字)
                        </div>
                    </div>
                </div>

                <h2>9. アルゴリズムの正当性</h2>
                <div class="highlight">
                    <h4>なぜこのアルゴリズムが正しく動作するのか：</h4>
                    <ol>
                        <li><strong>スタックの性質:</strong> LIFO (Last In, First Out) により、最も内側のカッコから順に処理される</li>
                        <li><strong>対応関係の保証:</strong> 正しいカッコ列では、各閉じカッコに対応する開きカッコが必ずスタックの最上位にある</li>
                        <li><strong>ソート条件:</strong> 出力順序の制約を満たすため、各ペアの最大位置で昇順ソート</li>
                        <li><strong>1-indexed変換:</strong> 問題の要求に合わせて、配列のインデックス(0-indexed)を位置(1-indexed)に変換</li>
                    </ol>
                </div>
            </div>
    </body>

</html>