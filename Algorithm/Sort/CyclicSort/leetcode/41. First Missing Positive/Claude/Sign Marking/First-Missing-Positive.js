// この問題は「First Missing Positive」という典型的なアルゴリズム問題です。O(n)時間でO(1)空間という制約を満たすために、配列自体をハッシュテーブルとして使用する手法を使います。この解法のポイント：

// 1. **配列を再利用**: 追加のデータ構造を使わず、入力配列自体をハッシュテーブルとして使用
// 2. **値の正規化**: 範囲外の値（0以下、n+1以上）を統一的に処理
// 3. **負値によるマーキング**: 値の存在を負の符号で表現し、元の値は絶対値で保持

// **アルゴリズムの流れ**：
// - Step 1: 1〜nの範囲外の値をn+1に置き換え
// - Step 2: 値xが存在する場合、インデックスx-1の値を負にマーク
// - Step 3: 最初の正の値を持つインデックス+1が答え

// **時間・空間計算量**：
// - 時間複雑度: O(n) - 3回のループ、各要素を定数回処理
// - 空間複雑度: O(1) - 入力配列以外に追加領域不要

// この手法は元の配列を変更しますが、LeetCodeでは一般的に許可されており、制約を満たす最も効率的な解法です。

/**
 * 配列から欠けている最小の正の整数を見つける
 * @param {number[]} nums - 整数配列
 * @return {number} - 欠けている最小の正の整数
 *
 * 時間複雑度: O(n)
 * 空間複雑度: O(1)
 */
function firstMissingPositive(nums) {
    const n = nums.length;

    // Step 1: 配列内の値を正規化
    // 1からnの範囲外の値（0以下、n+1以上）をn+1に置き換える
    for (let i = 0; i < n; i++) {
        if (nums[i] <= 0 || nums[i] > n) {
            nums[i] = n + 1;
        }
    }

    // Step 2: 各数値の存在を配列のインデックスを使って記録
    // 値xが存在する場合、インデックスx-1の値を負にする
    for (let i = 0; i < n; i++) {
        const val = Math.abs(nums[i]);
        if (val <= n) {
            // インデックスval-1の値を負にマーク（既に負の場合はそのまま）
            nums[val - 1] = -Math.abs(nums[val - 1]);
        }
    }

    // Step 3: 最初の正の値のインデックス+1が答え
    for (let i = 0; i < n; i++) {
        if (nums[i] > 0) {
            return i + 1;
        }
    }

    // 1からnまでの全ての数が存在する場合、答えはn+1
    return n + 1;
}
