以下では、TypeScript で実装した `countAndSay(n)` 関数の各処理について、**図解・具体例**を使って詳細に解析・説明します。

---

## ✅ 基本概要（復習）

**Count-and-Say シーケンス**は次のように定義されます：

```
countAndSay(1) = "1"
countAndSay(n) = countAndSay(n - 1) に対するランレングス圧縮（RLE）
```

---

## ✅ TypeScript 実装の再掲

```typescript
function countAndSay(n: number): string {
    if (n === 1) return '1';

    let result: string = '1';

    for (let i = 2; i <= n; i++) {
        let temp: string[] = [];
        let count: number = 1;

        for (let j = 1; j <= result.length; j++) {
            if (result[j] === result[j - 1]) {
                count++;
            } else {
                temp.push(count.toString());
                temp.push(result[j - 1]);
                count = 1;
            }
        }

        result = temp.join('');
    }

    return result;
}
```

---

## ✅ 処理フロー図解：n = 5 の場合

### ステップ 1: 初期化

```
n = 1 → "1"
```

```
result = "1"
```

---

### ステップ 2: 2回目（i = 2）

**入力**: `"1"`
**処理**:

```
1文字目: '1'
→ 次の文字が undefined → 出力に "1" 個の '1' = "11"
```

```
temp = ["1", "1"]
result = "11"
```

---

### ステップ 3: 3回目（i = 3）

**入力**: `"11"`
**処理フロー図**:

```
Index:     0   1
文字列:    1   1
               ↑ (次の文字が違う or 終端 → 出力)
→ "2個の1" → "21"
```

```
temp = ["2", "1"]
result = "21"
```

---

### ステップ 4: 4回目（i = 4）

**入力**: `"21"`
**処理フロー図**:

```
Index:     0   1
文字列:    2   1
         ↑ ↑（異なる文字 → 出力）
→ "1個の2" → "12"
→ "1個の1" → "11"
→ 合計: "1211"
```

```
temp = ["1", "2", "1", "1"]
result = "1211"
```

---

### ステップ 5: 5回目（i = 5）

**入力**: `"1211"`
**処理フロー図**:

```
Index:     0   1   2   3
文字列:    1   2   1   1
         ↑   ↑   ↑   ↑
         │   │   └─同じ→2個の1
         │   └─出力: 1個の2
         └─出力: 1個の1
→ "111221"
```

```
temp = ["1", "1", "1", "2", "2", "1"]
result = "111221"
```

---

## ✅ 各ループ内の動作を図で再現（文字列 `"1211"` の解析）

| `j` | `result[j]` | `result[j - 1]` | `count` | 操作内容          | tempの中身                       |
| --- | ----------- | --------------- | ------- | ----------------- | -------------------------------- |
| 1   | `'2'`       | `'1'`           | 1       | 出力: `"1" + "1"` | `["1", "1"]`                     |
| 2   | `'1'`       | `'2'`           | 1       | 出力: `"1" + "2"` | `["1", "1", "1", "2"]`           |
| 3   | `'1'`       | `'1'`           | 2       | 出力: `"2" + "1"` | `["1", "1", "1", "2", "2", "1"]` |

---

## ✅ 全体のイメージ（シーケンス図）

```text
n=1   : "1"
n=2   : "11"       (one 1)
n=3   : "21"       (two 1s)
n=4   : "1211"     (one 2, one 1)
n=5   : "111221"   (one 1, one 2, two 1s)
n=6   : "312211"   (three 1s, two 2s, one 1)
```

---

## ✅ 時間・空間解析（図式）

### 時間計算量 O(n \* m)

```
各ステップで前の文字列を1文字ずつ読む → O(m)
これを n 回繰り返す → O(n * m)
```

例：

```text
n = 1 : length 1
n = 2 : length 2
n = 3 : length 2
n = 4 : length 4
n = 5 : length 6
n = 6 : length 6
...
```

### 空間計算量 O(m)

```text
temp: 新しい文字列の配列 → 毎回文字列長分だけ保持
```

---

## ✅ まとめ

| 観点       | 内容                                     |
| ---------- | ---------------------------------------- |
| 方法       | 文字列を1文字ずつ走査し、RLE圧縮         |
| データ構造 | `string`, `string[]`                     |
| 時間計算量 | O(n \* m)（n: 回数, m: 出力文字列長）    |
| 空間計算量 | O(m)（出力文字列を一時保存）             |
| 図解       | 各ループの流れや処理が明確に見える構造化 |

---

図や構造をさらに視覚化して画像化することも可能です。必要であればリクエストしてください。
