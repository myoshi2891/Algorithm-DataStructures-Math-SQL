<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Jump Game Algorithm Analysis</title>
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
            rel="stylesheet"
        />
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
            rel="stylesheet"
        />
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600&family=Inter:wght@300;400;500;600&display=swap');

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Inter', sans-serif;
                line-height: 1.6;
                color: #333;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                padding: 20px;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                background: rgba(255, 255, 255, 0.95);
                border-radius: 20px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
                backdrop-filter: blur(10px);
                overflow: hidden;
            }

            .header {
                background: linear-gradient(135deg, #2c3e50, #3498db);
                color: white;
                padding: 40px;
                text-align: center;
            }

            .header h1 {
                font-size: 2.5rem;
                font-weight: 600;
                margin-bottom: 10px;
            }

            .header p {
                font-size: 1.2rem;
                opacity: 0.9;
            }

            .content {
                padding: 40px;
            }

            .section {
                margin-bottom: 40px;
                background: white;
                border-radius: 15px;
                padding: 30px;
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.05);
                border: 1px solid #e0e6ed;
            }

            .section h2 {
                color: #2c3e50;
                font-size: 1.8rem;
                margin-bottom: 20px;
                border-bottom: 3px solid #3498db;
                padding-bottom: 10px;
            }

            .code-container {
                position: relative;
                border-radius: 12px;
                overflow: hidden;
                box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
                transition:
                    transform 0.3s ease,
                    box-shadow 0.3s ease;
            }

            .code-container:hover {
                transform: translateY(-2px);
                box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
            }

            pre[class*='language-'] {
                margin: 0;
                padding: 20px !important;
                font-family: 'Fira Code', 'Monaco', 'Consolas', monospace !important;
                font-size: 14px !important;
                line-height: 1.6 !important;
                background: #2d3748 !important;
            }

            .line-numbers .line-numbers-rows {
                border-right: 1px solid #4a5568 !important;
                background: #1a202c !important;
            }

            .visualization {
                background: #f8fafc;
                border-radius: 12px;
                padding: 25px;
                margin: 20px 0;
                border-left: 5px solid #3498db;
            }

            .step {
                margin: 20px 0;
                padding: 20px;
                background: white;
                border-radius: 10px;
                border-left: 4px solid #e74c3c;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
                transition: all 0.3s ease;
            }

            .step:hover {
                transform: translateX(5px);
                box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            }

            .step h3 {
                color: #e74c3c;
                font-size: 1.3rem;
                margin-bottom: 10px;
            }

            .array-visual {
                display: flex;
                gap: 5px;
                margin: 15px 0;
                justify-content: center;
                flex-wrap: wrap;
            }

            .array-cell {
                width: 50px;
                height: 50px;
                display: flex;
                align-items: center;
                justify-content: center;
                border: 2px solid #3498db;
                border-radius: 8px;
                font-weight: bold;
                background: white;
                transition: all 0.3s ease;
                position: relative;
            }

            .array-cell:hover {
                transform: scale(1.1);
                z-index: 10;
            }

            .current {
                background: #e74c3c !important;
                color: white;
            }

            .reachable {
                background: #27ae60 !important;
                color: white;
            }

            .unreachable {
                background: #95a5a6 !important;
                color: white;
            }

            .index-label {
                position: absolute;
                top: -25px;
                font-size: 12px;
                color: #666;
            }

            .complexity {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                border-radius: 12px;
                padding: 25px;
                margin: 20px 0;
            }

            .complexity h3 {
                margin-bottom: 15px;
                font-size: 1.4rem;
            }

            .complexity-item {
                margin: 10px 0;
                padding: 10px 15px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 8px;
                backdrop-filter: blur(5px);
            }

            .example {
                background: #fff8e7;
                border: 1px solid #f39c12;
                border-radius: 12px;
                padding: 25px;
                margin: 20px 0;
            }

            .example h4 {
                color: #d68910;
                margin-bottom: 15px;
                font-size: 1.2rem;
            }

            .tooltip {
                position: relative;
                cursor: help;
                color: #3498db;
                text-decoration: underline;
            }

            .tooltip:hover::after {
                content: attr(data-tooltip);
                position: absolute;
                bottom: 125%;
                left: 50%;
                transform: translateX(-50%);
                background: #2c3e50;
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                white-space: nowrap;
                z-index: 1000;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>🚀 Jump Game Algorithm Analysis</h1>
                <p>配列の最後のインデックスに到達できるかを判定するアルゴリズムの詳細解析</p>
            </div>

            <div class="content">
                <!-- TypeScript Code Section -->
                <div class="section">
                    <h2>💻 TypeScript実装</h2>
                    <div class="code-container">
                        <pre class="line-numbers"><code class="language-typescript">/**
 * 配列の最後のインデックスに到達できるかどうかを判定する関数
 * 
 * @param nums - 各位置での最大ジャンプ長を表す整数配列
 * @returns 最後のインデックスに到達できる場合はtrue、そうでなければfalse
 * 
 * 時間計算量: O(n) - 配列を一度だけ走査
 * 空間計算量: O(1) - 定数の追加メモリのみ使用
 */
function canJump(nums: number[]): boolean {
    // 現在到達可能な最大インデックスを追跡
    let maxReach: number = 0;
    
    // 配列の各要素を順番に処理
    for (let i: number = 0; i < nums.length; i++) {
        // 現在の位置が到達可能範囲を超えている場合、最後まで到達不可能
        if (i > maxReach) {
            return false;
        }
        
        // 現在の位置から到達可能な最大インデックスを更新
        maxReach = Math.max(maxReach, i + nums[i]);
        
        // 既に最後のインデックス以上に到達可能な場合、早期終了
        if (maxReach >= nums.length - 1) {
            return true;
        }
    }
    
    // ループが完了した場合、最後のインデックスに到達可能
    return true;
}</code></pre>
                    </div>
                </div>

                <!-- Algorithm Analysis -->
                <div class="section">
                    <h2>🔍 アルゴリズム解析</h2>

                    <div class="step">
                        <h3>Step 1: 初期化</h3>
                        <p>
                            <span class="tooltip" data-tooltip="到達可能な最大インデックスを記録"
                                >maxReach</span
                            >を0で初期化。これは現在到達可能な最大インデックスを追跡します。
                        </p>
                        <div class="visualization"><strong>初期状態:</strong> maxReach = 0</div>
                    </div>

                    <div class="step">
                        <h3>Step 2: 配列の走査</h3>
                        <p>配列の各要素を順番に処理し、各位置で以下をチェック：</p>
                        <ul style="margin-left: 20px; margin-top: 10px">
                            <li>現在位置が到達可能範囲内か</li>
                            <li>現在位置から到達可能な最大距離の更新</li>
                            <li>最終インデックスに到達可能かの早期判定</li>
                        </ul>
                    </div>

                    <div class="step">
                        <h3>Step 3: 到達可能性判定</h3>
                        <p>
                            各位置で
                            <code>i > maxReach</code>
                            の場合、その位置には到達できないため即座にfalseを返します。
                        </p>
                    </div>
                </div>

                <!-- Visual Example 1 -->
                <div class="section">
                    <h2>📊 Example 1: [2,3,1,1,4] の実行過程</h2>

                    <div class="example">
                        <h4>🎯 Input: nums = [2,3,1,1,4] → Output: true</h4>

                        <div class="step">
                            <h3>初期状態</h3>
                            <div class="array-visual">
                                <div class="array-cell current">
                                    <span class="index-label">0</span>
                                    2
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">1</span>
                                    3
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">2</span>
                                    1
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">3</span>
                                    1
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">4</span>
                                    4
                                </div>
                            </div>
                            <p><strong>i = 0:</strong> maxReach = 0, nums[0] = 2</p>
                            <p><strong>計算:</strong> maxReach = max(0, 0 + 2) = 2</p>
                        </div>

                        <div class="step">
                            <h3>i = 1 の処理</h3>
                            <div class="array-visual">
                                <div class="array-cell reachable">
                                    <span class="index-label">0</span>
                                    2
                                </div>
                                <div class="array-cell current">
                                    <span class="index-label">1</span>
                                    3
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">2</span>
                                    1
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">3</span>
                                    1
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">4</span>
                                    4
                                </div>
                            </div>
                            <p><strong>i = 1:</strong> maxReach = 2, nums[1] = 3</p>
                            <p><strong>計算:</strong> maxReach = max(2, 1 + 3) = 4</p>
                            <p>
                                <strong>判定:</strong> maxReach (4) ≥ nums.length - 1 (4) →
                                <strong>true を返す</strong>
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Visual Example 2 -->
                <div class="section">
                    <h2>📊 Example 2: [3,2,1,0,4] の実行過程</h2>

                    <div class="example">
                        <h4>❌ Input: nums = [3,2,1,0,4] → Output: false</h4>

                        <div class="step">
                            <h3>i = 0 の処理</h3>
                            <div class="array-visual">
                                <div class="array-cell current">
                                    <span class="index-label">0</span>
                                    3
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">1</span>
                                    2
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">2</span>
                                    1
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">3</span>
                                    0
                                </div>
                                <div class="array-cell">
                                    <span class="index-label">4</span>
                                    4
                                </div>
                            </div>
                            <p><strong>i = 0:</strong> maxReach = max(0, 0 + 3) = 3</p>
                        </div>

                        <div class="step">
                            <h3>i = 1, 2, 3 の処理</h3>
                            <div class="array-visual">
                                <div class="array-cell reachable">
                                    <span class="index-label">0</span>
                                    3
                                </div>
                                <div class="array-cell reachable">
                                    <span class="index-label">1</span>
                                    2
                                </div>
                                <div class="array-cell reachable">
                                    <span class="index-label">2</span>
                                    1
                                </div>
                                <div class="array-cell current">
                                    <span class="index-label">3</span>
                                    0
                                </div>
                                <div class="array-cell unreachable">
                                    <span class="index-label">4</span>
                                    4
                                </div>
                            </div>
                            <p><strong>i = 3:</strong> nums[3] = 0, maxReach = max(3, 3 + 0) = 3</p>
                            <p>
                                <strong>重要:</strong>
                                インデックス3から先に進めない（ジャンプ長が0）
                            </p>
                            <p>
                                <strong>i = 4 で:</strong> i (4) > maxReach (3) →
                                <strong>false を返す</strong>
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Complexity Analysis -->
                <div class="section">
                    <h2>⚡ 計算量解析</h2>

                    <div class="complexity">
                        <h3>🕒 時間計算量: O(n)</h3>
                        <div class="complexity-item">
                            <strong>理由:</strong> 配列の各要素を最大1回だけ処理するため
                        </div>
                        <div class="complexity-item">
                            <strong>最良の場合:</strong> O(1) -
                            最初の要素で最終インデックスに到達可能と判明
                        </div>
                        <div class="complexity-item">
                            <strong>最悪の場合:</strong> O(n) - 全ての要素を処理する必要がある
                        </div>
                    </div>

                    <div class="complexity">
                        <h3>💾 空間計算量: O(1)</h3>
                        <div class="complexity-item">
                            <strong>理由:</strong>
                            maxReach変数のみを使用し、入力サイズに関係なく一定
                        </div>
                        <div class="complexity-item">
                            <strong>追加メモリ:</strong> 整数変数のみ（数バイト）
                        </div>
                    </div>
                </div>

                <!-- Key Insights -->
                <div class="section">
                    <h2>🔑 重要なポイント</h2>

                    <div class="step">
                        <h3>1. 貪欲法（Greedy Algorithm）</h3>
                        <p>
                            各段階で最適な選択（最大到達距離の更新）を行い、全体的に最適解を得る手法です。
                        </p>
                    </div>

                    <div class="step">
                        <h3>2. 早期終了による最適化</h3>
                        <p>
                            最終インデックスに到達可能と分かった時点で即座にtrueを返すことで、無駄な計算を回避します。
                        </p>
                    </div>

                    <div class="step">
                        <h3>3. 単一パス処理</h3>
                        <p>配列を一度だけ走査することで効率的な解法を実現しています。</p>
                    </div>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

        <script>
            // インタラクティブな要素の追加
            document.addEventListener('DOMContentLoaded', function () {
                // コードブロックにホバー効果を追加
                const codeContainers = document.querySelectorAll('.code-container');
                codeContainers.forEach((container) => {
                    container.addEventListener('mouseenter', function () {
                        this.style.transform = 'translateY(-2px)';
                    });
                    container.addEventListener('mouseleave', function () {
                        this.style.transform = 'translateY(0)';
                    });
                });

                // 配列セルのクリックイベント
                const arrayCells = document.querySelectorAll('.array-cell');
                arrayCells.forEach((cell) => {
                    cell.addEventListener('click', function () {
                        const index = this.querySelector('.index-label').textContent;
                        const value = this.textContent.replace(index, '').trim();
                        alert(
                            `インデックス ${index}: 値 = ${value}\n最大ジャンプ距離: ${value} 歩`,
                        );
                    });
                });

                // ステップのアニメーション
                const steps = document.querySelectorAll('.step');
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach((entry) => {
                        if (entry.isIntersecting) {
                            entry.target.style.opacity = '1';
                            entry.target.style.transform = 'translateY(0)';
                        }
                    });
                });

                steps.forEach((step) => {
                    step.style.opacity = '0';
                    step.style.transform = 'translateY(20px)';
                    step.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                    observer.observe(step);
                });
            });
        </script>
    </body>
</html>
