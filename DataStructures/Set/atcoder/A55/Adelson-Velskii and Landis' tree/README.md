
---

# 🌳 AVL木とは？

AVL木は「**高さバランス**」が保証される二分探索木（BST）です。

### ✅ 特徴

* 各ノードに「高さ情報（height）」を保持。
* 左右の部分木の高さ差（平衡係数 balance factor） ≤ 1 を保つ。
* 挿入・削除のたびにバランス調整（回転）を行う。

---

# 🔄 バランス調整の回転パターン（図解付き）

---

## 🔁 回転の種類とイメージ

### 1. **右回転（Right Rotation）**

発生条件：**左部分木が高すぎる（bf > 1）**
具体：**左-左パターン（LL）**

```
    y               x
   /               \
  x     →         y
 /                 \
a                   b
```

コードでの呼び出し：

```ts
rotateRight(y)
```

---

### 2. **左回転（Left Rotation）**

発生条件：**右部分木が高すぎる（bf < -1）**
具体：**右-右パターン（RR）**

```
  x                  y
   \                /
    y     →        x
     \            /
      z          b
```

コードでの呼び出し：

```ts
rotateLeft(x)
```

---

### 3. **左-右回転（Left-Right Rotation）**

発生条件：**左部分木の右部分が高い（bf > 1, 子のbf < 0）**
具体：**左-右パターン（LR）**

```
    y              y              z
   /              /              / \
  x     →        z     →        x   y
   \            /                 \
    z          x                   b
```

コード：

```ts
node.left = rotateLeft(node.left)
rotateRight(node)
```

---

### 4. **右-左回転（Right-Left Rotation）**

発生条件：**右部分木の左部分が高い（bf < -1, 子のbf > 0）**
具体：**右-左パターン（RL）**

```
  x               x                 z
   \               \               / \
    y     →         z     →       x   y
   /                 \               \
  z                   y               c
```

コード：

```ts
node.right = rotateRight(node.right)
rotateLeft(node)
```

---

# 🔍 各処理の図解

---

## ✅ `insert(x)` 挿入

### 例：空の木に 10 → 20 → 30 を挿入

```
Step 1: insert(10)

  10

Step 2: insert(20)

   10
     \
     20

Step 3: insert(30)

   10
     \
     20
       \
       30
```

❗ 不均衡（RRパターン）発生 → 左回転：

```
   20
  /  \
10   30
```

➡️ バランス調整完了

---

## ✅ `delete(x)` 削除

### 例：以下の木から 10 を削除

```
   20
  /  \
10   30
```

削除後：

```
  20
    \
    30
```

バランス OK → 調整不要

---

### 別例（回転発生）：

木：

```
      30
     /
   20
  /
10
```

削除：10 → バランス崩れる（LL） → 右回転

調整後：

```
   20
     \
     30
```

---

## ✅ `lowerBound(x)` 探索

### 目的：

「**x 以上の中で最小の値**」を探す

### ロジック：

* 木を辿りながら、

  * `node.value >= x` → 候補に入れ、左部分木へ（より小さい値があるかも）
  * `node.value < x` → 右部分木へ

---

### 例：

木：

```
     20
    /  \
  10    30
```

探索：`lowerBound(15)`

```
- node = 20 → 20 >= 15 → 候補 = 20、左へ
- node = 10 → 10 < 15 → 右へ（null）
- 終了 → 結果 = 20
```

---

# ✅ まとめ：AVL木の強み

| 操作         | 計算量      | 安定性 | 説明             |
| ---------- | -------- | --- | -------------- |
| 挿入         | O(log N) | 高   | 自動で回転調整        |
| 削除         | O(log N) | 高   | 回転により常に平衡維持    |
| lowerBound | O(log N) | 高   | 左右どちらにも探索できる構造 |

---

## 📘 補足

* AVL木はキーが頻繁に追加・削除される場合に非常に有効です。
* 二分探索配列に比べて挿入・削除が効率的（O(N) → O(log N)）。
* バランスロジックは回転だけで実現可能なため、意外とシンプルです。

---

