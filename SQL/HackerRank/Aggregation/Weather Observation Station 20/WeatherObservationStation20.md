# テーブルの見取り図と処理フロー

---

## ゴール

- `STATION` テーブルの北緯 `LAT_N` の **中央値** を求め、**小数点以下 4 桁**に丸めて返す。

---

## 使っているアイデア（要点だけ）

1. `LAT_N` を昇順に並べる
2. 並べた順に連番（`ROW_NUMBER()`）を振る
3. 全体の件数（`COUNT(*) OVER()`）を同時に持つ
4. **中央の行番号**だけを選び出して `AVG()`

   - 奇数件なら中央 1 行の平均＝その値
   - 偶数件なら中央 2 行の平均＝ 2 つの真ん中の平均

---

## クエリ（再掲）

```sql
WITH Ordered AS (
    SELECT
        LAT_N,
        ROW_NUMBER() OVER (ORDER BY LAT_N) AS rn,
        COUNT(*) OVER() AS total_count
    FROM STATION
)
SELECT ROUND(AVG(1.0 * LAT_N), 4) AS median
FROM Ordered
WHERE rn IN ((total_count + 1) / 2, (total_count + 2) / 2);
```

---

## 図解 ①：並べ替えと連番付与

`ROW_NUMBER() OVER (ORDER BY LAT_N)` が「小さい順の順位」を付けます。
`COUNT(*) OVER()` は「全体件数」を各行に同じ値で付けます。

```text
(例) STATION から LAT_N を取り出して昇順に並べたイメージ

+---------+------+
| LAT_N   |  rn  |  ← ROW_NUMBER() OVER (ORDER BY LAT_N)
+---------+------+
| 12.3001 |  1   |
| 13.5022 |  2   |
| 15.8770 |  3   |
| 16.4105 |  4   |
| 18.9999 |  5   |
+---------+------+
    ↑全行に total_count = 5（COUNT(*) OVER()）
```

---

## 図解 ②：奇数件のとき

総件数 `n=5` のとき、中央は **3 行目**。
クエリ中の式はこうなります：

```text
(total_count + 1) / 2 = (5 + 1) / 2 = 3
(total_count + 2) / 2 = (5 + 2) / 2 = 3  ← どちらも3
```

つまり `rn IN (3, 3)` → `rn=3` の行だけヒット。
`AVG(LAT_N)` は 1 行の平均＝その値＝**中央値**。

```text
対象行: rn=3 (LAT_N=15.8770)
AVG(15.8770) = 15.8770
ROUND(..., 4) → 15.8770
```

---

## 図解 ③：偶数件のとき

総件数 `n=6` を想像します。中央の 2 つは **3 行目**と**4 行目**。

```text
(total_count + 1) / 2 = (6 + 1) / 2 = 3
(total_count + 2) / 2 = (6 + 2) / 2 = 4
```

つまり `rn IN (3, 4)` → 2 行ヒット。
`AVG(LAT_N)` はその 2 値の平均＝**中央値**。

```text
対象行: rn=3 (LAT_N=a), rn=4 (LAT_N=b)
AVG(a, b) = (a + b) / 2
ROUND(..., 4) で小数4桁に丸め
```

---

## フロー図（処理の流れ）

```text
┌────────────────────┐
│  STATION           │
│  (列: LAT_N, …) 　  │
└─────────┬──────────┘
          │ SELECT LAT_N
          ▼
┌───────────────────────────────────┐
│ ウィンドウ関数で付加                 │
│  ROW_NUMBER()→ rn                 │
│  COUNT(*) OVER()→ total_count     │
└─────────┬─────────────────────────┘
          │ ORDER BY LAT_N (昇順の序数)
          ▼
┌────────────────────────────────────────────┐
│ 　中央インデックスの計算                       │
│   left  = (total_count + 1) / 2            │
│   right = (total_count + 2) / 2            │
│  → WHERE rn IN (left, right) で抽出         │
└─────────┬──────────────────────────────────┘
          │ 1行 or 2行
          ▼
┌─────────────────────────────┐
│  AVG(1.0 * LAT_N)           │ ← 奇数:1行の平均=その値
│                             │ ← 偶数:2行の平均=中央値
└─────────┬───────────────────┘
          │
          ▼
   ROUND(..., 4) で4桁丸め → median
```

---

## なぜ `(n+1)/2` と `(n+2)/2` なの？

- **奇数件** `n=2k+1`

  - `(n+1)/2 = (2k+2)/2 = k+1`
  - `(n+2)/2 = (2k+3)/2 = k+1`（整数除算なら同じ）
    → **中央 1 点**を二度指す＝その 1 行だけ抽出

- **偶数件** `n=2k`

  - `(n+1)/2 = (2k+1)/2 = k`
  - `(n+2)/2 = (2k+2)/2 = k+1`
    → **中央 2 点**（k 行目と (k+1) 行目）を抽出

**1 本の式で奇数／偶数の両方をきれいにカバー**できるのが肝です。

---

## 丸め（ROUND）の理由

- `AVG(1.0 * LAT_N)` で数値を実数計算に寄せつつ
  `ROUND(..., 4)` で **小数点以下 4 桁**に整形。
- 環境によっては `AVG()` の戻り型や桁数が微妙に異なるため、
  **最後に明示的に丸める**のが安全です。

---

## 補足：NULL の扱い

- `LAT_N` に `NULL` がある場合、`ROW_NUMBER()` は行自体は振られますが、
  **中央値の計算からは外れるのが望ましい**ことが多いです。
- 実運用なら `WHERE LAT_N IS NOT NULL` を CTE 内に追加しておくと安心。

```sql
WITH Ordered AS (
    SELECT
        LAT_N,
        ROW_NUMBER() OVER (ORDER BY LAT_N) AS rn,
        COUNT(*) OVER() AS total_count
    FROM STATION
    WHERE LAT_N IS NOT NULL
)
...
```

---

## 補足：性能メモ

- `ORDER BY LAT_N` が必須なので、**`LAT_N` にインデックス**があると速くなります。
- ただしウィンドウ関数は全体走査を伴うため、巨大テーブルではコストを意識。

---

## 代替案（対応 DB があれば簡潔）

- **PostgreSQL / Oracle** など：

  ```sql
  SELECT ROUND(
           PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY LAT_N)
         , 4) AS median
  FROM STATION;
  ```

  *連続パーセンタイル*関数で 0.5（中央値）を一発で算出できます。

- **MySQL 8.0+** ならご提示の解法が最も移植性が高く実務的です。
