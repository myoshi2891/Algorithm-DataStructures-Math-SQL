<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Remove Duplicates from Sorted List II - 技術解説</title>

        <!-- External CDNs -->
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css"
            rel="stylesheet"
        />
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
            rel="stylesheet"
        />
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
            rel="stylesheet"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap"
            rel="stylesheet"
        />

        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Inter', sans-serif;
                line-height: 1.6;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                color: #2d3748;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
            }

            .header {
                text-align: center;
                color: white;
                margin-bottom: 40px;
                padding: 40px 0;
            }

            .header h1 {
                font-size: 3rem;
                font-weight: 700;
                margin-bottom: 15px;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            }

            .header .subtitle {
                font-size: 1.2rem;
                opacity: 0.9;
                font-weight: 300;
            }

            .main-content {
                background: white;
                border-radius: 20px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.1);
                overflow: hidden;
            }

            .section {
                padding: 40px;
                border-bottom: 1px solid #f0f0f0;
                transition: all 0.3s ease;
            }

            .section:last-child {
                border-bottom: none;
            }

            .section-title {
                color: #2d3748;
                font-size: 2rem;
                font-weight: 600;
                margin-bottom: 20px;
                display: flex;
                align-items: center;
                gap: 15px;
            }

            .section-icon {
                width: 50px;
                height: 50px;
                border-radius: 15px;
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-size: 1.2rem;
            }

            .overview .section-icon {
                background: linear-gradient(135deg, #667eea, #764ba2);
            }
            .steps .section-icon {
                background: linear-gradient(135deg, #f093fb, #f5576c);
            }
            .code .section-icon {
                background: linear-gradient(135deg, #4facfe, #00f2fe);
            }
            .complexity .section-icon {
                background: linear-gradient(135deg, #fa709a, #fee140);
            }

            .algorithm-info {
                background: linear-gradient(135deg, #667eea15, #764ba215);
                padding: 25px;
                border-radius: 15px;
                margin-bottom: 30px;
                border-left: 4px solid #667eea;
            }

            .algorithm-name {
                font-size: 1.5rem;
                font-weight: 600;
                color: #667eea;
                margin-bottom: 10px;
            }

            .step-container {
                display: grid;
                gap: 20px;
                margin-bottom: 30px;
            }

            .step {
                background: #f8fafc;
                border-radius: 15px;
                padding: 25px;
                border-left: 4px solid #e2e8f0;
                transition: all 0.3s ease;
                cursor: pointer;
            }

            .step:hover {
                border-left-color: #667eea;
                box-shadow: 0 5px 20px rgba(102, 126, 234, 0.1);
                transform: translateY(-2px);
            }

            .step.active {
                border-left-color: #667eea;
                background: #f7fafc;
            }

            .step-header {
                display: flex;
                align-items: center;
                gap: 15px;
                margin-bottom: 15px;
            }

            .step-number {
                width: 35px;
                height: 35px;
                background: #667eea;
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: 600;
                font-size: 1.1rem;
                transition: all 0.3s ease;
            }

            .step:hover .step-number {
                background: #5a67d8;
                transform: scale(1.1);
            }

            .step-title {
                font-size: 1.3rem;
                font-weight: 600;
                color: #2d3748;
            }

            .code-container {
                position: relative;
                margin: 20px 0;
                transition: all 0.3s ease;
            }

            .code-container:hover {
                transform: translateY(-2px);
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            }

            .code-header {
                background: #2d3748;
                color: white;
                padding: 15px 20px;
                border-radius: 10px 10px 0 0;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            .code-title {
                font-family: 'JetBrains Mono', monospace;
                font-weight: 500;
            }

            .copy-btn {
                background: #667eea;
                border: none;
                color: white;
                padding: 8px 15px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 0.9rem;
                transition: all 0.2s ease;
            }

            .copy-btn:hover {
                background: #5a67d8;
                transform: translateY(-1px);
            }

            .copy-btn:active {
                transform: translateY(0);
            }

            pre {
                margin: 0 !important;
                border-radius: 0 0 10px 10px !important;
                font-family: 'JetBrains Mono', monospace !important;
            }

            .line-numbers-rows > span:before {
                color: #8b949e;
                font-family: var(--font-mono);
                padding: 0.5px 0.5em 0.5px 0 !important;
            }

            .visualization-container {
                background: #f8fafc;
                padding: 30px;
                border-radius: 15px;
                margin: 20px 0;
            }

            .linked-list {
                display: flex;
                align-items: center;
                justify-content: center;
                margin: 20px 0;
                padding: 20px;
                overflow-x: auto;
                flex-wrap: wrap;
                gap: 10px;
            }

            .node {
                background: white;
                border: 2px solid #e2e8f0;
                border-radius: 10px;
                padding: 15px 20px;
                margin: 0 5px;
                text-align: center;
                font-weight: 600;
                font-size: 1.1rem;
                min-width: 60px;
                transition: all 0.3s ease;
                position: relative;
            }

            .node:hover {
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            }

            .node.duplicate {
                background: #fed7d7;
                border-color: #fc8181;
                color: #c53030;
            }

            .node.unique {
                background: #c6f6d5;
                border-color: #68d391;
                color: #38a169;
            }

            .node.pointer {
                background: #bee3f8;
                border-color: #4299e1;
                color: #3182ce;
            }

            .arrow {
                font-size: 1.5rem;
                color: #4a5568;
                margin: 0 10px;
            }

            .complexity-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 25px;
                margin: 20px 0;
            }

            .complexity-card {
                background: white;
                border: 2px solid #e2e8f0;
                border-radius: 15px;
                padding: 25px;
                text-align: center;
                transition: all 0.3s ease;
            }

            .complexity-card:hover {
                border-color: #667eea;
                transform: translateY(-3px);
                box-shadow: 0 10px 25px rgba(102, 126, 234, 0.15);
            }

            .complexity-title {
                font-size: 1.3rem;
                font-weight: 600;
                margin-bottom: 15px;
                color: #2d3748;
            }

            .complexity-value {
                font-size: 2.5rem;
                font-weight: 700;
                color: #667eea;
                font-family: 'JetBrains Mono', monospace;
            }

            .tabs {
                display: flex;
                background: #f7fafc;
                border-radius: 10px;
                padding: 5px;
                margin-bottom: 20px;
            }

            .tab {
                flex: 1;
                padding: 12px 20px;
                text-align: center;
                background: transparent;
                border: none;
                border-radius: 8px;
                cursor: pointer;
                font-weight: 500;
                transition: all 0.2s ease;
                color: #4a5568;
            }

            .tab.active {
                background: white;
                color: #667eea;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            }

            .tab-content {
                display: none;
            }

            .tab-content.active {
                display: block;
            }

            .highlight {
                background: #fef5e7;
                padding: 2px 6px;
                border-radius: 4px;
                border: 1px solid #f6ad55;
                font-family: 'JetBrains Mono', monospace;
                font-size: 0.9em;
            }

            .demo-btn {
                background: #667eea;
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 8px;
                cursor: pointer;
                font-size: 1rem;
                font-weight: 500;
                transition: all 0.3s ease;
                margin: 20px 0;
            }

            .demo-btn:hover {
                background: #5a67d8;
                transform: translateY(-2px);
            }

            .demo-btn:active {
                transform: translateY(0);
            }

            @media (max-width: 768px) {
                .header h1 {
                    font-size: 2rem;
                }

                .section {
                    padding: 20px;
                }

                .linked-list {
                    justify-content: flex-start;
                }

                .node {
                    margin: 5px;
                }

                .complexity-grid {
                    grid-template-columns: 1fr;
                }
            }

            /* Animations */
            .fade-in {
                animation: fadeIn 0.6s ease-in;
            }

            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            .slide-in {
                animation: slideIn 0.5s ease-out;
            }

            @keyframes slideIn {
                from {
                    transform: translateX(-30px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            @keyframes pulse {
                0%,
                100% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.05);
                }
            }

            .pulse {
                animation: pulse 1s infinite;
            }

            /* Loading state */
            .loading {
                opacity: 0.6;
                pointer-events: none;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <header class="header">
                <h1>Remove Duplicates from Sorted List II</h1>
                <p class="subtitle">ソート済み連結リストから重複要素を完全削除するアルゴリズム</p>
            </header>

            <main class="main-content">
                <!-- Algorithm Overview -->
                <section class="section overview">
                    <h2 class="section-title">
                        <div class="section-icon"><i class="fas fa-lightbulb"></i></div>
                        アルゴリズム概要
                    </h2>

                    <div class="algorithm-info">
                        <div class="algorithm-name">Dummy Node + Two Pointers Technique</div>
                        <p>
                            ソート済み連結リストの特性を活かし、ダミーノードと2つのポインタを使用して重複要素を効率的に削除する手法です。
                        </p>
                    </div>

                    <div class="tabs">
                        <button class="tab active" onclick="switchTab('problem', this)">
                            問題定義
                        </button>
                        <button class="tab" onclick="switchTab('approach', this)">
                            解法アプローチ
                        </button>
                        <button class="tab" onclick="switchTab('key-points', this)">
                            重要なポイント
                        </button>
                    </div>

                    <div id="problem" class="tab-content active">
                        <h3>問題の要求事項</h3>
                        <ul>
                            <li>ソート済み連結リストが入力として与えられる</li>
                            <li>重複する値を持つノードはすべて削除する</li>
                            <li>一意な値を持つノードのみを残す</li>
                            <li>結果もソート済みの状態を維持する</li>
                        </ul>
                    </div>

                    <div id="approach" class="tab-content">
                        <h3>解法の核心</h3>
                        <ul>
                            <li>
                                <span class="highlight">ダミーノード</span>:
                                先頭削除の場合も統一的に処理
                            </li>
                            <li>
                                <span class="highlight">Two Pointers</span>:
                                prev（安全な位置）とcurr（探索位置）
                            </li>
                            <li>
                                <span class="highlight">重複検出</span>: curr.val ==
                                curr.next.valで判定
                            </li>
                            <li>
                                <span class="highlight">スキップ処理</span>:
                                同値ノードをすべて飛ばす
                            </li>
                        </ul>
                    </div>

                    <div id="key-points" class="tab-content">
                        <h3>アルゴリズムの特徴</h3>
                        <ul>
                            <li><strong>時間計算量：</strong> O(n) - 各ノードを一度だけ走査</li>
                            <li><strong>空間計算量：</strong> O(1) - 追加のデータ構造不要</li>
                            <li><strong>安定性：</strong> ソート順を維持</li>
                            <li><strong>効率性：</strong> インプレース操作</li>
                        </ul>
                    </div>
                </section>

                <!-- Step by Step -->
                <section class="section steps">
                    <h2 class="section-title">
                        <div class="section-icon"><i class="fas fa-list-ol"></i></div>
                        ステップバイステップ解説
                    </h2>

                    <div class="step-container">
                        <div
                            class="step"
                            onclick="highlightStep(1)"
                            tabindex="0"
                            role="button"
                            aria-label="Step 1: ダミーノードの初期化"
                        >
                            <div class="step-header">
                                <div class="step-number">1</div>
                                <div class="step-title">ダミーノードの初期化</div>
                            </div>
                            <p>
                                処理を簡潔にするためダミーノードを作成し、元のheadに接続します。prevポインタをダミーノードに設定。
                            </p>
                        </div>

                        <div
                            class="step"
                            onclick="highlightStep(2)"
                            tabindex="0"
                            role="button"
                            aria-label="Step 2: 重複の検出"
                        >
                            <div class="step-header">
                                <div class="step-number">2</div>
                                <div class="step-title">重複の検出</div>
                            </div>
                            <p>
                                currノードの値とcurr.nextノードの値を比較し、重複があるかチェックします。
                            </p>
                        </div>

                        <div
                            class="step"
                            onclick="highlightStep(3)"
                            tabindex="0"
                            role="button"
                            aria-label="Step 3: 重複ノードのスキップ"
                        >
                            <div class="step-header">
                                <div class="step-number">3</div>
                                <div class="step-title">重複ノードのスキップ</div>
                            </div>
                            <p>
                                重複が見つかった場合、同じ値を持つすべてのノードをスキップしてcurrを進めます。
                            </p>
                        </div>

                        <div
                            class="step"
                            onclick="highlightStep(4)"
                            tabindex="0"
                            role="button"
                            aria-label="Step 4: リンクの再構築"
                        >
                            <div class="step-header">
                                <div class="step-number">4</div>
                                <div class="step-title">リンクの再構築</div>
                            </div>
                            <p>prev.nextをcurrに設定し、重複ノードを除外したリンクを構築します。</p>
                        </div>

                        <div
                            class="step"
                            onclick="highlightStep(5)"
                            tabindex="0"
                            role="button"
                            aria-label="Step 5: ポインタの更新"
                        >
                            <div class="step-header">
                                <div class="step-number">5</div>
                                <div class="step-title">ポインタの更新</div>
                            </div>
                            <p>
                                重複がない場合はprevとcurrの両方を次に進め、重複がある場合はcurrのみ進めます。
                            </p>
                        </div>
                    </div>

                    <div style="text-align: center">
                        <button class="demo-btn" onclick="runDemo()" aria-label="自動デモを実行">
                            <i class="fas fa-play"></i> 自動デモを実行
                        </button>
                    </div>

                    <div class="visualization-container">
                        <h3 style="text-align: center; margin-bottom: 20px">
                            実行例：[1,2,3,3,4,4,5] → [1,2,5]
                        </h3>
                        <div id="visualization-display">
                            <div class="linked-list">
                                <div class="node pointer">dummy</div>
                                <div class="arrow">→</div>
                                <div class="node unique">1</div>
                                <div class="arrow">→</div>
                                <div class="node unique">2</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate">3</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate">3</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate">4</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate">4</div>
                                <div class="arrow">→</div>
                                <div class="node unique">5</div>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Code Implementation -->
                <section class="section code">
                    <h2 class="section-title">
                        <div class="section-icon"><i class="fas fa-code"></i></div>
                        実装コード
                    </h2>

                    <div class="tabs">
                        <button class="tab active" onclick="switchCodeTab('competitive', this)">
                            競技プログラミング版
                        </button>
                        <button class="tab" onclick="switchCodeTab('production', this)">
                            業務開発版
                        </button>
                    </div>

                    <div id="competitive" class="tab-content active">
                        <div class="code-container">
                            <div class="code-header">
                                <span class="code-title">solution_competitive.py</span>
                                <button
                                    class="copy-btn"
                                    onclick="copyCode('competitive-code')"
                                    aria-label="コードをクリップボードにコピー"
                                >
                                    <i class="fas fa-copy"></i> コピー
                                </button>
                            </div>
                            <pre
                                class="line-numbers"
                            ><code id="competitive-code" class="language-python">from typing import Optional

class ListNode:
    def __init__(self, val: int = 0, next: Optional["ListNode"] = None) -> None:
        self.val: int = val
        self.next: Optional["ListNode"] = next

class Solution:
    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        Time Complexity: O(n)  - 各ノードを一度だけ走査
        Space Complexity: O(1) - ポインタ操作のみ
        """
        dummy = ListNode(0, head)  # ダミーノード作成
        prev = dummy  # 最後に確定したユニーク要素の直前
        curr = head

        while curr:
            # 重複チェック
            if curr.next and curr.val == curr.next.val:
                # 重複値を保存
                dup_val = curr.val
                # 同じ値のノードをすべてスキップ
                while curr and curr.val == dup_val:
                    curr = curr.next
                # 重複ノードを飛ばして接続
                prev.next = curr
            else:
                # 重複なしの場合、ポインタを進める
                prev = curr
                curr = curr.next

        return dummy.next</code></pre>
                        </div>
                    </div>

                    <div id="production" class="tab-content">
                        <div class="code-container">
                            <div class="code-header">
                                <span class="code-title">solution_production.py</span>
                                <button
                                    class="copy-btn"
                                    onclick="copyCode('production-code')"
                                    aria-label="コードをクリップボードにコピー"
                                >
                                    <i class="fas fa-copy"></i> コピー
                                </button>
                            </div>
                            <pre
                                class="line-numbers"
                            ><code id="production-code" class="language-python">from typing import Optional

class ListNode:
    def __init__(self, val: int = 0, next: Optional["ListNode"] = None) -> None:
        self.val: int = val
        self.next: Optional["ListNode"] = next

class Solution:
    def deleteDuplicates_safe(self, head: Optional[ListNode]) -> Optional[ListNode]:
        """
        型安全・エラーハンドリング付きの堅牢版

        Args:
            head: 連結リストの先頭ノード

        Returns:
            重複を除去した連結リストの先頭ノード

        Raises:
            TypeError: headがListNodeまたはNoneでない場合
        """
        # 入力検証
        if head is not None and not isinstance(head, ListNode):
            raise TypeError("head must be a ListNode or None")

        # エッジケース処理
        if head is None or head.next is None:
            return head

        dummy = ListNode(0, head)
        prev = dummy
        curr = head

        while curr:
            if curr.next and curr.val == curr.next.val:
                dup_val = curr.val
                # 重複ノードを安全にスキップ
                while curr and curr.val == dup_val:
                    curr = curr.next
                prev.next = curr
            else:
                prev = curr
                curr = curr.next

        return dummy.next</code></pre>
                        </div>
                    </div>
                </section>

                <!-- Complexity Analysis -->
                <section class="section complexity">
                    <h2 class="section-title">
                        <div class="section-icon"><i class="fas fa-chart-line"></i></div>
                        計算量解析
                    </h2>

                    <div class="complexity-grid">
                        <div class="complexity-card">
                            <div class="complexity-title">時間計算量</div>
                            <div class="complexity-value">O(n)</div>
                            <p>
                                各ノードを最大で一度だけ走査するため、線形時間で処理が完了します。
                            </p>
                        </div>

                        <div class="complexity-card">
                            <div class="complexity-title">空間計算量</div>
                            <div class="complexity-value">O(1)</div>
                            <p>
                                ダミーノードと数個のポインタ変数のみ使用。入力サイズに依存しない定数空間。
                            </p>
                        </div>
                    </div>

                    <div
                        style="
                            background: #f8fafc;
                            padding: 25px;
                            border-radius: 15px;
                            margin-top: 20px;
                        "
                    >
                        <h3 style="color: #2d3748; margin-bottom: 15px">パフォーマンス特性</h3>
                        <ul style="color: #4a5568; line-height: 1.8">
                            <li>
                                <strong>最良の場合：</strong> 重複なし →
                                O(n)時間で全ノードを一度走査
                            </li>
                            <li>
                                <strong>最悪の場合：</strong> 全て重複 → O(n)時間で全ノードを削除
                            </li>
                            <li><strong>平均の場合：</strong> 部分的重複 → O(n)時間で効率的処理</li>
                            <li>
                                <strong>メモリ効率：</strong>
                                インプレース操作でメモリ使用量を最小化
                            </li>
                        </ul>
                    </div>
                </section>
            </main>
        </div>

        <!-- External Scripts -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

        <script>
            // Global state
            let isDemo = false;
            let demoInterval = null;

            // Initialize application
            document.addEventListener('DOMContentLoaded', function () {
                initializeCodeHighlighting();
                initializeAnimations();
                initializeAccessibility();
                console.log('Application initialized successfully');
            });

            // Initialize code highlighting
            function initializeCodeHighlighting() {
                // Add line numbers to all code blocks
                document.querySelectorAll('pre code').forEach(function (block) {
                    if (!block.parentElement.classList.contains('line-numbers')) {
                        block.parentElement.classList.add('line-numbers');
                    }
                });

                // Highlight code
                if (typeof Prism !== 'undefined') {
                    Prism.highlightAll();
                }
            }

            // Initialize animations
            function initializeAnimations() {
                const sections = document.querySelectorAll('.section');
                const observer = new IntersectionObserver(
                    (entries) => {
                        entries.forEach((entry) => {
                            if (entry.isIntersecting) {
                                entry.target.classList.add('fade-in');
                            }
                        });
                    },
                    {
                        threshold: 0.1,
                        rootMargin: '0px 0px -50px 0px',
                    },
                );

                sections.forEach((section) => observer.observe(section));
            }

            // Initialize accessibility
            function initializeAccessibility() {
                // Add ARIA attributes to steps
                document.querySelectorAll('.step').forEach((step, index) => {
                    step.setAttribute('role', 'button');
                    step.setAttribute('tabindex', '0');
                    step.setAttribute(
                        'aria-label',
                        `Step ${index + 1}: ${step.querySelector('.step-title').textContent}`,
                    );

                    // Add keyboard support
                    step.addEventListener('keydown', function (e) {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            step.click();
                        }
                    });
                });

                // Add ARIA attributes to copy buttons
                document.querySelectorAll('.copy-btn').forEach((btn) => {
                    btn.setAttribute('aria-label', 'Copy code to clipboard');
                });
            }

            // Tab switching for overview section
            function switchTab(tabName, element) {
                try {
                    // Remove active class from all tabs and contents
                    const parentSection = element.closest('.section');
                    parentSection
                        .querySelectorAll('.tab')
                        .forEach((tab) => tab.classList.remove('active'));
                    parentSection
                        .querySelectorAll('.tab-content')
                        .forEach((content) => content.classList.remove('active'));

                    // Add active class to clicked tab and corresponding content
                    element.classList.add('active');
                    const targetContent = document.getElementById(tabName);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                } catch (error) {
                    console.error('Error switching tab:', error);
                }
            }

            // Tab switching for code section
            function switchCodeTab(tabName, element) {
                try {
                    const codeSection = document.querySelector('.code');
                    codeSection
                        .querySelectorAll('.tab')
                        .forEach((tab) => tab.classList.remove('active'));
                    codeSection
                        .querySelectorAll('.tab-content')
                        .forEach((content) => content.classList.remove('active'));

                    element.classList.add('active');
                    const targetContent = document.getElementById(tabName);
                    if (targetContent) {
                        targetContent.classList.add('active');
                    }
                } catch (error) {
                    console.error('Error switching code tab:', error);
                }
            }

            // Step highlighting with error handling
            function highlightStep(stepNum) {
                try {
                    if (isDemo) return; // Prevent manual interaction during demo

                    // Remove active class from all steps
                    document
                        .querySelectorAll('.step')
                        .forEach((step) => step.classList.remove('active'));

                    // Add active class to clicked step
                    const clickedStep = event.currentTarget;
                    if (clickedStep) {
                        clickedStep.classList.add('active');
                    }

                    // Update visualization
                    updateVisualization(stepNum);
                } catch (error) {
                    console.error('Error highlighting step:', error);
                }
            }

            // Visualization update with comprehensive step handling
            function updateVisualization(step) {
                try {
                    const display = document.getElementById('visualization-display');
                    if (!display) {
                        console.error('Visualization display element not found');
                        return;
                    }

                    let content = '';

                    switch (step) {
                        case 1:
                            content = `
                            <div class="linked-list">
                                <div class="node pointer" style="background: #bee3f8; border-color: #4299e1;">dummy</div>
                                <div class="arrow">→</div>
                                <div class="node">1</div>
                                <div class="arrow">→</div>
                                <div class="node">2</div>
                                <div class="arrow">→</div>
                                <div class="node">3</div>
                                <div class="arrow">→</div>
                                <div class="node">3</div>
                                <div class="arrow">→</div>
                                <div class="node">4</div>
                                <div class="arrow">→</div>
                                <div class="node">4</div>
                                <div class="arrow">→</div>
                                <div class="node">5</div>
                            </div>
                            <p style="text-align: center; color: #4a5568; margin-top: 15px; font-weight: 500;">
                                <strong>Step 1:</strong> ダミーノード作成、prev = dummy, curr = head
                            </p>
                        `;
                            break;
                        case 2:
                            content = `
                            <div class="linked-list">
                                <div class="node pointer">dummy</div>
                                <div class="arrow">→</div>
                                <div class="node unique">1</div>
                                <div class="arrow">→</div>
                                <div class="node unique">2</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate pulse">3</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate pulse">3</div>
                                <div class="arrow">→</div>
                                <div class="node">4</div>
                                <div class="arrow">→</div>
                                <div class="node">4</div>
                                <div class="arrow">→</div>
                                <div class="node">5</div>
                            </div>
                            <p style="text-align: center; color: #4a5568; margin-top: 15px; font-weight: 500;">
                                <strong>Step 2:</strong> curr.val == curr.next.val を検出 (3 == 3)
                            </p>
                        `;
                            break;
                        case 3:
                            content = `
                            <div class="linked-list">
                                <div class="node pointer">dummy</div>
                                <div class="arrow">→</div>
                                <div class="node unique">1</div>
                                <div class="arrow">→</div>
                                <div class="node unique">2</div>
                                <div class="arrow">→</div>
                                <div class="node" style="opacity: 0.3; text-decoration: line-through; background: #fed7d7;">3</div>
                                <div class="arrow" style="opacity: 0.3;">→</div>
                                <div class="node" style="opacity: 0.3; text-decoration: line-through; background: #fed7d7;">3</div>
                                <div class="arrow">→</div>
                                <div class="node">4</div>
                                <div class="arrow">→</div>
                                <div class="node">4</div>
                                <div class="arrow">→</div>
                                <div class="node">5</div>
                            </div>
                            <p style="text-align: center; color: #4a5568; margin-top: 15px; font-weight: 500;">
                                <strong>Step 3:</strong> 重複値3のノードをすべてスキップ
                            </p>
                        `;
                            break;
                        case 4:
                            content = `
                            <div class="linked-list">
                                <div class="node pointer">dummy</div>
                                <div class="arrow">→</div>
                                <div class="node unique">1</div>
                                <div class="arrow">→</div>
                                <div class="node unique">2</div>
                                <div class="arrow" style="color: #667eea; font-weight: bold; font-size: 2rem;">⤴</div>
                                <div class="node duplicate pulse">4</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate pulse">4</div>
                                <div class="arrow">→</div>
                                <div class="node">5</div>
                            </div>
                            <p style="text-align: center; color: #4a5568; margin-top: 15px; font-weight: 500;">
                                <strong>Step 4:</strong> prev.next = curr でリンク再構築、次の重複を検出 (4 == 4)
                            </p>
                        `;
                            break;
                        case 5:
                            content = `
                            <div class="linked-list">
                                <div class="node pointer">dummy</div>
                                <div class="arrow">→</div>
                                <div class="node unique">1</div>
                                <div class="arrow">→</div>
                                <div class="node unique">2</div>
                                <div class="arrow">→</div>
                                <div class="node unique">5</div>
                            </div>
                            <p style="text-align: center; color: #4a5568; margin-top: 15px; font-weight: 500;">
                                <strong>Step 5:</strong> 最終結果: [1, 2, 5] - 重複要素を完全削除
                            </p>
                        `;
                            break;
                        default:
                            content = `
                            <div class="linked-list">
                                <div class="node pointer">dummy</div>
                                <div class="arrow">→</div>
                                <div class="node unique">1</div>
                                <div class="arrow">→</div>
                                <div class="node unique">2</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate">3</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate">3</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate">4</div>
                                <div class="arrow">→</div>
                                <div class="node duplicate">4</div>
                                <div class="arrow">→</div>
                                <div class="node unique">5</div>
                            </div>
                            <p style="text-align: center; color: #4a5568; margin-top: 15px; font-weight: 500;">
                                初期状態: 重複要素の削除前
                            </p>
                        `;
                    }

                    // Update display with smooth transition
                    display.style.opacity = '0';
                    setTimeout(() => {
                        display.innerHTML = content;
                        display.style.opacity = '1';
                        display.classList.add('slide-in');
                        setTimeout(() => display.classList.remove('slide-in'), 500);
                    }, 200);
                } catch (error) {
                    console.error('Error updating visualization:', error);
                }
            }

            // Enhanced copy code functionality with better error handling
            function copyCode(codeId) {
                try {
                    const codeElement = document.getElementById(codeId);
                    if (!codeElement) {
                        console.error('Code element not found:', codeId);
                        return;
                    }

                    const textContent = codeElement.textContent || codeElement.innerText;
                    const button = event.target.closest('.copy-btn');

                    if (!button) {
                        console.error('Copy button not found');
                        return;
                    }

                    // Modern clipboard API
                    if (navigator.clipboard && window.isSecureContext) {
                        navigator.clipboard
                            .writeText(textContent)
                            .then(() => {
                                showCopyFeedback(button, true);
                            })
                            .catch((err) => {
                                console.error('Clipboard API failed:', err);
                                fallbackCopyToClipboard(textContent, button);
                            });
                    } else {
                        fallbackCopyToClipboard(textContent, button);
                    }
                } catch (error) {
                    console.error('Error copying code:', error);
                    const button = event.target.closest('.copy-btn');
                    if (button) {
                        showCopyFeedback(button, false);
                    }
                }
            }

            // Fallback copy method for older browsers
            function fallbackCopyToClipboard(text, button) {
                try {
                    const textArea = document.createElement('textarea');
                    textArea.value = text;
                    textArea.style.position = 'fixed';
                    textArea.style.left = '-999999px';
                    textArea.style.top = '-999999px';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();

                    const successful = document.execCommand('copy');
                    document.body.removeChild(textArea);

                    showCopyFeedback(button, successful);
                } catch (error) {
                    console.error('Fallback copy failed:', error);
                    showCopyFeedback(button, false);
                }
            }

            // Show copy feedback to user
            function showCopyFeedback(button, success) {
                const originalText = button.innerHTML;
                const originalColor = button.style.background;

                if (success) {
                    button.innerHTML = '<i class="fas fa-check"></i> コピーしました！';
                    button.style.background = '#48bb78';
                } else {
                    button.innerHTML = '<i class="fas fa-exclamation-triangle"></i> コピー失敗';
                    button.style.background = '#f56565';
                }

                button.disabled = true;

                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.style.background = originalColor || '#667eea';
                    button.disabled = false;
                }, 2000);
            }

            // Enhanced demo functionality with better control
            function runDemo() {
                try {
                    if (isDemo) {
                        stopDemo();
                        return;
                    }

                    isDemo = true;
                    const demoButton = event.target;
                    const originalText = demoButton.innerHTML;

                    demoButton.innerHTML = '<i class="fas fa-stop"></i> デモを停止';
                    demoButton.style.background = '#f56565';

                    let currentStep = 1;
                    const maxSteps = 5;

                    // Clear any existing active steps
                    document
                        .querySelectorAll('.step')
                        .forEach((step) => step.classList.remove('active'));

                    // Initial step
                    updateVisualization(currentStep);
                    document.querySelector('.step:nth-child(1)').classList.add('active');

                    demoInterval = setInterval(() => {
                        currentStep++;

                        if (currentStep <= maxSteps) {
                            // Remove previous active step
                            document
                                .querySelectorAll('.step')
                                .forEach((step) => step.classList.remove('active'));

                            // Update visualization and highlight current step
                            updateVisualization(currentStep);
                            const targetStep = document.querySelector(
                                `.step:nth-child(${currentStep})`,
                            );
                            if (targetStep) {
                                targetStep.classList.add('active');
                            }
                        } else {
                            // Demo completed
                            clearInterval(demoInterval);

                            setTimeout(() => {
                                document
                                    .querySelectorAll('.step')
                                    .forEach((step) => step.classList.remove('active'));
                                updateVisualization(0);

                                // Reset button
                                demoButton.innerHTML = originalText;
                                demoButton.style.background = '#667eea';
                                isDemo = false;
                            }, 2000);
                        }
                    }, 2500); // Slower pace for better comprehension
                } catch (error) {
                    console.error('Error running demo:', error);
                    stopDemo();
                }
            }

            // Stop demo function
            function stopDemo() {
                if (demoInterval) {
                    clearInterval(demoInterval);
                    demoInterval = null;
                }

                isDemo = false;
                const demoButton = document.querySelector('.demo-btn');
                if (demoButton) {
                    demoButton.innerHTML = '<i class="fas fa-play"></i> 自動デモを実行';
                    demoButton.style.background = '#667eea';
                }

                // Clear active states
                document
                    .querySelectorAll('.step')
                    .forEach((step) => step.classList.remove('active'));
                updateVisualization(0);
            }

            // Enhanced keyboard navigation
            document.addEventListener('keydown', function (event) {
                if (isDemo) return; // Disable keyboard navigation during demo

                const steps = Array.from(document.querySelectorAll('.step'));
                const activeStep = document.querySelector('.step.active');
                let currentIndex = activeStep ? steps.indexOf(activeStep) : -1;

                switch (event.key) {
                    case 'ArrowRight':
                    case 'ArrowDown':
                        event.preventDefault();
                        if (currentIndex < steps.length - 1) {
                            const nextStep = steps[currentIndex + 1];
                            nextStep.click();
                            nextStep.focus();
                        }
                        break;

                    case 'ArrowLeft':
                    case 'ArrowUp':
                        event.preventDefault();
                        if (currentIndex > 0) {
                            const prevStep = steps[currentIndex - 1];
                            prevStep.click();
                            prevStep.focus();
                        }
                        break;

                    case 'Escape':
                        if (isDemo) {
                            stopDemo();
                        }
                        break;

                    case ' ':
                        if (document.activeElement.classList.contains('demo-btn')) {
                            event.preventDefault();
                            document.activeElement.click();
                        }
                        break;
                }
            });

            // Performance monitoring
            window.addEventListener('load', function () {
                if (performance && performance.mark) {
                    performance.mark('app-loaded');
                    console.log('Application fully loaded');
                }
            });

            // Error boundary for uncaught errors
            window.addEventListener('error', function (event) {
                console.error('Uncaught error:', event.error);
            });

            // Handle visibility change (tab switching)
            document.addEventListener('visibilitychange', function () {
                if (document.hidden && isDemo) {
                    stopDemo();
                }
            });
        </script>
    </body>
</html>
