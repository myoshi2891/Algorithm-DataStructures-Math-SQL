以下に、\*\*mod P 上のべき乗演算を高速に行うアルゴリズム（繰り返し二乗法）\*\*について、図を用いて段階的に解析・説明します。
対象クエリは以下の例とします：

---

## 🎯 例題

```
P = 17
X = 3
Y = 13
```

このとき、
求めるのは：

$$
3^{13} \mod 17
$$

---

## 🔧 ステップ1：Y を 2 進数に変換

13 を 2 進数に変換します：

```
13 = 1101₂ = 8 + 4 + 1
```

```
  2進数ビット:   1     1     0     1
                ↑     ↑     ↑     ↑
   2のべき乗: 2^3   2^2   2^1   2^0
```

---

## 📘 ステップ2：X の 2^k 乗を mod P 上で事前計算

### mod P 上で以下を計算しておきます：

| 指数 k | 3<sup>2^k</sup> mod 17 | 計算内容 |
| ------ | ---------------------- | -------- |
| 0      | 3                      | 初期値   |
| 1      | (3 × 3) % 17 = 9       | 3²       |
| 2      | (9 × 9) % 17 = 13      | 3⁴       |
| 3      | (13 × 13) % 17 = 16    | 3⁸       |

---

## 🔢 ステップ3：必要なビットだけ掛ける

Y = `1101₂` のうち、**1ビットだけ**掛け合わせます：

| ビット位置 (k) | 2^k | Y のビット値 | X<sup>2^k</sup> (mod 17) | 掛けるか |
| -------------- | --- | ------------ | ------------------------ | -------- |
| 0              | 1   | 1            | 3                        | ✅       |
| 1              | 2   | 0            | 9                        | ❌       |
| 2              | 4   | 1            | 13                       | ✅       |
| 3              | 8   | 1            | 16                       | ✅       |

したがって：

$$
3^{13} \mod 17 = 3 \times 13 \times 16 \mod 17
$$

---

## 🧮 ステップ4：mod 17 上で掛け合わせ

1つずつ掛けていきます：

```
Step 1: 3 × 13 = 39 → 39 % 17 = 5
Step 2: 5 × 16 = 80 → 80 % 17 = 12
```

---

## ✅ 最終答え：

```
3^13 mod 17 = 12
```

---

## 🧩 全体フロー図

```plaintext
          Y = 13 = 1101₂
                ↓
     ----------------------------
     | index | 2^k | bit | used? |
     ----------------------------
     |   0   |  1  |  1  |  ✔   → base = 3
     |   1   |  2  |  0  |  ✘
     |   2   |  4  |  1  |  ✔   → base^4 = 13
     |   3   |  8  |  1  |  ✔   → base^8 = 16
     ----------------------------
           ↓ 乗算対象：3, 13, 16
           ↓
      計算: (((3 × 13) % 17) × 16) % 17
           ↓
           結果: 12
```

---

## 🧠 アルゴリズムの本質（繰り返し二乗法）

- **O(log₂Y)** の計算量
- Y の各ビットに対応する `X^(2^k)` を計算し、ビットが 1 のものだけ掛ける
- 大きな指数でも桁落ちせずに計算可能（ただし BigInt 必須）

---

## 🧪 BigInt 利用のイメージ図

```plaintext
      (例) Y = 1000000000000000000n
                 ↓
   2進数ビット列は60ビット以上
                 ↓
      log₂Y ≒ 60 ステップだけで完了
```

`Number` 型だと正確にビット列が取れない → `BigInt` は必須！

---

## ✅ パフォーマンス上の利点

| 特徴                 | 通常の累乗法               | 繰り返し二乗法    |
| -------------------- | -------------------------- | ----------------- |
| 1回の指数処理        | O(Y)                       | ✅ O(log₂Y)       |
| 高速性               | 遅い（指数が大きいと不可） | ✅ 高速           |
| 10^18 に対応可能か   | ❌ 無理                    | ✅ 可能（BigInt） |
| JavaScriptでの実装性 | Numberのみでは不可         | ✅ BigInt使用で可 |

---

## 🔚 結論

- `X^Y % P` を求めるには **繰り返し二乗法** が最も適しており、
- `Y` が非常に大きくなる問題においても **安全・高速** に処理できる。
- JavaScript では `BigInt` を用いることでこのアルゴリズムを精度損失なく実装できる。

---

必要であれば、**他の例（Pが大きい、XやYが境界値のとき）での図解**も可能です！
