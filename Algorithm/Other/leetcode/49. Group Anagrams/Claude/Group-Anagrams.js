// この解決策の特徴とパフォーマンスについて説明します：

// ## アルゴリズムの解説
// 1. **キー生成**: 各文字列をソートして、アナグラム同士が同じキーを持つようにします
// 2. **グループ化**: `Map`オブジェクトを使ってキーごとにアナグラムをグループ化します
// 3. **結果返却**: `Map`の値をすべて配列として返却します

// ## パフォーマンス分析
// - **時間計算量**: `O(N * K log K)`
//   - N: 文字列の数（`strs.length`）
//   - K: 最長文字列の長さ
//   - 各文字列のソートに `O(K log K)` かかります

// - **空間計算量**: `O(N * K)`
//   - すべての文字列を格納するために必要な空間

// ## 最適化のポイント
// 1. **`Map`の使用**: オブジェクトリテラルより高速なキー検索
// 2. **`Array.from(map.values())`**: 効率的な値の抽出
// 3. **文字列ソート**: アナグラム判定の標準的で信頼性の高い方法

// このソリューションは制約条件（文字列数最大10^4、文字列長最大100）に対して十分に効率的で、LeetCodeでの実行においても良好なパフォーマンスを示すはずです。

/**
 * アナグラムをグループ化する関数
 * @param {string[]} strs - 文字列の配列
 * @return {string[][]} - グループ化されたアナグラムの2次元配列
 */
var groupAnagrams = function (strs) {
    // Mapオブジェクトを使用してアナグラムをグループ化
    // キー: ソートされた文字列、値: アナグラムの配列
    const anagramMap = new Map();

    for (const str of strs) {
        // 文字列をソートしてキーとして使用
        // split('')で文字配列に変換 → sort()でソート → join('')で文字列に戻す
        const sortedStr = str.split('').sort().join('');

        // Mapにキーが存在しない場合は新しい配列を作成
        if (!anagramMap.has(sortedStr)) {
            anagramMap.set(sortedStr, []);
        }

        // 現在の文字列をグループに追加
        anagramMap.get(sortedStr).push(str);
    }

    // Mapの値（アナグラムのグループ）を配列として返却
    return Array.from(anagramMap.values());
};
