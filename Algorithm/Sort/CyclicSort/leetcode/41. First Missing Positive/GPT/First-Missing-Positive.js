// 以下のコードは **O(n) 時間・O(1) 追加メモリ** で最小の欠けている正整数を求める実装です。
// 配列をインプレースで並べ替える **"cyclic sort"（配置スワップ法）** を利用します。

// ```javascript
/**
 * 最小の欠けている正整数を返す
 * @param {number[]} nums - 整数配列（順不同、重複あり、負数あり）
 * @returns {number} - 配列に存在しない最小の正の整数
 * 
 * 時間計算量: O(n)  
 * 空間計算量: O(1) （インプレース処理）
 * Node.js 18.16.1 / LeetCode 環境対応
 */
function firstMissingPositive(nums) {
    const n = nums.length;

    // インプレースで正しい位置に正整数を配置
    for (let i = 0; i < n; i++) {
        while (
            nums[i] > 0 &&
            nums[i] <= n &&
            nums[nums[i] - 1] !== nums[i]
        ) {
            const correctIndex = nums[i] - 1;
            // ES6構文でスワップ
            [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];
        }
    }

    // 1からnまで順に確認し、位置と値が一致しない最初のものが答え
    for (let i = 0; i < n; i++) {
        if (nums[i] !== i + 1) {
            return i + 1;
        }
    }

    // 全て一致する場合は n+1 が答え
    return n + 1;
}

// ### 実装のポイント

// 1. **インプレース配置**

//    * 値 `x` が `1 <= x <= n` の場合、インデックス `x-1` に置く。
//    * すでに同じ値がある場合は無限ループを避けるためスキップ。

// 2. **O(n) 時間**

//    * 各要素は最大1回しか正しい位置に移動されないため、総操作回数は O(n)。

// 3. **O(1) 追加メモリ**

//    * 配列内で直接スワップして順序を整えるため、追加の配列は不要。

// 4. **負数や範囲外の値は無視**

//    * 配置対象は `[1, n]` の範囲内のみ。

// ---

// もし希望すれば、このアルゴリズムの **ステップごとの図解トレース** も作成できますが、作りますか？
// そうすれば、どう O(1) メモリで実現しているかが一目でわかります。
