---

> **「長さ N の数列 A からいくつか選んで、和をちょうど K にできるか？
> できるなら最小個数で、かつ選んだ要素を降順に並べたとき辞書順最大になるように選ぶ」**

に対して、修正版のJavaScriptコードを使って、**各処理の流れ・役割・考え方**を**図解付きで詳細に解析**します。

---

## 🧠 問題の本質：

- 単なる部分和判定問題（Subset Sum）ではなく、
  ① **和が K**、② **最小個数で**、③ **辞書順最大な列を構成**という3つの条件を同時に満たす必要があります。

---

## 🏗️ アルゴリズム全体像（構成）

```mermaid
flowchart TD
    A[入力：N, K, A[]] --> B[降順ソート]
    B --> C[DP配列 dp[0...K]を初期化]
    C --> D[各要素 a in A をループ]
    D --> E[各合計 sum (K→0) をループ]
    E --> F{dp[sum] が存在？}
    F -- いいえ --> E
    F -- はい --> G[dp[sum+a] の更新を試みる]
    G --> H{より少ない個数？または辞書順が大？}
    H -- はい --> I[更新]
    H -- いいえ --> E
    I --> E
    E --> D
    D --> J{dp[K] が存在？}
    J -- いいえ --> K[出力 -1]
    J -- はい --> L[個数と降順出力]
```

---

## 🔍 ステップごとの詳細と図解

---

### ✅ 1. 入力と降順ソート

```js
const A = input[1].split(' ').map(Number);
A.sort((a, b) => b - a);
```

#### 🔎 なぜ降順にする？

辞書順最大な数列を得るには、大きい数から使うべき。
→ 小さい数を先に選んでしまうと、「より良い構成」チャンスを逃す。

#### 例：

```
A = [1, 2, 3] → ソート後 → [3, 2, 1]
```

---

### ✅ 2. DPテーブル初期化

```js
const dp = Array(K + 1).fill(null);
dp[0] = { count: 0, list: [] }; // 和=0を作る方法（空）
```

#### 📘 意味：

- `dp[k] = { count, list }` は「和が k を作る最良の方法」を記録。
- `count`: 使用した個数（少ない方がよい）
- `list`: 使った要素列（辞書順最大を目指す）

---

### ✅ 3. 各 a ∈ A を使って dp 更新

```js
for (const a of A) {
  for (let sum = K; sum >= 0; sum--) {
    if (dp[sum] === null) continue;
    const nextSum = sum + a;
    if (nextSum > K) continue;

    const nextCount = dp[sum].count + 1;
    const nextList = [...dp[sum].list, a];
    ...
  }
}
```

---

### 🧮 DP更新の具体例（図解）

#### 入力：

```
A = [3, 2, 1]
K = 4
```

#### 初期：

```
dp[0] = {count:0, list:[]}
dp[1]～dp[4] = null
```

#### a = 3 のとき：

```
sum = 0 → nextSum = 3
→ dp[3] = {count:1, list:[3]}
```

#### a = 2 のとき：

```
sum = 0 → nextSum = 2
→ dp[2] = {count:1, list:[2]}

sum = 3 → nextSum = 5 ❌ 超過なのでスキップ
```

#### a = 1 のとき：

```
sum = 0 → nextSum = 1
→ dp[1] = {count:1, list:[1]}

sum = 2 → nextSum = 3
既に dp[3] = {count:1, list:[3]} がある
→ 新候補 = {count:2, list:[2,1]} は個数多いのでスキップ

sum = 3 → nextSum = 4
→ dp[4] = {count:2, list:[3,1]}
```

---

### ✅ 4. 更新判定の詳細条件：

```js
if (
  dp[nextSum] === null ||
  nextCount < dp[nextSum].count ||
  (nextCount === dp[nextSum].count && isLexGreater(nextList, dp[nextSum].list))
)
```

#### 🧠 これは何をしている？

1. 初めて到達 → 無条件採用
2. 個数が少ない → 採用
3. 個数が同じで辞書順が大 → 採用

#### ⚖️ 辞書順比較関数：

```js
function isLexGreater(a, b) {
    for (let i = 0; i < a.length && i < b.length; i++) {
        if (a[i] !== b[i]) return a[i] > b[i];
    }
    return a.length > b.length;
}
```

---

## 🎯 最終判定と出力

```js
if (dp[K] === null) return [-1];
return [dp[K].count, dp[K].list.sort((a, b) => b - a)];
```

### ✅ 辞書順最大にするため、出力前に降順ソート

---

## 🧪 テストケース例とDP表可視化

### 例：

A = \[3, 2, 1], K = 4

| k   | dp\[k].count | dp\[k].list |
| --- | ------------ | ----------- |
| 0   | 0            | \[]         |
| 1   | 1            | \[1]        |
| 2   | 1            | \[2]        |
| 3   | 1            | \[3]        |
| 4   | 2            | \[3, 1] ✅  |

出力：

```
2
3 1
```

---

## ✅ このDPの工夫のまとめ

| 工夫             | 内容                                          |
| ---------------- | --------------------------------------------- |
| 辞書順最大       | A を降順ソート + 更新時比較                   |
| 最小個数         | dp\[k].count で制御                           |
| 復元             | list に要素を追加してトラッキング             |
| オーバーラン防止 | nextSum > K を即スキップ                      |
| 高速化           | K から 0 への逆ループで同一ステップ内重複防止 |

---

## 📌 総合評価（難しさ・工夫点）

| 項目         | 評価                                 |
| ------------ | ------------------------------------ |
| 時間計算量   | O(N×K)                               |
| メモリ計算量 | O(K×M), M:最大経路長                 |
| 工夫点       | 複数条件最適化のDP更新、比較関数設計 |

---

## 📎 補足：さらなる高速化のために

- `Map` や `BitSet` を使って DP のメモリ使用量を削減
- インデックストラッキングで復元を短縮

---

ご希望あれば、この実装を **インデックス復元型 / 多重使用可型 / メモリ最小型** に書き換えることも可能です。必要に応じてお知らせください。
