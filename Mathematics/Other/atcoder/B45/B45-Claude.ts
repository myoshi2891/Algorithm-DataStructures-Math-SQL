// この問題を分析してみましょう。

// 操作は「3つ中2つの整数を選び、片方に+1、もう片方に-1する」というものです。この操作の特徴を考えると：

// 1. 操作を行っても、3つの数の合計は変わりません（+1と-1を同時に行うため）
// 2. 全部を0にするには、最終的に a + b + c = 0 になる必要があります
// 3. しかし、初期状態で a + b + c ≠ 0 の場合、この操作では合計を変えることができないため、不可能です

// さらに詳しく分析すると：
// - 操作によって2つの数の差は2ずつ変化します
// - 3つの数を全て0にするには、各ペアの差も最終的に0になる必要があります
// - 初期状態で a + b + c = 0 であれば、適切な操作により全て0にできます解法の説明：

// **アルゴリズムの核心：**
// - 操作「片方に+1、もう片方に-1」は3つの数の合計を変えません
// - したがって、初期状態で `a + b + c ≠ 0` なら、どんな操作をしても全て0にはできません
// - 逆に `a + b + c = 0` なら、適切な操作により全て0にできます

// **実装のポイント：**
// 1. **BigInt使用**: 制約が-10^18 ≤ a,b,c ≤ 10^18 のため、JavaScriptのnumber型では精度が不足する可能性があります
// 2. **メモリ効率**: `fs.readFileSync`で一度に読み込み、不要な配列やオブジェクトの生成を避けました
// 3. **時間計算量**: O(1) - 単純な加算と比較のみ
// 4. **メモリ計算量**: O(1) - 固定サイズの変数のみ使用

// **なぜこの解法が正しいか：**
// - `a + b + c = 0` の場合、例えば (a,b,c) → (a-1,b,c+1) → (a-1,b-1,c+2) → ... のような操作を繰り返すことで、最終的に全て0にできます
// - 数学的には、3つの数の合計が0である限り、2つずつ選んで差を調整していくことで、必ず全て0にできることが証明できます

import * as fs from 'fs';

/**
 * 3つの整数を全て0にできるかを判定する関数
 * @param a 1つ目の整数
 * @param b 2つ目の整数
 * @param c 3つ目の整数
 * @returns 全て0にできる場合はtrue、そうでなければfalse
 */
function canMakeAllZero(a: bigint, b: bigint, c: bigint): boolean {
    // 3つの数の合計が0でなければ、操作によって全て0にすることは不可能
    // なぜなら、操作は一方に+1、もう一方に-1するため、合計は変わらないから
    return a + b + c === 0n;
}

/**
 * メイン処理関数
 * 標準入力から3つの整数を読み取り、全て0にできるかを判定して結果を出力する
 */
function main(): void {
    // メモリ使用量とパフォーマンスを考慮してfsの同期読み込みを使用
    const input = fs.readFileSync('/dev/stdin', 'utf8').trim();

    // 入力をパースして3つの整数を取得
    const numbers = input.split(' ').map((str) => BigInt(str.trim()));
    const [a, b, c] = numbers;

    // 判定処理を実行
    const result = canMakeAllZero(a, b, c);

    // 結果を出力
    console.log(result ? 'Yes' : 'No');
}

// メイン処理を実行
main();