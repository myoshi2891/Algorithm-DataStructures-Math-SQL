
---

## **問題のおさらい**

### 入力：

```text
nums = [-1, 2, 1, -4]
target = 1
```

### 出力：

```text
2
```

---

## **アルゴリズムの流れ（図解）**

### **Step1: ソート**

```text
元の配列: [-1, 2, 1, -4]
ソート後: [-4, -1, 1, 2]
```

**目的：**

* ソートしておくことで、\*\*2ポインター法（leftとrightを動かす）\*\*が使える

---

### **Step2: メインループ**

#### 概要：

* `i`を固定し、残りの`2つの数字`は**2ポインター法**で探索

---

## **図解で解説**

### **初期設定**

| インデックス | 値  |
| :----: | -- |
|    i   | -4 |
|  left  | -1 |
|  right | 2  |

---

### **Iteration 1**

#### i = 0（nums\[i] = -4）

**初期状態：**

```
[-4] [-1] [1] [2]
   ↑    ↑      ↑
   i   left   right
```

#### 1回目計算：

```
sum = -4 + (-1) + 2 = -3
diff = |1 - (-3)| = 4
```

最小差が更新される → `closestSum = -3`

---

#### leftポインターを右に移動（1に）

```
[-4] [-1] [1] [2]
   ↑         ↑ ↑
   i       left right
```

#### 2回目計算：

```
sum = -4 + 1 + 2 = -1
diff = |1 - (-1)| = 2
```

最小差が更新される → `closestSum = -1`

---

#### left移動（left=3、right=3なので終了）

---

### **Iteration 2**

#### i = 1（nums\[i] = -1）

初期状態：

```
[-4] [-1] [1] [2]
         ↑   ↑   ↑
         i  left right
```

---

#### 1回目計算：

```
sum = -1 + 1 + 2 = 2
diff = |1 - 2| = 1
```

最小差が更新される → `closestSum = 2`

---

#### rightポインターを左に移動（right=1、終了）

---

### **探索終了**

最終的な結果：

```
closestSum = 2
```

---

## **全体イメージ**

```
ソート → [-4, -1, 1, 2]

i=-4の場合：
   [-4] [-1] [1] [2]
      ↑    ↑     ↑
      i   left  right
  -3, -1 が候補

i=-1の場合：
   [-4] [-1] [1] [2]
           ↑   ↑   ↑
           i  left right
  2 が候補（最も近い）
```

---

## **解析まとめ**

| 処理内容   | 詳細             | 時間計算量      |
| ------ | -------------- | ---------- |
| ソート    | `nums.sort()`  | O(n log n) |
| メインループ | `i`固定＋2ポインター探索 | O(n²)      |
| メモリ    | 追加配列なし、O(1)    |            |

---

## **時間計算量**

| 処理     | 計算量        |
| ------ | ---------- |
| ソート    | O(n log n) |
| 2重ループ  | O(n²)      |
| **合計** | O(n²)      |

---

## **メモリ使用量**

| 項目     | メモリ            |
| ------ | -------------- |
| 入力配列   | O(n)（既存配列のみ）   |
| 補助変数   | O(1)           |
| **合計** | O(1)（追加メモリは定数） |

---

## **まとめ**

* **ソート+2ポインター法**で高速化（O(n²)）
* **直感的な探索**でシンプルかつ実用的
* 最大500要素でも問題なく動作（LeetCode制限内）
