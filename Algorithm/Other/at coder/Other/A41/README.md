---

## 🧩 問題の本質：塗れるのは「**3連続の同色のみ**」

### 操作可能なアクション：

* 「任意の位置から連続3つのタイルを、赤（R）または青（B）で塗る」
  → つまり、盤面上に `[x, x+1, x+2]` に対して同じ色を適用することしかできません。

---

## 🎯 ゴール：タイル列を最終的に `S` に一致させる

---

## ✅ 正しい判定条件：

「S に `RRR` または `BBB` のように**3つ連続で同じ色が存在するか？**」を確認するだけで十分です。

なぜなら、逆に「そのような 3 連が**一度も現れない**場合」は、どんなに操作しても `S` は作れません。

---

## 🖼️ 図で理解しよう

### 例1：`S = "RBRBR"`（R と B が交互）

```
位置:     0   1   2   3   4
        +---+---+---+---+---+
S[i]:   | R | B | R | B | R |
        +---+---+---+---+---+
```

このような構造では「3つ連続して同じ色」になる位置が**どこにもありません**。

- 操作では `[i, i+1, i+2]` をすべて同じ色にしかできない。
- つまり、**操作の結果、RBRやBRBのような構造を作ることは不可能**です。

**結論：No**

---

### 例2：`S = "BBRRRBB"`

```
位置:     0   1   2   3   4   5   6
        +---+---+---+---+---+---+---+
S[i]:   | B | B | R | R | R | B | B |
        +---+---+---+---+---+---+---+
                  ↑   ↑   ↑
               ←―RRR―→ がある！
```

この場合、`S[2] === S[3] === S[4] === 'R'` なので、**3つ連続で同じ色が存在します**。

このことから、「塗る操作によってこの状態を作ることが可能」であると判断できます。

**結論：Yes**

---

## ✅ 実際のコードの動き

```javascript
function canPaintTiles(N, S) {
    for (let i = 0; i <= N - 3; i++) {
        if (S[i] === S[i + 1] && S[i + 1] === S[i + 2]) {
            return 'Yes';
        }
    }
    return 'No';
}
```

### 流れ：

1. 文字列 `S` の先頭から末尾-2 まで `i` をループ。
2. 各位置 `i` で `S[i] == S[i+1] == S[i+2]` を確認。
3. 一致したらすぐ `Yes`。
4. 1箇所もなければ `No`。

---

## 💡 補足：なぜそれだけで良いのか？

- 操作は「**3連続の同色**しか作れない」＝3連続の同色が **必要条件**
- また、同色3連があれば、それを起点にうまく繋げて全体を作れる（十分条件）
- このことから、「3連続の同色の有無」を見るだけで正否が判定可能

---

## ✅ 時間・空間計算量

- 時間：**O(N)**（最大20万文字でも高速）
- 空間：**O(1)**（余分な配列なし）

---

## ✨ 最後に：まとめ

| ポイント     | 説明                                      |
| ------------ | ----------------------------------------- |
| 操作内容     | 3マス同色に塗るのみ                       |
| 作れる形     | `RRR`, `BBB` を組み合わせた構造のみ       |
| チェック方法 | `S[i] == S[i+1] == S[i+2]` の場所があるか |
| 成功条件     | どこか1箇所でも3連同色が存在すればOK      |

---
