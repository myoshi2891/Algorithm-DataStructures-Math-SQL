ここでは **問題: Unique Paths（m×n グリッド上を右か下にのみ移動してゴールに到達する経路数を求める）** について、

- **動的計画法 (DP) による実装**
- **計算式（組み合わせ）による実装**

の両方を「図解」を用いて解析していきます。

---

# 1. 問題設定の図解

例: `m = 3, n = 7`

```
Start (0,0)
 ↓       →       →       →       →       →       →
(1,0)    (0,1)   (0,2)   (0,3)   (0,4)   (0,5)   Goal(2,6)
 ↓
(2,0)
```

- ロボットは「右 (→)」または「下 (↓)」にしか進めない
- ゴールまでの「ユニークな経路数」を数える

---

# 2. 動的計画法 (DP) アプローチ

## 基本アイデア

- 各セル `(i, j)` に「そのセルに到達する経路数」を書き込む
- 遷移式:

    ```
    dp[i][j] = dp[i-1][j] + dp[i][j-1]
    ```

    （上から来る場合 + 左から来る場合）

---

## 2.1 DP テーブルの初期化

- 最上段（row=0）と最左列（col=0）は **常に 1 通り**しかない
  （スタートからずっと右だけ or 下だけで到達できるため）

例: `m=3, n=7`

```
1   1   1   1   1   1   1
1   .   .   .   .   .   .
1   .   .   .   .   .   .
```

---

## 2.2 DP の計算手順

次に、残りのセルを式に基づいて埋めていきます。

### Step 1: (1,1)

```
dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2
```

```
1   1   1   1   1   1   1
1   2   .   .   .   .   .
1   .   .   .   .   .   .
```

---

### Step 2: (1,2)

```
dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3
```

```
1   1   1   1   1   1   1
1   2   3   .   .   .   .
1   .   .   .   .   .   .
```

---

### Step 3: (1,3)

```
dp[1][3] = dp[0][3] + dp[1][2] = 1 + 3 = 4
```

```
1   1   1   1   1   1   1
1   2   3   4   .   .   .
1   .   .   .   .   .   .
```

---

### Step 4: 全部埋めると…

```
1   1   1   1   1   1   1
1   2   3   4   5   6   7
1   3   6  10  15  21  28
```

👉 ゴール `(2,6)` の値 = **28** が答え

---

## 2.3 計算量と最適化

- **時間計算量**: O(m×n)
- **空間計算量**: O(n) （1次元DPに圧縮可能）

実際の実装では **1行分だけ保存して更新**します。

---

# 3. 数学的アプローチ（組み合わせ）

ロボットは **必ず (m-1) 回下に行き、(n-1) 回右に行く**。
つまり合計ステップ数は `m+n-2`。

- その中から「どこで下に行くか (m-1 回)」を選ぶ組み合わせ
- 数式:

    ```
    C(m+n-2, m-1) = (m+n-2)! / ((m-1)! * (n-1)!)
    ```

---

## 3.1 図解（例: m=3, n=7）

- ステップ数 = 3+7-2 = 8
- その中で「下 (D)」を2回選ぶ

例:

```
R R R D R D R R   (パターン1)
R D R R R D R R   (パターン2)
...
```

👉 「全 8 ステップ中から 2 回 D を選ぶ」= C(8,2) = 28 通り

---

# 4. 両者の比較

| 方法   | 時間計算量        | 空間計算量 | Python実装コスト | 可読性 | 備考           |
| ------ | ----------------- | ---------- | ---------------- | ------ | -------------- |
| DP     | O(m×n)            | O(n)       | 低               | 高     | 小規模に強い   |
| 組合せ | O(1)（math.comb） | O(1)       | 極低             | 最高   | 大規模でも高速 |

👉 Python では `math.comb` が内部で C 実装されており、非常に高速。
**最適解は組合せ式**ですが、**DP も理解のため重要**です。

---

# 5. まとめ図

```
DP法
┌─────┬─────┬─────┬─────┐
│  1  │  1  │  1  │  1  │ ...
├─────┼─────┼─────┼─────┤
│  1  │  2  │  3  │  4  │ ...
├─────┼─────┼─────┼─────┤
│  1  │  3  │  6  │ 10  │ ...
└─────┴─────┴─────┴─────┘

組合せ法
ステップ数 = m+n-2
↓
その中から (m-1) 回の "下" を選ぶ
↓
答え = C(m+n-2, m-1)
```

---

「数学的アプローチ（組み合わせ）」を **さらに詳しく、図解付きで** 解説していきます。

---

# 1. 問題の整理

ロボットは

- **下 (D)** を `m-1` 回
- **右 (R)** を `n-1` 回
  動く必要があります。

➡️ 合計ステップ数 = `(m-1) + (n-1) = m+n-2`

この中で **どの位置で下 (D) を選ぶか** を決めれば経路は一意に決まります。

---

# 2. 数式で表現

組み合わせで考えると:

$$
C(m+n-2, \; m-1) = \frac{(m+n-2)!}{(m-1)! \cdot (n-1)!}
$$

- 分子 `(m+n-2)!` … 全ステップの並べ方
- 分母 `(m-1)!` … 下 (D) の並べ替え
- 分母 `(n-1)!` … 右 (R) の並べ替え

---

# 3. 図解で理解 (m=3, n=7 の例)

- `m = 3` → 下に行くのは **2回 (D)**
- `n = 7` → 右に行くのは **6回 (R)**
- 合計ステップ数 = `2 + 6 = 8`

👉 「8個の枠のうち、どの2つにDを入れるか？」 を決める。

---

### 3.1 ステップの枠を並べる

```
[ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ]
```

---

### 3.2 D を置く位置を選ぶ（例）

- D を (3,6) に置いた場合:

```
R R D R R D R R
```

- D を (2,5) に置いた場合:

```
R D R R D R R R
```

- D を (1,2) に置いた場合:

```
D D R R R R R R
```

---

### 3.3 図解（例: D を配置するイメージ）

```
枠:   [ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ][ 8 ]
選択:      D          D
経路: R D R R D R R R
```

👉 この「D を置く場所の選び方」が **組み合わせ** に対応します。

---

# 4. 実際の計算

今回の例 (m=3, n=7):

$$
C(8,2) = \frac{8!}{2! \cdot 6!} = \frac{8 \times 7}{2} = 28
$$

➡️ **28通りの経路**が存在。

---

# 5. まとめ

- ロボットの移動 = 「D と R の並べ替え」問題
- 経路数 = **組み合わせ $C(m+n-2, m-1)$**
- 図で見ると「どの枠にDを置くか？」という選び方

---

# 1. 問題の本質

ロボットはゴールに行くために、

- **下に行く (D)** → 必ず `(m-1)` 回
- **右に行く (R)** → 必ず `(n-1)` 回

合計で **(m-1) + (n-1) = m+n-2** 回の動きをします。

つまり「`D` を (m-1) 個、`R` を (n-1) 個並べた並び」を作る問題です。

---

# 2. 並べ替えの総数

まず、もし全部の動きが **異なるもの**（例: D1, D2, R1, R2, …）だと考えると、
並べ方の数は **(m+n-2)!** 通りになります。

---

# 3. 「同じ動き」の調整

しかし実際には

- D1, D2, … (m-1個) は区別できない → (m-1)! で割る
- R1, R2, … (n-1個) も区別できない → (n-1)! で割る

したがって **重複を除いた並べ方**は:

$$
\frac{(m+n-2)!}{(m-1)! \cdot (n-1)!}
$$

これが **組み合わせ式 C(m+n-2, m-1)** です。

---

# 4. なぜ「組み合わせ」になるのか？

実は同じことを別の視点で説明できます。

- 合計 `m+n-2` ステップの枠がある
- そのうち「どの枠を下 (D) にするか」を選ぶ

つまり「`m+n-2` 個の枠から `(m-1)` 個を選ぶ組み合わせ」

これがそのまま

$$
C(m+n-2, m-1)
$$

になります。

---

# 5. 図解（例: m=3, n=7）

- 下: (m-1)=2 回
- 右: (n-1)=6 回
- 合計: 8 ステップ

ステップ枠を並べると:

```
[1][2][3][4][5][6][7][8]
```

- この中から **2個をDにする**選び方が C(8,2)。
- 具体例:
    - (1,2) → D D R R R R R R
    - (2,5) → R D R R D R R R
    - (3,6) → R R D R R D R R
    - … (28通り)

---

# 6. 数学式のまとめ

$$
C(m+n-2, m-1) = \frac{(m+n-2)!}{(m-1)! \cdot (n-1)!}
$$

- 分子 `(m+n-2)!` → 全体の順列数
- 分母 `(m-1)!` → D の重複を除く
- 分母 `(n-1)!` → R の重複を除く

👉 結果として **ユニークな経路数**が得られる。

---

では「経路 = 二項係数」というのを **直感的に**結びつけて説明してみます。

---

## 1. ゴールへの経路は「文字列」として表せる

ロボットの動きは

- **下 (Down, D)** を `(m-1)` 回
- **右 (Right, R)** を `(n-1)` 回

必ず行います。

したがって「経路」は次のような文字列になります：

例: $m=3, n=7$ の場合

- 下: 2 回
- 右: 6 回
- 合計 8 ステップ

つまり「D を2個、R を6個並べた文字列」

```
例1: D D R R R R R R
例2: R D R R R D R R
例3: R R R R R R D D
```

---

## 2. 経路は「どこに D を置くか」を選ぶ問題になる

全体で 8 ステップあるときに、
「そのうちどのステップを D にするか？」を決めれば経路が確定します。

- ステップ 1, 4 → D にすると → `D R R D R R R R`
- ステップ 3, 6 → D にすると → `R R D R R D R R`

👉 「どこを D にするか？」を選ぶだけで経路が一意に決まる。

---

## 3. だから「組み合わせ」になる

「8 ステップの中から 2 つを D に選ぶ」
これはまさに **組み合わせの定義**です。

$$
C(8, 2) = 28
$$

こうして「経路数 = 二項係数」が直感的に説明できます。

---

## 4. 一般化

- 全体のステップ数: $m+n-2$
- そのうち「下 (D) の位置」を $m-1$ 個選ぶ

$$
\text{経路数} = C(m+n-2, m-1)
$$

---

## 5. さらに直感を深める比喩 🧩

これは「じゃんけん大会の並び替え」と同じです。

- 8人並んでる椅子がある
- そのうち 2 人だけが「D チーム」、残りは「R チーム」
- 椅子にどう座らせるか？

というのと完全に同じ。
👉 「どの椅子に D を座らせるか」という選び方 = **組み合わせ**。

---

✅ まとめると：

- 経路は「D と R の並び」
- 並びを決めるのは「どこに D を置くか」だけ
- だから「経路数 = 二項係数」

---
