// この問題は動的プログラミング（DP）を用いて階段を上る方法の数を求める問題ですね。1歩でa段またはb段を上ることができる時、n段の階段を上る方法の数を計算します。このソリューションの解説：

// ## アルゴリズムの概要
// - **動的プログラミング（DP）**を使用して、n段の階段を上る方法の数を効率的に計算します
// - DPテーブル`dp[i]`は「i段目に到達する方法の数」を表します

// ## 計算ロジック
// 1. **初期化**：`dp[0] = 1`（0段目に到達する方法は1通り）
// 2. **状態遷移**：各段`i`について、以下の2つの方法で到達可能：
//    - `(i-a)`段目から`a`段上る：`dp[i] += dp[i-a]`
//    - `(i-b)`段目から`b`段上る：`dp[i] += dp[i-b]`

// ## 計算量
// - **時間計算量**：O(n) - 各段を1回ずつ計算
// - **空間計算量**：O(n) - DPテーブルのサイズ

// ## 入力例の確認
// 入力例1：`n=11, a=3, b=4`
// - 11段を3段ずつまたは4段ずつで上る方法
// - 可能な組み合わせ：
//   - 3+4+4 = 11
//   - 3+3+3+4 = 13（不適合）
//   - 実際には3通りの方法があることが計算されます

// このコードは効率的で、与えられた制約（n≤40）に対して十分高速に動作します。

const fs = require('fs');

/**
 * 階段を上る方法の数を動的プログラミングで計算する関数
 * @param {number} n - 上る階段の段数
 * @param {number} a - 1歩で上れる段数1
 * @param {number} b - 1歩で上れる段数2
 * @returns {number} n段の階段を上る方法の数
 */
function countStairClimbingWays(n, a, b) {
    // DPテーブルを初期化（0で埋める）
    const dp = new Array(n + 1).fill(0);

    // ベースケース：0段目に到達する方法は1通り（何もしない）
    dp[0] = 1;

    // DPテーブルを埋める
    for (let i = 1; i <= n; i++) {
        // i段目に到達する方法を計算
        // (i-a)段目からa段上る場合
        if (i >= a) {
            dp[i] += dp[i - a];
        }
        // (i-b)段目からb段上る場合
        if (i >= b) {
            dp[i] += dp[i - b];
        }
    }

    return dp[n];
}

/**
 * メイン処理関数
 * 標準入力から値を読み取り、階段を上る方法の数を計算して出力する
 */
function main() {
    // 標準入力から値を読み取る
    const input = fs.readFileSync('/dev/stdin', 'utf8').trim();
    const [n, a, b] = input.split(' ').map(Number);

    // 階段を上る方法の数を計算
    const result = countStairClimbingWays(n, a, b);

    // 結果を出力
    console.log(result);
}

// メイン処理を実行
main();
