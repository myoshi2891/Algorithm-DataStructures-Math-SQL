以下では、`mergeKLists` 関数（TypeScript関数ベース版）における **各処理の流れを図解つきでステップバイステップ解析**し、アルゴリズムの動作やパフォーマンスに関して具体的に説明します。

---

## 🧩 問題の例（Input）

```ts
lists = [
  1 → 4 → 5,
  1 → 3 → 4,
  2 → 6
]
```

### 🔄 期待される出力

```
1 → 1 → 2 → 3 → 4 → 4 → 5 → 6
```

---

## 🧠 全体処理フロー（mergeKLists）

### ステップ 1️⃣: ヒープの初期化

```ts
for (const node of lists) {
    if (node !== null) heap.push(node);
}
```

- 各リストの先頭ノードをヒープに追加
- この時点でヒープの状態は以下：

```
MinHeap:
   [1, 1, 2]
   ↑   ↑   ↑
  L1  L2  L3
```

---

### ステップ 2️⃣: ダミーノードで出力連結リストを構築

```ts
const dummy = new ListNode(0);
let current = dummy;
```

```
dummy → null
         ↑
      current
```

---

### ステップ 3️⃣: ヒープを使って最小値ノードを取り出し、出力リストに接続

```ts
while (heap.size() > 0) {
    const node = heap.pop()!;
    current.next = node;
    current = current.next;
    if (node.next !== null) {
        heap.push(node.next);
    }
}
```

---

## 📊 実際の処理ステップ例（図付き）

| ヒープ状態 | 出力リスト                        | 処理説明                                                           |
| ---------- | --------------------------------- | ------------------------------------------------------------------ |
| \[1, 1, 2] | dummy →                           | 最小値 `1(L1)` を取り出し、出力に接続。次の `4(L1)` をヒープに追加 |
| \[1, 2, 4] | dummy → 1                         | `1(L2)` を取り出し、出力に接続。次の `3(L2)` をヒープに追加        |
| \[2, 3, 4] | dummy → 1 → 1                     | `2(L3)` を取り出し、出力に接続。次の `6(L3)` をヒープに追加        |
| \[3, 4, 6] | dummy → 1 → 1 → 2                 | `3(L2)` を取り出し、出力に接続。次の `4(L2)` をヒープに追加        |
| \[4, 4, 6] | dummy → 1 → 1 → 2 → 3             | `4(L1)` を取り出し、出力に接続。次の `5(L1)` をヒープに追加        |
| \[4, 5, 6] | dummy → 1 → 1 → 2 → 3 → 4         | `4(L2)` を取り出し、出力に接続。次がないので追加なし               |
| \[5, 6]    | dummy → 1 → 1 → 2 → 3 → 4 → 4     | `5(L1)` を出力へ。次がないので追加なし                             |
| \[6]       | dummy → 1 → 1 → 2 → 3 → 4 → 4 → 5 | `6(L3)` を出力へ。次がないので終了                                 |

---

### ✅ 最終結果（出力連結リスト）

```
dummy → 1 → 1 → 2 → 3 → 4 → 4 → 5 → 6
```

`dummy.next` が返却される

---

## ⏱ 時間計算量解析

- ヒープに最大 `k` 個のノードが常に入る ⇒ 各 `push/pop` 操作は **O(log k)**
- 各ノード（合計 `N` 個）について `pop` → `next.push` 操作を行う ⇒ 合計 **N 回**

📌 **最終的な計算量：** `O(N log k)`
　`N`: 全ノード数、`k`: リストの数

---

## 📦 空間計算量解析

- ヒープには最大 `k` 要素が入る ⇒ **O(k)**
- 出力リストは既存ノードを使い回している ⇒ **追加メモリ O(1)**

---

## 💡 まとめ図

```
       Input Lists                MinHeap                  Output
   --------------------        ------------         -------------------
  L1: 1 → 4 → 5                  [1]                      dummy
  L2: 1 → 3 → 4      ─ push ─▶  [1, 1]       ─ pop ─▶   dummy → 1
  L3: 2 → 6                      [1, 1, 2]                dummy → 1 → 1
                              ↓ repeat... ↓             dummy → 1 → 1 → 2 → ...
```

---

## 🧪 テスト例：例1

```ts
lists = [[1,4,5], [1,3,4], [2,6]]
→ 出力: [1,1,2,3,4,4,5,6]
```

## ⏱ 実行目安 (LeetCode)

- 実行時間：**約 100ms 前後**
- メモリ使用量：**約 50MB**

---

さらに：

- 分割統治法 `mergeSort(lists, 0, k - 1)` を使ったバージョン（再帰）も同じ `O(N log k)` ですが、実装がやや複雑になります。必要があればこちらも解説します。
