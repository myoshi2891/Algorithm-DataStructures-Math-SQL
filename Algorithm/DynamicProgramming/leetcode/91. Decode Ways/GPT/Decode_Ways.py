# ## 1. 多角的問題分析

# ### 競技プログラミング視点

# * **最速手法**: 一列DPのローリング（`prev2, prev1` の2スカラー）で **O(n) 時間 / O(1) 追加メモリ**。
# * **判定規則**:

#   * 1桁: `'1'..'9'` のみ有効（`'0'`単独は無効）
#   * 2桁: `'10'..'26'` のみ有効（先頭0不可、`'06'` などは無効）
# * **早期終了**: 先頭が `'0'`、あるいは途中で 1桁・2桁のいずれにも当てはまらない箇所に遭遇したら即 `0` を返す。

# ### 業務開発視点

# * **可読性/保守性**: 1桁・2桁の有効判定を同一パターンで実装。境界条件（先頭、連続ゼロ等）を早期に処理。
# * **型安全性**: 引数・戻り値に明示的な型、ローカルも `int` で単型維持。
# * **エラーハンドリング**: LeetCode仕様では **非数字混入なし** が前提。堅牢化が必要な実運用では **非数字検出で 0 を返す**（または ValueError）等の方針を採用可能。

# ### Python特有考慮

# * **CPython実装最適化**:

#   * `ord(c) - 48` による整数算出（`int()`/`slice` を避けて割当・変換コストを最小化）
#   * 小さな `int` と単純な `for` に集約 → バイトコード経路が短く分岐予測に素直
# * **GIL**: CPU単発処理で並列化利益は小。アルゴリズム自体で O(n)/O(1) を達成するのが本筋。
# * **内蔵構造**: 追加構造体不要（配列DPや再帰スタックを使わない）。

# ---

# ## 2. アルゴリズム比較表

# | アプローチ                   | 時間計算量    | 空間計算量    | Python実装コスト | 可読性 | 標準ライブラリ活用              | CPython最適化 | 備考                    |
# | ----------------------- | -------- | -------- | ----------- | --- | ---------------------- | ---------- | --------------------- |
# | **方法A: 一列DPローリング（本採用）** | **O(n)** | **O(1)** | 低           | 高   | 不要                     | 適          | `prev2, prev1` の2変数のみ |
# | 方法B: 配列DP（`dp[n+1]`）    | O(n)     | O(n)     | 中           | 高   | 不要                     | 適          | 学習用途に明快だが割当増          |
# | 方法C: 再帰 + メモ化           | O(n)     | O(n)     | 中           | 中   | `functools.lru_cache`可 | 普通         | 関数呼び出し/スタック分で遅い       |

# ---

# ## 3. Python特有最適化ポイント

# * **整数演算の徹底**: `two = d0*10 + d1` で2桁値を構成し、`'10'..'26'` 判定を高速化。
# * **部分文字列生成の回避**: `s[i-1:i+1]` 等を行わず、`ord` ベースの整数で判定。
# * **早期return**: 不成立箇所を検知した時点で即終了→無駄なループを回さない。
# * **ローカル変数化**: ループ内で `prev1/prev2` を局所に閉じ、参照コストを抑える。

# ---

# ## 4. 実装（LeetCode提出用：Class形式）

# ```python
from __future__ import annotations
from typing import Final


class Solution:
    """
    Decode Ways (A-Z ←→ 1-26)
    1桁: '1'..'9' / 2桁: '10'..'26' のみ有効。'0'単独は無効。
    ローリングDPで O(n) 時間 / O(1) 追加メモリ。
    """

    def numDecodings(self, s: str) -> int:
        """
        Args:
            s: 数字のみから成る文字列（長さ 1..100）
        Returns:
            通り数（デコード不能なら 0）
        Complexity:
            Time O(n), Space O(1)
        """
        n: Final[int] = len(s)
        if n == 0:
            return 0

        # 先頭が '0' ならデコード不能
        c0: int = ord(s[0])
        if c0 < 48 or c0 > 57:  # 非数字防御（LeetCodeでは不要だが堅牢化）
            return 0
        if c0 == 48:  # '0'
            return 0

        # dp[-1]=1（空文字の基数）、dp[0]=1（先頭が1..9であることを上で保証）
        prev2: int = 1  # dp[i-2]
        prev1: int = 1  # dp[i-1]

        for i in range(1, n):
            ci: int = ord(s[i])
            if ci < 48 or ci > 57:  # 非数字防御
                return 0

            d1: int = ci - 48
            d0: int = ord(s[i - 1]) - 48

            cur: int = 0

            # 1桁（1..9）
            if d1 >= 1:
                cur += prev1

            # 2桁（10..26）
            two: int = d0 * 10 + d1
            if 10 <= two <= 26:
                cur += prev2

            if cur == 0:
                return 0  # どちらにも該当せず → デコード不能

            prev2, prev1 = prev1, cur

        return prev1


# ```

# ---

# ## 5. 検証（観点のみ／テストコード不要）

# * **基本**:

#   * `"12" → 2`（"AB", "L"）
#   * `"226" → 3`（"BZ","VF","BBF"）
#   * `"06" → 0`（先頭0で不成立）
# * **境界**:

#   * `"0" → 0`、`"10" → 1`（"J"）、`"27" → 1`（"BG" のみ）
#   * `"101" → 1`（"JA"）、`"100" → 0`、`"110" → 1`（"JK"は不可、"JT"のみ等）
# * **連続ゼロ**: `"1001" → 0`（`'00'` が無効）

# ---

# ### まとめ

# * **方法A（ローリングDP）**で最短・省メモリ・読みやすい実装。
# * CPython 3.11 での実行でも、**部分文字列割当回避**と**整数演算**により安定して高速に動作します。
