<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>背の順区間アルゴリズム - 詳細解析</title>
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
            rel="stylesheet"
        />
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
            rel="stylesheet"
        />
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
                color: #333;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
            }

            h1 {
                text-align: center;
                color: white;
                margin-bottom: 30px;
                font-size: 2.5em;
                text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            }

            .section {
                background: white;
                border-radius: 15px;
                padding: 25px;
                margin-bottom: 30px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
                transition:
                    transform 0.3s ease,
                    box-shadow 0.3s ease;
            }

            .section:hover {
                transform: translateY(-5px);
                box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
            }

            .section h2 {
                color: #4a5568;
                margin-bottom: 20px;
                border-left: 4px solid #667eea;
                padding-left: 15px;
                font-size: 1.8em;
            }

            .code-container {
                position: relative;
                margin: 20px 0;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            }

            pre[class*='language-'] {
                font-family: 'Fira Code', 'Monaco', 'Consolas', monospace !important;
                font-size: 14px;
                line-height: 1.5;
                margin: 0;
                padding: 20px;
                background: #2d3748 !important;
                border-radius: 10px;
                transition: all 0.3s ease;
            }

            pre[class*='language-']:hover {
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            }

            .line-numbers .line-numbers-rows {
                border-right: 1px solid #4a5568;
                padding-right: 10px;
                margin-right: 15px;
            }

            .visualization {
                display: flex;
                flex-wrap: wrap;
                gap: 20px;
                margin: 20px 0;
                justify-content: center;
            }

            .step-card {
                background: linear-gradient(135deg, #f6f9fc 0%, #e9f4ff 100%);
                border: 2px solid #e2e8f0;
                border-radius: 12px;
                padding: 20px;
                min-width: 300px;
                max-width: 400px;
                transition: all 0.3s ease;
                cursor: pointer;
            }

            .step-card:hover {
                border-color: #667eea;
                transform: scale(1.02);
                box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
            }

            .step-title {
                font-weight: bold;
                color: #2d3748;
                margin-bottom: 10px;
                font-size: 1.2em;
            }

            .array-visualization {
                display: flex;
                gap: 5px;
                margin: 15px 0;
                flex-wrap: wrap;
                justify-content: center;
            }

            .array-item {
                background: #4299e1;
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-weight: bold;
                min-width: 40px;
                text-align: center;
                transition: all 0.3s ease;
                cursor: pointer;
            }

            .array-item:hover {
                background: #3182ce;
                transform: translateY(-3px);
                box-shadow: 0 4px 12px rgba(66, 153, 225, 0.4);
            }

            .array-item.highlight {
                background: #f56565;
                animation: pulse 1s infinite;
            }

            .array-item.dp {
                background: #48bb78;
            }

            @keyframes pulse {
                0%,
                100% {
                    opacity: 1;
                }

                50% {
                    opacity: 0.7;
                }
            }

            .complexity-box {
                background: linear-gradient(135deg, #fef5e7 0%, #fbd38d 100%);
                border-left: 5px solid #ed8936;
                padding: 20px;
                border-radius: 8px;
                margin: 20px 0;
            }

            .algorithm-flow {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                margin: 20px 0;
            }

            .flow-step {
                background: white;
                border: 2px solid #e2e8f0;
                border-radius: 10px;
                padding: 20px;
                text-align: center;
                position: relative;
                transition: all 0.3s ease;
            }

            .flow-step:hover {
                border-color: #667eea;
                box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
            }

            .flow-step::after {
                content: '→';
                position: absolute;
                right: -15px;
                top: 50%;
                transform: translateY(-50%);
                font-size: 24px;
                color: #667eea;
            }

            .flow-step:last-child::after {
                display: none;
            }

            .interactive-demo {
                background: #f7fafc;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
            }

            .demo-controls {
                display: flex;
                gap: 10px;
                margin-bottom: 20px;
                justify-content: center;
                flex-wrap: wrap;
            }

            .demo-button {
                background: #667eea;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.3s ease;
                font-weight: bold;
            }

            .demo-button:hover {
                background: #5a67d8;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            }

            .demo-button:active {
                transform: translateY(0);
            }

            .explanation-text {
                background: #ebf8ff;
                border-left: 4px solid #3182ce;
                padding: 15px;
                margin: 15px 0;
                border-radius: 0 8px 8px 0;
            }

            @media (max-width: 768px) {
                .container {
                    padding: 10px;
                }

                .section {
                    padding: 15px;
                }

                h1 {
                    font-size: 2em;
                }

                .step-card {
                    min-width: 250px;
                }
            }
        </style>
    </head>

    <body>
        <div class="container">
            <h1>🔢 背の順区間アルゴリズム - 詳細解析</h1>

            <!-- アルゴリズム概要 -->
            <div class="section">
                <h2>📋 アルゴリズム概要</h2>
                <p>
                    このアルゴリズムは<strong>動的プログラミング（DP）</strong>を使用して、連続する身長の非減少区間の最大長を効率的に求めます。
                </p>

                <div class="algorithm-flow">
                    <div class="flow-step">
                        <h3>入力読み取り</h3>
                        <p>人数nと各人の身長を配列に格納</p>
                    </div>
                    <div class="flow-step">
                        <h3>DP初期化</h3>
                        <p>dp[1] = 1として開始</p>
                    </div>
                    <div class="flow-step">
                        <h3>DP計算</h3>
                        <p>各位置で前の人との比較を実行</p>
                    </div>
                    <div class="flow-step">
                        <h3>最大値取得</h3>
                        <p>dp配列から最大値を返す</p>
                    </div>
                </div>
            </div>

            <!-- コード表示 -->
            <div class="section">
                <h2>💻 実装コード</h2>
                <div class="code-container">
                    <pre
                        class="line-numbers"
                    ><code class="language-javascript">const fs = require('fs');

/**
 * 標準入力から文字列を読み取り、背の順区間の最長長さを計算する
 * @param {string} input - 標準入力の文字列
 * @returns {number} 背の順であるような区間のうち、最長であるものの長さ
 */
function findLongestNonDecreasingSequence(input) {
    const lines = input.trim().split('\n');
    const n = parseInt(lines[0]);
    
    // 身長データを配列に格納（1-indexedで扱うため先頭に0を追加）
    const heights = [0]; // heights[0]は使用しない
    for (let i = 1; i <= n; i++) {
        heights.push(parseInt(lines[i]));
    }
    
    // dp[i] = 人iが右端となる背の順区間の最長長さ
    const dp = new Array(n + 1);
    dp[1] = 1; // 最初の人は長さ1の区間
    
    // 動的プログラミングでdp配列を計算
    for (let i = 2; i <= n; i++) {
        if (heights[i - 1] <= heights[i]) {
            // 前の人の身長以上なら、前の区間に追加できる
            dp[i] = dp[i - 1] + 1;
        } else {
            // 前の人より身長が低いなら、新しい区間の開始
            dp[i] = 1;
        }
    }
    
    // dp配列の最大値を求める
    return Math.max(...dp.slice(1));
}

/**
 * メイン処理関数
 * 標準入力を読み取り、結果を標準出力に出力する
 */
function main() {
    try {
        // 標準入力を同期的に読み取り
        const input = fs.readFileSync('/dev/stdin', 'utf8');
        
        // 最長の背の順区間の長さを計算
        const result = findLongestNonDecreasingSequence(input);
        
        // 結果を出力
        console.log(result);
        
    } catch (error) {
        console.error('Error reading input:', error);
        process.exit(1);
    }
}

// メイン処理を実行
main();</code></pre>
                </div>
            </div>

            <!-- 具体例での動作解析 -->
            <div class="section">
                <h2>🔍 具体例での動作解析</h2>
                <div class="explanation-text">
                    <strong>入力例:</strong> n=5, 身長=[160, 178, 170, 190, 190]
                </div>

                <div class="interactive-demo">
                    <h3>ステップバイステップ実行</h3>
                    <div class="demo-controls">
                        <button class="demo-button" onclick="resetDemo()">リセット</button>
                        <button class="demo-button" onclick="nextStep()">次のステップ</button>
                        <button class="demo-button" onclick="autoPlay()">自動実行</button>
                    </div>

                    <div id="demo-content">
                        <div class="step-title">初期状態</div>
                        <div class="array-visualization" id="heights-array">
                            <div class="array-item">160</div>
                            <div class="array-item">178</div>
                            <div class="array-item">170</div>
                            <div class="array-item">190</div>
                            <div class="array-item">190</div>
                        </div>
                        <div class="array-visualization" id="dp-array">
                            <div class="array-item dp">1</div>
                            <div class="array-item dp">?</div>
                            <div class="array-item dp">?</div>
                            <div class="array-item dp">?</div>
                            <div class="array-item dp">?</div>
                        </div>
                        <div id="step-explanation">
                            <p><strong>初期化:</strong> dp[1] = 1（最初の人は長さ1の区間）</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 各処理ステップの詳細 -->
            <div class="section">
                <h2>⚙️ 各処理ステップの詳細</h2>
                <div class="visualization">
                    <div class="step-card">
                        <div class="step-title">ステップ 1: i=2 (178)</div>
                        <p><strong>比較:</strong> 160 ≤ 178 ✓</p>
                        <p><strong>処理:</strong> dp[2] = dp[1] + 1 = 2</p>
                        <p><strong>意味:</strong> 区間[1,2]が背の順（長さ2）</p>
                    </div>

                    <div class="step-card">
                        <div class="step-title">ステップ 2: i=3 (170)</div>
                        <p><strong>比較:</strong> 178 > 170 ✗</p>
                        <p><strong>処理:</strong> dp[3] = 1</p>
                        <p><strong>意味:</strong> 新しい区間開始（長さ1）</p>
                    </div>

                    <div class="step-card">
                        <div class="step-title">ステップ 3: i=4 (190)</div>
                        <p><strong>比較:</strong> 170 ≤ 190 ✓</p>
                        <p><strong>処理:</strong> dp[4] = dp[3] + 1 = 2</p>
                        <p><strong>意味:</strong> 区間[3,4]が背の順（長さ2）</p>
                    </div>

                    <div class="step-card">
                        <div class="step-title">ステップ 4: i=5 (190)</div>
                        <p><strong>比較:</strong> 190 ≤ 190 ✓</p>
                        <p><strong>処理:</strong> dp[5] = dp[4] + 1 = 3</p>
                        <p><strong>意味:</strong> 区間[3,5]が背の順（長さ3）</p>
                    </div>
                </div>
            </div>

            <!-- 計算量解析 -->
            <div class="section">
                <h2>📊 計算量解析</h2>
                <div class="complexity-box">
                    <h3>🕒 時間計算量: O(n)</h3>
                    <p>各人について一度だけ処理を行うため、線形時間で解決できます。</p>
                    <ul style="margin-top: 10px; padding-left: 20px">
                        <li>入力読み取り: O(n)</li>
                        <li>DP配列計算: O(n)</li>
                        <li>最大値取得: O(n)</li>
                        <li><strong>合計: O(n)</strong></li>
                    </ul>
                </div>

                <div
                    class="complexity-box"
                    style="
                        background: linear-gradient(135deg, #e6fffa 0%, #81e6d9 100%);
                        border-left-color: #38b2ac;
                    "
                >
                    <h3>💾 空間計算量: O(n)</h3>
                    <p>身長配列とDP配列の2つのn要素配列を使用します。</p>
                    <ul style="margin-top: 10px; padding-left: 20px">
                        <li>heights配列: O(n)</li>
                        <li>dp配列: O(n)</li>
                        <li><strong>合計: O(n)</strong></li>
                    </ul>
                </div>
            </div>

            <!-- DPの状態遷移 -->
            <div class="section">
                <h2>🔄 動的プログラミングの状態遷移</h2>
                <div class="explanation-text">
                    <strong>状態定義:</strong> dp[i] = 人iが右端となる背の順区間の最長長さ
                </div>

                <div class="code-container">
                    <pre class="line-numbers"><code class="language-javascript">// 状態遷移式
if (heights[i-1] <= heights[i]) {
    dp[i] = dp[i-1] + 1;  // 前の区間を延長
} else {
    dp[i] = 1;            // 新しい区間を開始
}</code></pre>
                </div>

                <div class="visualization">
                    <div class="step-card" style="width: 100%; max-width: none">
                        <div class="step-title">🧠 アルゴリズムの核心</div>
                        <p>
                            このアルゴリズムの美しさは、<strong>各位置で局所的な判断</strong>を行うことで、<strong>全体の最適解</strong>を求められる点にあります。
                        </p>
                        <p>
                            前の人より身長が高いか同じなら区間を延長し、低いなら新しい区間を開始する単純な規則で、すべての可能な背の順区間を効率的に探索できます。
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

        <script>
            let currentStep = 0;
            const heights = [160, 178, 170, 190, 190];
            const dpSteps = [
                { dp: [1, '?', '?', '?', '?'], explanation: '初期化: dp[1] = 1', highlight: 0 },
                {
                    dp: [1, 2, '?', '?', '?'],
                    explanation: 'i=2: 160 ≤ 178 なので dp[2] = dp[1] + 1 = 2',
                    highlight: 1,
                },
                {
                    dp: [1, 2, 1, '?', '?'],
                    explanation: 'i=3: 178 > 170 なので dp[3] = 1 (新区間開始)',
                    highlight: 2,
                },
                {
                    dp: [1, 2, 1, 2, '?'],
                    explanation: 'i=4: 170 ≤ 190 なので dp[4] = dp[3] + 1 = 2',
                    highlight: 3,
                },
                {
                    dp: [1, 2, 1, 2, 3],
                    explanation: 'i=5: 190 ≤ 190 なので dp[5] = dp[4] + 1 = 3',
                    highlight: 4,
                },
                {
                    dp: [1, 2, 1, 2, 3],
                    explanation: '完了: 最大値は 3 （区間[3,5]の長さ）',
                    highlight: -1,
                },
            ];

            function resetDemo() {
                currentStep = 0;
                updateDemo();
            }

            function nextStep() {
                if (currentStep < dpSteps.length - 1) {
                    currentStep++;
                    updateDemo();
                }
            }

            function autoPlay() {
                resetDemo();
                const interval = setInterval(() => {
                    nextStep();
                    if (currentStep >= dpSteps.length - 1) {
                        clearInterval(interval);
                    }
                }, 1500);
            }

            function updateDemo() {
                const step = dpSteps[currentStep];
                const heightsArray = document.getElementById('heights-array');
                const dpArray = document.getElementById('dp-array');
                const explanation = document.getElementById('step-explanation');

                // Clear highlights
                heightsArray.querySelectorAll('.array-item').forEach((item, index) => {
                    item.classList.remove('highlight');
                    if (index === step.highlight) {
                        item.classList.add('highlight');
                    }
                });

                // Update DP array
                dpArray.innerHTML = '';
                step.dp.forEach((value, index) => {
                    const item = document.createElement('div');
                    item.className = 'array-item dp';
                    item.textContent = value;
                    if (index === step.highlight) {
                        item.classList.add('highlight');
                    }
                    dpArray.appendChild(item);
                });

                // Update explanation
                explanation.innerHTML = `<p><strong>ステップ ${currentStep}:</strong> ${step.explanation}</p>`;
            }

            // Initialize demo
            updateDemo();
        </script>
    </body>
</html>
