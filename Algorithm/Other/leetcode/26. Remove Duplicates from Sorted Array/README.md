以下に、`removeDuplicates` 処理の **各ステップを図解しながら解析・説明**します。

---

# 🧠 問題要約

* 昇順にソートされた整数配列 `nums` が与えられる。
* 重複要素を原地（in-place）で削除。
* 最初の `k` 要素に **ユニークな値のみ**を保持。
* 残りの部分は無視してよい。
* **返すのはユニークな値の数 `k`。**

---

# ✅ コアロジックの図解と説明

## 🎯 実装中の変数

* `k`: ユニークな値を格納する「次の書き込み位置」
* `i`: 配列の走査位置（1から開始）

---

## 🧪 入力例

```python
nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
```

---

### 🔁 処理ステップの図解

#### ステップ 0: 初期化

```
nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]
         ↑
         k=1 (0番目の値は常にユニークとみなす)
```

---

#### ステップ 1: i=1

```
nums[1] == nums[0] → 重複 → スキップ
```

---

#### ステップ 2: i=2

```
nums[2] = 1 ≠ nums[0] = 0 → ユニーク → 代入
nums[1] = nums[2] → k++
↓
nums = [0, 1, 1, 1, 1, 2, 2, 3, 3, 4]
             ↑
             k=2
```

---

#### ステップ 3: i=3 → 重複 → スキップ

#### ステップ 4: i=4 → 重複 → スキップ

---

#### ステップ 5: i=5

```
nums[5] = 2 ≠ nums[1] = 1 → ユニーク → 代入
nums[2] = nums[5] → k++
↓
nums = [0, 1, 2, 1, 1, 2, 2, 3, 3, 4]
                  ↑
                  k=3
```

---

#### ステップ 6: i=6 → 重複 → スキップ

---

#### ステップ 7: i=7

```
nums[7] = 3 ≠ nums[2] = 2 → ユニーク → 代入
nums[3] = nums[7] → k++
↓
nums = [0, 1, 2, 3, 1, 2, 2, 3, 3, 4]
                       ↑
                       k=4
```

---

#### ステップ 8: i=8 → 重複 → スキップ

---

#### ステップ 9: i=9

```
nums[9] = 4 ≠ nums[3] = 3 → ユニーク → 代入
nums[4] = nums[9] → k++
↓
nums = [0, 1, 2, 3, 4, 2, 2, 3, 3, 4]
                            ↑
                            k=5
```

---

## ✅ 処理完了

```python
return k = 5
nums[:k] = [0, 1, 2, 3, 4]
```

---

# 📊 パフォーマンス解析

| 項目          | 説明                  |
| ----------- | ------------------- |
| 時間計算量       | **O(n)** → 1回の走査で完了 |
| 空間計算量       | **O(1)** → メモリ追加なし  |
| in-place 特性 | 新しい配列を使わずに更新        |
| 効率性         | リード/ライトポインタで高速      |

---

# 💡 最後に

このように `removeDuplicates()` は「**2つのポインタ（i, k）を用いた書き換えアルゴリズム**」です。
元の順序を保ちながらユニークな要素を前方に詰めることで、in-placeに重複除去を行います。

---

必要であれば、以下のような応用にも拡張可能です：

* **最大2回までの重複を許容**
* **`nums` がソートされていない場合の対応**
* **リスト内包表記を使った非in-placeバージョン（O(n) 空間）**

ご希望があればそれらの図解も可能です。
