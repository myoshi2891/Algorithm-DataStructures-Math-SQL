では、先ほどの TypeScript 実装の **`combinationSum2`** を、図を交えてかなり具体的に解析・説明します。
流れとしては

1. ソートの役割
2. 再帰（バックトラッキング）の動き
3. 重複スキップの仕組み
4. 枝刈り（early break）の効果

の順に説明します。

---

## 1. ソートの役割

例：

```
candidates = [10, 1, 2, 7, 6, 1, 5], target = 8
```

ソート後：

```
[1, 1, 2, 5, 6, 7, 10]
```

```
┌──────────────┐
│ 1  1  2  5  6  7  10 │
└──────────────┘
 ↑  ↑
 同じ値は隣接
```

**効果**

- 隣同士を比較して「同じ階層での重複スキップ」ができる
- `num > remain` の時点でそれ以降は探索不要（昇順なので break）

---

## 2. 再帰（バックトラッキング）の動き

例での探索ツリーを簡易図にすると：

```
Start: remain=8, path=[]

                []
       /    |    |     \
     1      1    2      5  ...
    /       |    |      |
 [1]       [1]  [2]    [5]
   \       /     |
   1     2      6
  /     /        \
[1,1] [1,2]     [2,6]
  |     |
  6     5
  ↓     ↓
[1,1,6] (remain=0)
[1,2,5] (remain=0)
```

**動きの流れ（例：`[1,1,6]` の場合）**

1. 最初に 1 を選択 → remain = 7
2. 次も 1 を選択（index を進める） → remain = 6
3. 次に 6 を選択 → remain = 0 → 結果に追加
4. 6 を取り除いて（pop）、次の候補へ

このように `path` 配列を push / pop しながら深さ優先探索を進めます。

---

## 3. 重複スキップの仕組み

ソート済み `[1, 1, 2, 5, 6, 7, 10]` で、

```
if (i > start && candidates[i] === candidates[i - 1]) continue;
```

が効く例：

```
start=0:
  i=0 → 候補 1   ✅
  i=1 → 候補 1   ❌ スキップ（同じ階層で前と同じ値）
```

**図で表すと：**

```
レベル0（start=0）
  ├─ i=0: 1
  ├─ i=1: 1 ← 前と同じ値かつ同階層なのでスキップ
  ├─ i=2: 2
```

これにより、同じ組み合わせが重複して出てくることを防ぎます。

---

## 4. 枝刈り（early break）の効果

`if (num > remain) break;`

ソート済みなので、もし候補が残りより大きければ、**それ以降の候補もすべて大きい** ため探索をやめます。

例：

```
remain = 5
候補 6 → 6 > 5 → break
これ以降 [7, 10] は見なくてよい
```

**図：**

```
[1, 2] remain=5
   |
   ├─ 5  → OK
   ├─ 6  → NG → break（7,10は不要）
```

これにより無駄な再帰呼び出しを減らせます。

---

## 全体の探索イメージ図

```
                []
        ┌───────┴───────────────────┐
       [1]                         [1(skip)]
    ┌───┴──────┐
  [1,1]       [1,2]
    |            |
  [1,1,6]*    [1,2,5]*
```

- `*` が target 達成
- `(skip)` は重複スキップで探索しない枝
- remain を超えた場合は break で切り捨て

---

## 処理時間・メモリ面での効果

- **ソート**：O(n log n)（n ≤ 100なのでほぼ無視できる）
- **バックトラッキング**：最悪でも組み合わせ数は 2ⁿ より少なく、枝刈りとスキップにより大幅削減
- **メモリ効率**：`path` 配列は使い回し（push/pop）、コピーは結果に追加するときだけ
