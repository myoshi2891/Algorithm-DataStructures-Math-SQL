// この問題は重複を含む配列から一意な順列を生成する問題です。バックトラッキングを使って効率的に解決します。このソリューションのポイント：

// 1. **ソート**: 配列を事前にソートすることで、同じ値の要素を隣接させます
// 2. **重複スキップ**: `nums[i] === nums[i-1] && !used[i-1]` の条件で重複順列を防ぎます
// 3. **バックトラッキング**: 各位置で全ての未使用要素を試し、条件に合わない場合は前の状態に戻ります
// 4. **メモリ効率**: `used`配列でインデックス追跡し、`current`配列は必要最小限のサイズを維持

// **計算量**：
// - 時間計算量: O(n! × n) - 最悪の場合、n!個の順列を生成し、各順列の作成にO(n)
// - 空間計算量: O(n) - 再帰スタックと補助配列用

// **重複スキップの仕組み**：
// - ソート後、同じ値の要素は連続して配置される
// - `!used[i-1]` により、同じ値の要素群で最初の要素から順番に使用することを強制
// - これにより `[1a,1b,2]` と `[1b,1a,2]` のような重複順列を防ぐ

/**
 * 重複を含む配列から一意な順列を生成する関数
 * @param {number[]} nums - 入力配列（重複要素を含む可能性がある）
 * @return {number[][]} - 一意な順列の配列
 */
function permuteUnique(nums) {
    // 結果を格納する配列
    const result = [];
    // 現在の順列を格納する配列
    const current = [];
    // 使用済み要素を追跡するフラグ配列
    const used = new Array(nums.length).fill(false);

    // ソートして同じ要素を隣接させる（重複スキップのため）
    nums.sort((a, b) => a - b);

    /**
     * バックトラッキングで順列を生成するヘルパー関数
     */
    function backtrack() {
        // 順列が完成した場合、結果に追加
        if (current.length === nums.length) {
            result.push([...current]); // 配列のコピーを作成
            return;
        }

        // 各要素を試行
        for (let i = 0; i < nums.length; i++) {
            // 既に使用済みの要素はスキップ
            if (used[i]) continue;

            // 重複要素のスキップ条件:
            // 同じ値の要素で、前の同じ値がまだ使われていない場合はスキップ
            // これにより重複順列を防ぐ
            if (i > 0 && nums[i] === nums[i - 1] && !used[i - 1]) {
                continue;
            }

            // 現在の要素を選択
            current.push(nums[i]);
            used[i] = true;

            // 再帰的に次の位置を探索
            backtrack();

            // バックトラック（選択を取り消し）
            current.pop();
            used[i] = false;
        }
    }

    // バックトラッキング開始
    backtrack();
    return result;
}
