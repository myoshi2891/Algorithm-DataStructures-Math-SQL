
---

> **「長さ N の数列 A からいくつか選んで、和をちょうど K にできるか？
> できるなら最小個数で、かつ選んだ要素を降順に並べたとき辞書順最大になるように選ぶ」**

に対して、修正版のJavaScriptコードを使って、**各処理の流れ・役割・考え方**を**図解付きで詳細に解析**します。

---

## 🧠 問題の本質：

* 単なる部分和判定問題（Subset Sum）ではなく、
  ① **和が K**、② **最小個数で**、③ **辞書順最大な列を構成**という3つの条件を同時に満たす必要があります。

---

## 🏗️ アルゴリズム全体像（構成）

```mermaid
flowchart TD
    A[入力：N, K, A[]] --> B[降順ソート]
    B --> C[DP配列 dp[0...K]を初期化]
    C --> D[各要素 a in A をループ]
    D --> E[各合計 sum (K→0) をループ]
    E --> F{dp[sum] が存在？}
    F -- いいえ --> E
    F -- はい --> G[dp[sum+a] の更新を試みる]
    G --> H{より少ない個数？または辞書順が大？}
    H -- はい --> I[更新]
    H -- いいえ --> E
    I --> E
    E --> D
    D --> J{dp[K] が存在？}
    J -- いいえ --> K[出力 -1]
    J -- はい --> L[個数と降順出力]
```

---

## 🔍 ステップごとの詳細と図解

---

### ✅ 1. 入力と降順ソート

```js
const A = input[1].split(" ").map(Number);
A.sort((a, b) => b - a);
```

#### 🔎 なぜ降順にする？

辞書順最大な数列を得るには、大きい数から使うべき。
→ 小さい数を先に選んでしまうと、「より良い構成」チャンスを逃す。

#### 例：

```
A = [1, 2, 3] → ソート後 → [3, 2, 1]
```

---

### ✅ 2. DPテーブル初期化

```js
const dp = Array(K + 1).fill(null);
dp[0] = { count: 0, list: [] };  // 和=0を作る方法（空）
```

#### 📘 意味：

* `dp[k] = { count, list }` は「和が k を作る最良の方法」を記録。
* `count`: 使用した個数（少ない方がよい）
* `list`: 使った要素列（辞書順最大を目指す）

---

### ✅ 3. 各 a ∈ A を使って dp 更新

```js
for (const a of A) {
  for (let sum = K; sum >= 0; sum--) {
    if (dp[sum] === null) continue;
    const nextSum = sum + a;
    if (nextSum > K) continue;

    const nextCount = dp[sum].count + 1;
    const nextList = [...dp[sum].list, a];
    ...
  }
}
```

---

### 🧮 DP更新の具体例（図解）

#### 入力：

```
A = [3, 2, 1]
K = 4
```

#### 初期：

```
dp[0] = {count:0, list:[]}
dp[1]～dp[4] = null
```

#### a = 3 のとき：

```
sum = 0 → nextSum = 3
→ dp[3] = {count:1, list:[3]}
```

#### a = 2 のとき：

```
sum = 0 → nextSum = 2
→ dp[2] = {count:1, list:[2]}

sum = 3 → nextSum = 5 ❌ 超過なのでスキップ
```

#### a = 1 のとき：

```
sum = 0 → nextSum = 1
→ dp[1] = {count:1, list:[1]}

sum = 2 → nextSum = 3
既に dp[3] = {count:1, list:[3]} がある
→ 新候補 = {count:2, list:[2,1]} は個数多いのでスキップ

sum = 3 → nextSum = 4
→ dp[4] = {count:2, list:[3,1]}
```

---

### ✅ 4. 更新判定の詳細条件：

```js
if (
  dp[nextSum] === null || 
  nextCount < dp[nextSum].count ||
  (nextCount === dp[nextSum].count && isLexGreater(nextList, dp[nextSum].list))
)
```

#### 🧠 これは何をしている？

1. 初めて到達 → 無条件採用
2. 個数が少ない → 採用
3. 個数が同じで辞書順が大 → 採用

#### ⚖️ 辞書順比較関数：

```js
function isLexGreater(a, b) {
  for (let i = 0; i < a.length && i < b.length; i++) {
    if (a[i] !== b[i]) return a[i] > b[i];
  }
  return a.length > b.length;
}
```

---

## 🎯 最終判定と出力

```js
if (dp[K] === null) return [-1];
return [dp[K].count, dp[K].list.sort((a, b) => b - a)];
```

### ✅ 辞書順最大にするため、出力前に降順ソート

---

## 🧪 テストケース例とDP表可視化

### 例：

A = \[3, 2, 1], K = 4

| k | dp\[k].count | dp\[k].list |
| - | ------------ | ----------- |
| 0 | 0            | \[]         |
| 1 | 1            | \[1]        |
| 2 | 1            | \[2]        |
| 3 | 1            | \[3]        |
| 4 | 2            | \[3, 1] ✅   |

出力：

```
2
3 1
```

---

## ✅ このDPの工夫のまとめ

| 工夫       | 内容                        |
| -------- | ------------------------- |
| 辞書順最大    | A を降順ソート + 更新時比較          |
| 最小個数     | dp\[k].count で制御          |
| 復元       | list に要素を追加してトラッキング       |
| オーバーラン防止 | nextSum > K を即スキップ        |
| 高速化      | K から 0 への逆ループで同一ステップ内重複防止 |

---

## 📌 総合評価（難しさ・工夫点）

| 項目     | 評価                  |
| ------ | ------------------- |
| 時間計算量  | O(N×K)              |
| メモリ計算量 | O(K×M), M:最大経路長     |
| 工夫点    | 複数条件最適化のDP更新、比較関数設計 |

---

## 📎 補足：さらなる高速化のために

* `Map` や `BitSet` を使って DP のメモリ使用量を削減
* インデックストラッキングで復元を短縮

---

ご希望あれば、この実装を **インデックス復元型 / 多重使用可型 / メモリ最小型** に書き換えることも可能です。必要に応じてお知らせください。
