# ## 1. 多角的問題分析

# ### 競技プログラミング視点

# * **目的**: 重複を含む `nums` から **重複のない** 全部分集合（パワーセット）を列挙。
# * **最速方針**: 先に昇順ソートし、各要素 `v` について

#   * **新規値**: 既存の全 subset を拡張
#   * **重複値**: **直前イテレーションで新規に追加された範囲のみ**を拡張
#     とする **反復法**。再帰/関数呼び出しのオーバーヘッドを排除。
# * **計算量**: 生成される部分集合は高々 `2^n` なので **時間 O(n·2^n)**、追加メモリは出力除き **O(1)**。

# ### 業務開発視点

# * **可読性/保守性**: ロジックは 1 本の for で完結。命名は `res`, `prev_size`, `size`, `start` など最小限で一貫。
# * **型安全性**: `List[int]` / `List[List[int]]` を明示。Pylance での補完・検査が安定。
# * **エラーハンドリング**: LeetCode の入出力前提では実行時例外は基本発生しないため、不要な検証は省略（速度優先）。

# ### Python特有考慮

# * **CPython 3.11**: list 連結（`base + [v]`）は C 実装で高速・簡潔。
# * **GIL**: 単一スレッド・CPU 集約の小問題なので影響なし。
# * **内蔵最適化**: `sort()` は Timsort（部分整列に強い）。`for` とローカル変数束縛で速度安定。

# ---

# ## 2. アルゴリズム比較表

# | アプローチ                   | 時間計算量        | 空間計算量          | Python実装コスト | 可読性 | 標準ライブラリ活用        | CPython最適化 | 備考               |
# | ----------------------- | ------------ | -------------- | ----------- | --- | ---------------- | ---------- | ---------------- |
# | 方法A: **再帰BT + 同階層スキップ** | O(n·2^n)     | O(n)           | 低           | 高   | —                | 関数呼び出し多め   | 定番・十分速い          |
# | **方法B: 反復・拡張区間限定（採用）**  | **O(n·2^n)** | **O(1)**（出力除く） | 低           | 高   | —                | 関数呼び出しゼロ   | `prev_size`で重複制御 |
# | 方法C: 頻度表（多重集合 DFS）      | O(n·2^n)     | O(n)           | 中           | 中   | `dict`/`Counter` | やや冗長       | 効果は限定的           |

# ---

# ## 3. Python特有最適化ポイント

# * **反復法**で再帰/スタック/クロージャのコストを排除。
# * **`base + [v]`** による新配列生成は C 実装で高速・簡潔。
# * ループ内の属性/グローバル参照を避け、**ローカル変数**に束縛（`res`, `arr` など）。
# * **ソート後の線形走査**のみで、分岐は軽量（重複判定）。

# ---

# ## 4. 採用アルゴリズムと根拠

# * **選択**: 方法B（反復・拡張区間限定、`prev_size` 方式）
# * **理由**: 出力量に支配される領域で、**最小オーバーヘッド**・**高い可読性**・**安定性能**を同時に満たす。
# * **トレードオフ**: 再帰実装よりコード量は同程度、ただし関数呼び出しが無い分だけ速く・安定。

# ---

# ## 5. 実装（LeetCode “Class 形式” / Pylance対応）

# ```python
from typing import List


class Solution:
    """
    Subsets II（重複要素を含む配列から重複なしの全部分集合）
    反復・拡張区間限定（prev_size）方式
    Time: O(n·2^n), Space: O(1) extra (excluding output)
    """

    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        """
        Args:
            nums: 入力整数配列（重複を含む可能性あり）

        Returns:
            すべてのユニークな部分集合（順不同）

        Complexity:
            Time: O(n·2^n)
            Space: O(1) 追加（出力除く）
        """
        # 昇順ソートで同値を隣接させる
        arr: List[int] = sorted(nums)
        res: List[List[int]] = [[]]

        # prev_size: 直前イテレーション開始時点の res の長さ
        prev_size: int = 0

        # 反復で subset を増殖
        for i, v in enumerate(arr):
            size: int = len(res)
            # 重複要素なら「前回追加分のみ」拡張、そうでなければ全体を拡張
            start: int = prev_size if i > 0 and v == arr[i - 1] else 0

            # start..size-1 の各 subset に v を付与して末尾に追加
            # Python では base + [v] が速く・明快（C 実装）
            for j in range(start, size):
                base = res[j]
                res.append(base + [v])

            # 次回用に「今回開始時点の長さ」を保存
            prev_size = size

        return res


# ```

# ---

# ## 6. 検証（観点のみ）

# * **境界**: `[]`（空配列; LeetCode では稀だが問題拡張に備え OK）、`[x]`、全要素同一、全要素異なる、最大長 `n=10`。
# * **正当性**: `nums=[1,2,2]` ⇒ `[[],[1],[1,2],[1,2,2],[2],[2,2]]`。
# * **静的解析**: すべての変数に型注釈が付き、Pylance 警告は発生しません。

# > そのまま提出可能です。必要があれば、`prev_size` をコメントで強調しておくと、レビュー時に重複排除の根拠が伝わりやすいです。
