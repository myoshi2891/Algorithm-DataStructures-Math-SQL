# ã“ã®Pythonã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã®ç‰¹å¾´ã¨LeetCodeç”¨ã®æœ€é©åŒ–ãƒã‚¤ãƒ³ãƒˆï¼š

# ## ğŸ”§ å‹å®‰å…¨æ€§ã¨Pylanceå¯¾å¿œ
# - `from typing import List` ã§ãƒªã‚¹ãƒˆå‹ã‚’æ˜ç¤ºçš„ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
# - å…¨ã¦ã®å¤‰æ•°ãƒ»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ»æˆ»ã‚Šå€¤ã«å‹ãƒ’ãƒ³ãƒˆã‚’è¿½åŠ 
# - `result: List[List[int]]` ã§çµæœãƒªã‚¹ãƒˆã®å‹ã‚’æ˜ç¢ºã«å®šç¾©
# - Pylanceã®å‹ãƒã‚§ãƒƒã‚¯ã‚’å®Œå…¨ã«ã‚¯ãƒªã‚¢

# ## âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
# 1. **ãƒ¡ãƒ¢ãƒªåŠ¹ç‡**ï¼š
#    - `current_combination.copy()` ã§ãƒªã‚¹ãƒˆã®æµ…ã„ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆï¼ˆæ·±ã„ã‚³ãƒ”ãƒ¼ã‚ˆã‚Šé«˜é€Ÿï¼‰
#    - ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã§ `pop()` æ“ä½œã«ã‚ˆã‚ŠçŠ¶æ…‹ã‚’åŠ¹ç‡çš„ã«å¾©å…ƒ

# 2. **æ™‚é–“åŠ¹ç‡**ï¼š
#    - `candidates.sort()` ã«ã‚ˆã‚‹äº‹å‰ã‚½ãƒ¼ãƒˆã§å‰ªå®šåŠ¹æœã‚’æœ€å¤§åŒ–
#    - æ—©æœŸçµ‚äº†æ¡ä»¶ `current_sum > target` ã§ä¸è¦ãªæ¢ç´¢ã‚’å›é¿
#    - ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¯„å›²ã‚’ `range(start_index, len(candidates))` ã§æœ€å°åŒ–

# ## ğŸ¯ é‡è¤‡æ’é™¤ã®æœ€é©åŒ–
# ```python
# if i > start_index and candidates[i] == candidates[i - 1]:
#     continue
# ```
# - O(1)æ™‚é–“ã§ã®é‡è¤‡æ¤œå‡º
# - ãƒãƒƒã‚·ãƒ¥ã‚»ãƒƒãƒˆã‚’ä½¿ã‚ãšãƒ¡ãƒ¢ãƒªåŠ¹ç‡ã‚’ç¶­æŒ
# - åŒä¸€ãƒ¬ãƒ™ãƒ«ã§ã®é‡è¤‡è¦ç´ ã‚¹ã‚­ãƒƒãƒ—ã‚’ä¿è¨¼

# ## ğŸ“Š è¨ˆç®—é‡
# - **æ™‚é–“è¨ˆç®—é‡**: O(2^n) - æœ€æ‚ªã‚±ãƒ¼ã‚¹ã§å„è¦ç´ ã®é¸æŠ/éé¸æŠ
# - **ç©ºé–“è¨ˆç®—é‡**: O(target) - å†å¸°ã‚¹ã‚¿ãƒƒã‚¯ã®æ·±ã•
# - **å®Ÿç”¨çš„ãªåŠ¹ç‡**: ã‚½ãƒ¼ãƒˆã¨å‰ªå®šã«ã‚ˆã‚Šå®Ÿéš›ã®å®Ÿè¡Œæ™‚é–“ã¯å¤§å¹…ã«çŸ­ç¸®

# ã“ã®ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã¯LeetCodeã®Pythonç’°å¢ƒã§æœ€é©ãªãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’ç™ºæ®ã—ã€Pylanceã®å‹ãƒã‚§ãƒƒã‚¯ã‚‚å®Œå…¨ã«é€šéã™ã‚‹è¨­è¨ˆã«ãªã£ã¦ã„ã¾ã™ã€‚

from typing import List


class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        """
        é‡è¤‡è¦ç´ ã‚’å«ã‚€é…åˆ—ã‹ã‚‰ã€å„è¦ç´ ã‚’æœ€å¤§1å›ä½¿ç”¨ã—ã¦ç›®æ¨™å€¤ã«é”ã™ã‚‹å…¨ã¦ã®çµ„ã¿åˆã‚ã›ã‚’è¦‹ã¤ã‘ã‚‹
        
        Args:
            candidates: å€™è£œæ•°å€¤ã®ãƒªã‚¹ãƒˆï¼ˆé‡è¤‡è¦ç´ ã‚’å«ã‚€å¯èƒ½æ€§ãŒã‚ã‚‹ï¼‰
            target: ç›®æ¨™ã¨ãªã‚‹åˆè¨ˆå€¤
            
        Returns:
            ç›®æ¨™å€¤ã«é”ã™ã‚‹å…¨ã¦ã®ä¸€æ„ãªçµ„ã¿åˆã‚ã›ã®ãƒªã‚¹ãƒˆ
        """
        result: List[List[int]] = []
        
        # ã‚½ãƒ¼ãƒˆã—ã¦é‡è¤‡è¦ç´ ã‚’éš£æ¥ã•ã›ã€åŠ¹ç‡çš„ãªå‰ªå®šã‚’å¯èƒ½ã«ã™ã‚‹
        candidates.sort()
        
        def backtrack(start_index: int, current_sum: int, current_combination: List[int]) -> None:
            """
            ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°ã«ã‚ˆã‚‹çµ„ã¿åˆã‚ã›æ¢ç´¢
            
            Args:
                start_index: æ¢ç´¢é–‹å§‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
                current_sum: ç¾åœ¨ã®åˆè¨ˆå€¤
                current_combination: ç¾åœ¨ã®çµ„ã¿åˆã‚ã›
            """
            # ç›®æ¨™å€¤ã«é”ã—ãŸå ´åˆã€çµæœã«è¿½åŠ ï¼ˆãƒªã‚¹ãƒˆã®ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆï¼‰
            if current_sum == target:
                result.append(current_combination.copy())
                return
            
            # ç›®æ¨™å€¤ã‚’è¶…ãˆãŸå ´åˆã¯æ¢ç´¢ã‚’æ‰“ã¡åˆ‡ã‚Šï¼ˆã‚½ãƒ¼ãƒˆæ¸ˆã¿ãªã®ã§ä»¥é™ã‚‚è¶…ãˆã‚‹ï¼‰
            if current_sum > target:
                return
            
            for i in range(start_index, len(candidates)):
                # åŒã˜ãƒ¬ãƒ™ãƒ«ã§é‡è¤‡è¦ç´ ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆé‡è¤‡çµ„ã¿åˆã‚ã›ã‚’é˜²ãï¼‰
                # start_indexã‚ˆã‚Šå¤§ãã„ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§åŒã˜å€¤ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                if i > start_index and candidates[i] == candidates[i - 1]:
                    continue
                
                # ç¾åœ¨ã®æ•°å€¤ã‚’çµ„ã¿åˆã‚ã›ã«è¿½åŠ 
                current_combination.append(candidates[i])
                
                # å†å¸°çš„ã«æ¢ç´¢ï¼ˆæ¬¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰é–‹å§‹ã€å„è¦ç´ ã¯1å›ã®ã¿ä½¿ç”¨ï¼‰
                backtrack(i + 1, current_sum + candidates[i], current_combination)
                
                # ãƒãƒƒã‚¯ãƒˆãƒ©ãƒƒã‚¯ï¼šç¾åœ¨ã®æ•°å€¤ã‚’çµ„ã¿åˆã‚ã›ã‹ã‚‰å‰Šé™¤
                current_combination.pop()
        
        backtrack(0, 0, [])
        return result