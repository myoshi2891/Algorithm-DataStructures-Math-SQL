// ## 1. 問題の分析

// ### 競技プログラミング視点での分析

// * **最速方針**: 1 パス DP。`dp[i] = (#1桁が有効 ? dp[i-1] : 0) + (#2桁が有効 ? dp[i-2] : 0)` を **O(1) メモリ**のローリング（`prev2, prev1`）で実装。
// * **無効ケース**は即時に 0 を返す（例: 先頭が `'0'`、途中で `'00'`、`'30'`、`'06'` などに遭遇）。
// * **部分文字列生成を回避**して `charCodeAt` と整数演算で判定することで一定の高速化（割当削減）。

// ### 業務開発視点での分析

// * **型安全性**: 引数は `string` のみ。戻り値 `number`。TS の型で意図を固定。
// * **可読性/保守性**: 単純な for ループと明確な条件分岐（1 桁／2 桁）に限定。
// * **エラーハンドリング**:

//   * 型は TS で担保（`s: string`）。
//   * 実行時は「数字以外を含む」入力を想定しない（LeetCode 前提）。堅牢化が必要なら **非数字検出で 0** を返すか例外にする設計も可。ここでは**問題仕様準拠**で「デコード不能＝0」を返す。

// ### TypeScript特有の考慮点

// * **型推論**: 局所変数は `number` 明確化で単型維持（V8 にも有利）。
// * **コンパイル時最適化**: 分岐と定数畳み込みが効きやすい直線コード。
// * **null 安全**: `charCodeAt` は範囲内アクセスのみ、境界は for 条件で保証。

// ---

// ## 2. アルゴリズムアプローチ比較

// | アプローチ                      | 時間計算量    | 空間計算量    | TS実装コスト | 型安全性 | 可読性 | 備考                         |
// | -------------------------- | -------- | -------- | ------- | ---- | --- | -------------------------- |
// | **方法A**: 1 行 DP ローリング（本採用） | **O(n)** | **O(1)** | 低       | 高    | 高   | `prev2/prev1` のみ使用、最速・省メモリ |
// | 方法B: DP 配列 `dp[n+1]`       | O(n)     | O(n)     | 中       | 高    | 高   | 学習用途には明快だが割当が増える           |
// | 方法C: 再帰 + メモ化              | O(n)     | O(n)     | 中       | 中    | 中   | 関数割当・スタックのオーバーヘッド          |

// ---

// ## 3. 実装方針

// * **選択したアプローチ**: 方法A（1 行 DP のローリング）
// * **理由**:

//   * **計算量**: 時間 O(n) / 追加メモリ O(1) で最適。
//   * **TS 型安全**: `string→number` の範囲で完結、型が単純で崩れにくい。
//   * **可読性**: 1 桁／2 桁の判定を一定のパターンで繰り返すだけ。
// * **TypeScript特有の最適化ポイント**:

//   * `charCodeAt(i) - 48` で数字化（`parseInt`/`Number`を避ける）。
//   * 2 桁判定は `d0 * 10 + d1` の整数演算（サブストリング割当なし）。
//   * 早期リターンでデコード不能を即座に終了。

// ---

// ## 4. 実装コード（LeetCode フォーマット／ESM想定）

// ```ts
/**
 * Decode Ways（A1..Z=1..26）: 文字列 s のデコード通り数を返す
 * - '1'..'9' は 1 桁有効
 * - '10'..'26' は 2 桁有効（'06' 等の先頭 0 は無効）
 * - デコード不能な場合は 0 を返す
 *
 * @param s - 数字のみから成る文字列（長さ 1..100）
 * @returns 通り数（32-bit 整数範囲）
 * @complexity Time: O(n), Space: O(1)
 */
function numDecodings(s: string): number {
    const n = s.length;
    if (n === 0) return 0;

    // 先頭 '0' は不可能
    const c0 = s.charCodeAt(0);
    if (c0 < 48 || c0 > 57) return 0; // 非数字の防御（LeetCodeでは不要だが堅牢化）
    if (c0 === 48) return 0;

    // dp[-1]=1（空）、dp[0]=1（先頭が1..9）
    let prev2 = 1; // dp[i-2]
    let prev1 = 1; // dp[i-1]

    for (let i = 1; i < n; i++) {
        const ci = s.charCodeAt(i);
        if (ci < 48 || ci > 57) return 0; // 非数字は不正

        const d1 = ci - 48;
        const d0 = s.charCodeAt(i - 1) - 48;

        // 現在位置の通り数
        let cur = 0;

        // 1 桁（1..9）
        if (d1 >= 1) {
            cur += prev1;
        }

        // 2 桁（10..26）
        const two = d0 * 10 + d1; // 'xy' → 10*x + y
        if (two >= 10 && two <= 26) {
            cur += prev2;
        }

        if (cur === 0) return 0; // どちらも不成立 → デコード不能

        prev2 = prev1;
        prev1 = cur;
    }

    return prev1;
}

/*
// --- ローカル ESM で使う場合（LeetCode 提出時は削除してください）---
export { numDecodings };
*/
// ```

// ---

// ## TypeScript 固有の最適化観点

// * **型安全性の活用**

//   * `s: string` を強制し、戻り値は `number` で固定。
//   * `charCodeAt` の戻り値は `number`、計算は整数演算で統一 → 単型維持。
//   * 例外ではなく**仕様に従い 0 を返す**ため、呼び出し側のエラーハンドリング負担を軽減。

// * **コンパイル時最適化**

//   * リテラル数値と単純分岐のため、デッドコード消去／分岐予測最適化の恩恵が得やすい。
//   * `readonly` 配列等は不要（副作用のないスカラー更新のみ）。

// * **開発効率と保守性**

//   * ローリング DP による定型パターンで、境界条件が明確。
//   * 早期リターンで不成立分岐を短絡化し、読みやすさと性能を両立。

// ---

// ### 補足（検証観点）

// * `numDecodings("12") === 2`（"AB", "L"）
// * `numDecodings("226") === 3`（"BZ","VF","BBF"）
// * `numDecodings("06") === 0`（先頭 0 は無効）

// 以上です。
