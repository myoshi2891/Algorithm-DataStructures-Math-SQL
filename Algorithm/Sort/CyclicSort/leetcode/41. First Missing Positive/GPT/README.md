それでは、先ほどの **TypeScript O(n) / O(1)** 解法について、
**図解付きで処理を解析** します。

---

## 1. 問題の例

例:

```text
nums = [3, 4, -1, 1]
```

目的:

- 配列に存在しない最小の正の整数を探す（この場合は 2）

---

## 2. アルゴリズムの流れ

アルゴリズムは **「値を正しい位置にスワップしていく」** という考え方です。

- 値 `x` が **1 以上 n 以下** なら、インデックス `x-1` に置く
- 既にその位置に同じ値がある場合は何もしない（無限ループ回避）
- すべての要素を処理後、**位置と値が一致していない最初のインデックス+1** が答え

---

## 3. 図解トレース

### ステップ 0（初期状態）

```
i=0, nums = [3, 4, -1, 1]
n = 4
```

---

### ステップ 1（i=0）

- `nums[0] = 3` → 範囲 \[1,4] 内
- 正しい位置は index = 3-1 = 2
- `nums[2]` と `nums[0]` をスワップ

```
swap(nums[0], nums[2])

[ -1, 4, 3, 1 ]
  ^
  i=0  → 再度 while チェック
```

---

### ステップ 1-2（i=0 続き）

- `nums[0] = -1` → 範囲外（1～4ではない） → while 終了

```
[-1, 4, 3, 1]
```

---

### ステップ 2（i=1）

- `nums[1] = 4` → 範囲 \[1,4] 内
- 正しい位置は index = 4-1 = 3
- swap(nums\[1], nums\[3])

```
[-1, 1, 3, 4]
     ^
     i=1 → 再度 while チェック
```

---

### ステップ 2-2（i=1 続き）

- `nums[1] = 1` → 範囲内、正しい位置は index = 0
- swap(nums\[1], nums\[0])

```
[1, -1, 3, 4]
    ^
    i=1 → 再度 while チェック
```

---

### ステップ 2-3（i=1 続き）

- `nums[1] = -1` → 範囲外 → while 終了

```
[1, -1, 3, 4]
```

---

### ステップ 3（i=2）

- `nums[2] = 3` → 正しい位置は index = 2
- 既に正しい位置 → 何もしない

```
[1, -1, 3, 4]
```

---

### ステップ 4（i=3）

- `nums[3] = 4` → 正しい位置は index = 3
- 既に正しい位置 → 何もしない

```
[1, -1, 3, 4]
```

---

## 4. スキャンして答えを見つける

- index 0 → nums\[0] = 1 ✔
- index 1 → nums\[1] = -1 ❌ → **答え = index+1 = 2**

---

## 5. 全体の図まとめ

```
初期:     [3, 4, -1, 1]
i=0:      [-1, 4, 3, 1]  // 3 を index=2 へ
i=1:      [-1, 1, 3, 4]  // 4 を index=3 へ
i=1続き:  [1, -1, 3, 4]  // 1 を index=0 へ
i=2:      [1, -1, 3, 4]  // 3 は正しい位置
i=3:      [1, -1, 3, 4]  // 4 は正しい位置
スキャン: index=1 で -1 → 答えは 2
```

---

## 6. 計算量解析

- **時間計算量**: 各要素は最大1回正しい位置に移動 → `O(n)`
- **空間計算量**: スワップは配列内のみで行い、追加配列を使わない → `O(1)`

---
