<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>木における最短経路探索 - BFS解説</title>

        <!-- Prism.js 修正済み: 行番号プラグインを追加 -->
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
            rel="stylesheet"
        />
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
            rel="stylesheet"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
            rel="stylesheet"
        />
        <style>
            :root {
                --primary-color: #3b82f6;
                --secondary-color: #10b981;
                --accent-color: #f59e0b;
                --background-dark: #0f172a;
                --background-light: #1e293b;
                --text-primary: #f8fafc;
                --text-secondary: #cbd5e1;
                --border-color: #334155;
                --code-bg: #1a1b26;
                --highlight-color: #fbbf2440;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family:
                    'Inter',
                    -apple-system,
                    BlinkMacSystemFont,
                    sans-serif;
                background: linear-gradient(
                    135deg,
                    var(--background-dark) 0%,
                    var(--background-light) 100%
                );
                color: var(--text-primary);
                line-height: 1.6;
                min-height: 100vh;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
                padding: 2rem;
            }

            h1 {
                font-size: 3rem;
                text-align: center;
                margin-bottom: 2rem;
                background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                font-weight: 700;
            }

            .section {
                background: rgba(30, 41, 59, 0.8);
                border-radius: 16px;
                padding: 2rem;
                margin-bottom: 2rem;
                border: 1px solid var(--border-color);
                backdrop-filter: blur(10px);
                transition:
                    transform 0.3s ease,
                    box-shadow 0.3s ease;
            }

            .section:hover {
                transform: translateY(-2px);
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            }

            .section h2 {
                color: var(--primary-color);
                margin-bottom: 1.5rem;
                font-size: 2rem;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .section h3 {
                color: var(--secondary-color);
                margin: 1.5rem 0 1rem;
                font-size: 1.5rem;
            }

            pre,
            code {
                font-family:
                    'Fira Code', 'Courier New', Consolas, 'Liberation Mono', Menlo, monospace !important;
                white-space: pre !important;
                overflow-x: auto;
                line-height: 1.5;
            }

            pre {
                padding: 1.5rem;
                background: var(--code-bg) !important;
                border-radius: 12px;
                margin: 1rem 0;
                position: relative;
                border: 1px solid var(--border-color);
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }

            /* 修正済み: Prism.js 行番号の正しい設定 */
            pre.line-numbers {
                padding-left: 3.8em;
                counter-reset: linenumber;
            }

            pre.line-numbers > code {
                position: relative;
            }

            .line-numbers .line-numbers-rows {
                position: absolute;
                pointer-events: none;
                top: 0;
                font-size: 100%;
                left: -3.8em;
                width: 3em;
                letter-spacing: -1px;
                border-right: 1px solid #999;
                user-select: none;
            }

            .line-numbers-rows > span {
                pointer-events: none;
                display: block;
                counter-increment: linenumber;
            }

            .line-numbers-rows > span:before {
                content: counter(linenumber);
                color: #999;
                display: block;
                padding-right: 0.8em;
                text-align: right;
            }

            .code-container {
                position: relative;
            }

            .copy-button {
                position: absolute;
                top: 1rem;
                right: 1rem;
                background: var(--primary-color);
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 6px;
                cursor: pointer;
                font-size: 0.875rem;
                transition: all 0.3s ease;
                z-index: 10;
            }

            .copy-button:hover {
                background: #2563eb;
                transform: scale(1.05);
            }

            .algorithm-flow {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 2rem;
                margin: 2rem 0;
            }

            .flow-step {
                background: linear-gradient(
                    135deg,
                    rgba(59, 130, 246, 0.1),
                    rgba(16, 185, 129, 0.1)
                );
                padding: 2rem;
                border-radius: 12px;
                border: 1px solid var(--border-color);
                position: relative;
                overflow: hidden;
                transition: all 0.3s ease;
            }

            .flow-step:hover {
                transform: translateY(-4px);
                box-shadow: 0 12px 24px rgba(59, 130, 246, 0.2);
            }

            .flow-step::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 4px;
                background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            }

            /* 修正済み: ステップ番号を枠内に表示 */
            .step-number {
                position: absolute;
                top: 1rem;
                left: 1rem;
                background: var(--accent-color);
                color: var(--background-dark);
                width: 2.5rem;
                height: 2.5rem;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                font-size: 1rem;
                z-index: 10;
            }

            .visualization {
                background: rgba(15, 23, 42, 0.5);
                padding: 2rem;
                border-radius: 12px;
                margin: 2rem 0;
                text-align: center;
                overflow-x: auto;
            }

            /* 修正済み: ツリーの表示領域を拡大して枠内に収める */
            .tree-diagram {
                position: relative;
                width: 600px;
                height: 350px;
                margin: 0 auto;
                border: 2px solid var(--border-color);
                border-radius: 12px;
                background: rgba(15, 23, 42, 0.3);
            }

            .node {
                width: 50px;
                height: 50px;
                border-radius: 50%;
                background: var(--primary-color);
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
                position: absolute;
                transition: all 0.3s ease;
                cursor: pointer;
                border: 3px solid transparent;
            }

            .node.start {
                background: var(--secondary-color);
                box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
            }

            .node.end {
                background: var(--accent-color);
                box-shadow: 0 0 20px rgba(245, 158, 11, 0.5);
            }

            .node.visited {
                background: #8b5cf6;
                transform: scale(1.1);
            }

            .node.path {
                background: #ef4444;
                animation: pulse 1s infinite;
                border-color: white;
            }

            @keyframes pulse {
                0%,
                100% {
                    transform: scale(1.1);
                }
                50% {
                    transform: scale(1.2);
                }
            }

            .complexity-info {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 1.5rem;
                margin: 2rem 0;
            }

            .complexity-card {
                background: rgba(59, 130, 246, 0.1);
                padding: 1.5rem;
                border-radius: 12px;
                border-left: 4px solid var(--primary-color);
                transition: all 0.3s ease;
            }

            .complexity-card:hover {
                background: rgba(59, 130, 246, 0.2);
                transform: translateX(4px);
            }

            .complexity-title {
                color: var(--primary-color);
                font-weight: bold;
                margin-bottom: 0.5rem;
                font-size: 1.1rem;
            }

            .interactive-demo {
                background: rgba(16, 185, 129, 0.1);
                padding: 2rem;
                border-radius: 12px;
                margin: 2rem 0;
            }

            .demo-controls {
                display: flex;
                justify-content: center;
                gap: 1rem;
                margin: 2rem 0;
                flex-wrap: wrap;
            }

            .demo-button {
                background: var(--primary-color);
                color: white;
                border: none;
                padding: 0.75rem 1.5rem;
                border-radius: 8px;
                cursor: pointer;
                font-size: 1rem;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .demo-button:hover {
                background: #2563eb;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            }

            .demo-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                transform: none;
            }

            .speed-control {
                display: flex;
                align-items: center;
                gap: 1rem;
                background: rgba(30, 41, 59, 0.8);
                padding: 1rem;
                border-radius: 8px;
            }

            .speed-slider {
                flex: 1;
                max-width: 200px;
            }

            @media (max-width: 768px) {
                .container {
                    padding: 1rem;
                }
                h1 {
                    font-size: 2rem;
                }
                .section {
                    padding: 1.5rem;
                }
                .algorithm-flow {
                    grid-template-columns: 1fr;
                }
                .demo-controls {
                    flex-direction: column;
                    align-items: center;
                }
                .tree-diagram {
                    width: 100%;
                    min-width: 500px;
                }
            }

            .fade-in {
                animation: fadeIn 0.8s ease-in-out;
            }

            @keyframes fadeIn {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1 class="fade-in"><i class="fas fa-sitemap"></i> 木における最短経路探索 - BFS解説</h1>

            <div class="section fade-in">
                <h2><i class="fas fa-info-circle"></i> アルゴリズム概要</h2>
                <p>
                    木構造において2つの頂点間の最短経路を求める問題です。木は閉路がないため、任意の2頂点間には唯一の経路が存在します。BFS（幅優先探索）を使用して効率的に経路を探索します。
                </p>

                <div class="complexity-info">
                    <div class="complexity-card">
                        <div class="complexity-title">時間計算量</div>
                        <div>O(n) - 全頂点を最大1回訪問</div>
                    </div>
                    <div class="complexity-card">
                        <div class="complexity-title">空間計算量</div>
                        <div>O(n) - グラフ表現とキューに必要</div>
                    </div>
                    <div class="complexity-card">
                        <div class="complexity-title">特徴</div>
                        <div>木構造では常に最短経路が一意に決まる</div>
                    </div>
                </div>
            </div>

            <div class="section fade-in">
                <h2><i class="fas fa-code"></i> 実装コード</h2>
                <div class="code-container">
                    <button class="copy-button" onclick="copyCode(this)">
                        <i class="fas fa-copy"></i> コピー
                    </button>
                    <!-- 修正済み: Prism.js行番号の正しい設定 -->
                    <pre
                        class="line-numbers"
                    ><code class="language-python">from typing import List, Dict
from collections import defaultdict, deque
import sys

class Solution:
    def shortest_path_in_tree(self, n: int, x: int, y: int, edges: List[List[int]]) -> List[int]:
        """
        木における2頂点間の最短経路を BFS で求める
        """
        if not (1 <= n <= 100000):
            raise ValueError("Invalid number of nodes")
        if not (1 <= x <= n and 1 <= y <= n and x != y):
            raise ValueError("Invalid start or end node")
        if len(edges) != n - 1:
            raise ValueError("Edges must contain exactly n-1 items")

        graph: Dict[int, List[int]] = defaultdict(list)
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)

        parent = [-1] * (n + 1)
        parent[x] = 0
        q = deque([x])

        while q:
            cur = q.popleft()
            if cur == y:
                break
            for nxt in graph[cur]:
                if parent[nxt] == -1:
                    parent[nxt] = cur
                    q.append(nxt)

        path: List[int] = []
        node = y
        while node != 0:
            path.append(node)
            if node == x:
                break
            node = parent[node]
        path.reverse()
        return path

if __name__ == "__main__":
    sys.setrecursionlimit(1 << 25)
    N, X, Y = 6, 1, 6
    edges = [[1,2],[1,3],[2,4],[2,5],[3,6]]
    solver = Solution()
    print(solver.shortest_path_in_tree(N, X, Y, edges))</code></pre>
                </div>
            </div>

            <div class="section fade-in">
                <h2><i class="fas fa-cogs"></i> アルゴリズムの動作ステップ</h2>
                <div class="algorithm-flow">
                    <div class="flow-step">
                        <div class="step-number">1</div>
                        <h3>入力検証</h3>
                        <p>
                            頂点数、始点・終点、辺の数が適切かチェックします。木構造では辺の数は必ずn-1個である必要があります。
                        </p>
                    </div>

                    <div class="flow-step">
                        <div class="step-number">2</div>
                        <h3>隣接リスト構築</h3>
                        <p>
                            与えられた辺のリストから、各頂点に接続されている隣接頂点のリストを作成します。無向グラフなので双方向に追加します。
                        </p>
                    </div>

                    <div class="flow-step">
                        <div class="step-number">3</div>
                        <h3>BFS初期化</h3>
                        <p>
                            親ノードを記録する配列とBFS用のキューを初期化します。始点から探索を開始します。
                        </p>
                    </div>

                    <div class="flow-step">
                        <div class="step-number">4</div>
                        <h3>BFS実行</h3>
                        <p>
                            キューから頂点を取り出し、その隣接頂点を探索します。未訪問の頂点があれば親を記録してキューに追加します。
                        </p>
                    </div>

                    <div class="flow-step">
                        <div class="step-number">5</div>
                        <h3>終点到達判定</h3>
                        <p>
                            現在の頂点が終点と一致した場合、BFSを終了します。木構造なので必ず終点に到達できます。
                        </p>
                    </div>

                    <div class="flow-step">
                        <div class="step-number">6</div>
                        <h3>経路復元</h3>
                        <p>
                            終点から始点まで親を辿って経路を復元し、最後に反転させて始点→終点の順序にします。
                        </p>
                    </div>
                </div>
            </div>

            <div class="section fade-in">
                <h2><i class="fas fa-play-circle"></i> インタラクティブデモ</h2>
                <div class="interactive-demo">
                    <p>下のボタンを使ってBFSの動作を段階的に確認できます。</p>

                    <div class="visualization">
                        <!-- 修正済み: ツリーグラフが枠内に収まるように調整 -->
                        <div class="tree-diagram" id="treeDiagram">
                            <!-- 動的に生成される木構造 -->
                        </div>
                    </div>

                    <div class="demo-controls">
                        <button class="demo-button" onclick="initDemo()">
                            <i class="fas fa-refresh"></i> リセット
                        </button>
                        <button class="demo-button" onclick="stepBFS()" id="stepBtn">
                            <i class="fas fa-step-forward"></i> 次のステップ
                        </button>
                        <button class="demo-button" onclick="runFullDemo()" id="autoBtn">
                            <i class="fas fa-play"></i> 自動実行
                        </button>
                        <div class="speed-control">
                            <label>速度:</label>
                            <input
                                type="range"
                                class="speed-slider"
                                min="0.5"
                                max="3"
                                step="0.1"
                                value="1"
                                id="speedSlider"
                            />
                            <span id="speedValue">1.0x</span>
                        </div>
                    </div>

                    <div
                        id="stepInfo"
                        style="
                            margin-top: 1rem;
                            padding: 1rem;
                            background: rgba(59, 130, 246, 0.1);
                            border-radius: 8px;
                            text-align: center;
                        "
                    >
                        デモを開始するには「リセット」ボタンを押してください
                    </div>
                </div>
            </div>

            <div class="section fade-in">
                <h2><i class="fas fa-lightbulb"></i> アルゴリズムの特徴と利点</h2>
                <div class="algorithm-flow">
                    <div class="flow-step">
                        <h3>木構造の特性</h3>
                        <p>
                            木は閉路がないため、任意の2頂点間に唯一の経路が存在します。これにより探索が効率的になります。
                        </p>
                    </div>

                    <div class="flow-step">
                        <h3>BFSの適用</h3>
                        <p>BFSは最短経路を保証し、親ノードの記録により経路復元が簡単になります。</p>
                    </div>

                    <div class="flow-step">
                        <h3>効率性</h3>
                        <p>各頂点を最大1回だけ訪問するため、時間計算量はO(n)と非常に効率的です。</p>
                    </div>
                </div>
            </div>
        </div>

        <script>
            let currentStep = 0;
            let bfsQueue = [];
            let visited = new Set();
            let parent = {};
            let graph = {};
            let path = [];
            let isRunning = false;

            // デモ用のサンプルグラフ
            const sampleGraph = {
                nodes: [1, 2, 3, 4, 5, 6],
                edges: [
                    [1, 2],
                    [1, 3],
                    [2, 4],
                    [2, 5],
                    [3, 6],
                ],
                start: 1,
                end: 6,
            };

            // 修正済み: リセット機能の正常化
            function initDemo() {
                currentStep = 0;
                bfsQueue = [sampleGraph.start];
                visited = new Set();
                parent = { [sampleGraph.start]: 0 };
                path = [];
                isRunning = false;

                // グラフ構築
                graph = {};
                sampleGraph.nodes.forEach((node) => {
                    graph[node] = [];
                });

                sampleGraph.edges.forEach(([a, b]) => {
                    graph[a].push(b);
                    graph[b].push(a);
                });

                renderTree();
                updateStepInfo(
                    'BFS初期化完了。始点' + sampleGraph.start + 'からキューを開始します。',
                );
                document.getElementById('stepBtn').disabled = false;
                document.getElementById('autoBtn').disabled = false;
            }

            function renderTree() {
                const diagram = document.getElementById('treeDiagram');
                diagram.innerHTML = '';

                // ノードの位置を定義（枠内に収まるように調整）
                const positions = {
                    1: { x: 280, y: 50 },
                    2: { x: 180, y: 150 },
                    3: { x: 380, y: 150 },
                    4: { x: 120, y: 250 },
                    5: { x: 240, y: 250 },
                    6: { x: 380, y: 250 },
                };

                // SVG要素を作成（枠内に収まるサイズ）
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '600');
                svg.setAttribute('height', '350');
                svg.style.position = 'absolute';
                svg.style.top = '0';
                svg.style.left = '0';

                // エッジを描画
                sampleGraph.edges.forEach(([a, b]) => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', positions[a].x);
                    line.setAttribute('y1', positions[a].y);
                    line.setAttribute('x2', positions[b].x);
                    line.setAttribute('y2', positions[b].y);
                    line.setAttribute('stroke', '#cbd5e1');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('id', `edge-${a}-${b}`);
                    svg.appendChild(line);
                });

                diagram.appendChild(svg);

                // ノードを描画
                sampleGraph.nodes.forEach((node) => {
                    const nodeDiv = document.createElement('div');
                    nodeDiv.className = 'node';
                    nodeDiv.textContent = node;
                    nodeDiv.id = `node-${node}`;
                    nodeDiv.style.position = 'absolute';
                    nodeDiv.style.left = `${positions[node].x - 25}px`;
                    nodeDiv.style.top = `${positions[node].y - 25}px`;

                    if (node === sampleGraph.start) {
                        nodeDiv.classList.add('start');
                    } else if (node === sampleGraph.end) {
                        nodeDiv.classList.add('end');
                    }

                    if (visited.has(node)) {
                        nodeDiv.classList.add('visited');
                    }

                    if (path.includes(node)) {
                        nodeDiv.classList.add('path');
                    }

                    diagram.appendChild(nodeDiv);
                });
            }

            function stepBFS() {
                if (bfsQueue.length === 0) {
                    reconstructPath();
                    return;
                }

                const current = bfsQueue.shift();
                visited.add(current);

                updateStepInfo(`現在の頂点: ${current} を処理中...`);

                if (current === sampleGraph.end) {
                    updateStepInfo(`終点 ${sampleGraph.end} に到達しました！経路を復元します。`);
                    reconstructPath();
                    return;
                }

                // 隣接頂点を探索
                graph[current].forEach((neighbor) => {
                    if (!parent.hasOwnProperty(neighbor)) {
                        parent[neighbor] = current;
                        bfsQueue.push(neighbor);
                    }
                });

                renderTree();

                if (bfsQueue.length > 0) {
                    updateStepInfo(`次の探索候補: [${bfsQueue.join(', ')}]`);
                }
            }

            function reconstructPath() {
                path = [];
                let node = sampleGraph.end;

                while (node !== 0) {
                    path.unshift(node);
                    if (node === sampleGraph.start) break;
                    node = parent[node];
                }

                renderTree();
                updateStepInfo(`最短経路が見つかりました: ${path.join(' → ')}`);
                document.getElementById('stepBtn').disabled = true;
            }

            // 修正済み: 自動実行機能の正常化
            async function runFullDemo() {
                if (isRunning) return;

                isRunning = true;
                document.getElementById('autoBtn').disabled = true;
                document.getElementById('stepBtn').disabled = true;

                const speed = parseFloat(document.getElementById('speedSlider').value);
                const delay = 1000 / speed;

                updateStepInfo('自動実行を開始します...');
                await sleep(delay);

                while (bfsQueue.length > 0 && isRunning && path.length === 0) {
                    stepBFS();
                    await sleep(delay);
                }

                isRunning = false;
                document.getElementById('autoBtn').disabled = false;
                if (path.length === 0) {
                    document.getElementById('stepBtn').disabled = false;
                }
            }

            function updateStepInfo(message) {
                document.getElementById('stepInfo').textContent = message;
            }

            function sleep(ms) {
                return new Promise((resolve) => setTimeout(resolve, ms));
            }

            function copyCode(button) {
                const codeBlock = button.nextElementSibling.querySelector('code');
                const text = codeBlock.textContent;

                navigator.clipboard.writeText(text).then(() => {
                    const originalText = button.innerHTML;
                    button.innerHTML = '<i class="fas fa-check"></i> コピー完了！';
                    setTimeout(() => {
                        button.innerHTML = originalText;
                    }, 2000);
                });
            }

            // 速度スライダーの値を表示
            document.getElementById('speedSlider').addEventListener('input', function (e) {
                document.getElementById('speedValue').textContent = e.target.value + 'x';
            });

            // ページ読み込み時にデモを初期化
            document.addEventListener('DOMContentLoaded', function () {
                // Prism.jsの初期化を待つ
                setTimeout(() => {
                    if (window.Prism) {
                        Prism.highlightAll();
                    }
                }, 100);

                initDemo();

                // フェードインアニメーションを順次実行
                const sections = document.querySelectorAll('.section');
                sections.forEach((section, index) => {
                    setTimeout(() => {
                        section.style.opacity = '0';
                        section.style.transform = 'translateY(20px)';
                        section.style.animation = `fadeIn 0.8s ease-in-out ${
                            index * 0.2
                        }s forwards`;
                    }, 100);
                });
            });
        </script>
    </body>
</html>
