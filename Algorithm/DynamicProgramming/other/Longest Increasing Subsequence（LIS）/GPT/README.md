入力例

```
5
160
178
170
190
190
```

を例にして、**アルゴリズムがどのように動作するか**を図を使ってトレース解析していきます。

---

## アルゴリズム概要

- `currentLen` = 直前までの「背の順区間」の長さ
- `maxLen` = これまでで見つかった最長の「背の順区間」の長さ

ループで **左から右に1人ずつ確認**し、

- `a[i-1] <= a[i]` → 伸ばせるので `currentLen++`
- `a[i-1] > a[i]` → 途切れるので `currentLen = 1`
  を行います。

---

## トレース図（例1）

入力配列:

```
a = [160, 178, 170, 190, 190]
```

処理の流れを表にまとめます。

| i (人の位置) | a\[i] | 直前の a\[i-1] | 判定 (a\[i-1] <= a\[i]?) | currentLen の更新         | maxLen の更新 | 図によるイメージ   |
| ------------ | ----- | -------------- | ------------------------ | ------------------------- | ------------- | ------------------ |
| 0 (人1)      | 160   | -              | -                        | currentLen = 1 (初期)     | maxLen = 1    | `160`              |
| 1 (人2)      | 178   | 160            | 160 ≤ 178 ✅             | currentLen = 2            | maxLen = 2    | `160 → 178`        |
| 2 (人3)      | 170   | 178            | 178 ≤ 170 ❌             | currentLen = 1 (リセット) | maxLen = 2    | `170` (新しい区間) |
| 3 (人4)      | 190   | 170            | 170 ≤ 190 ✅             | currentLen = 2            | maxLen = 2    | `170 → 190`        |
| 4 (人5)      | 190   | 190            | 190 ≤ 190 ✅             | currentLen = 3            | maxLen = 3    | `170 → 190 → 190`  |

---

## 図解 (ASCII でイメージ)

```
Step1: 160          (currentLen=1, maxLen=1)
Step2: 160 → 178    (currentLen=2, maxLen=2)
Step3:       170    (currentLen=1, maxLen=2)
Step4:       170 → 190    (currentLen=2, maxLen=2)
Step5:       170 → 190 → 190   (currentLen=3, maxLen=3)
```

---

## 結果

- 最長の「背の順区間」は

    ```
    [170, 190, 190]
    ```

- 長さ = **3**

---

## 計算量の解析と実行イメージ

- **時間計算量**: O(n) → 各人を一度だけ確認
- **空間計算量**: O(1) → `currentLen` と `maxLen` のみ保持

入力サイズが最大 200,000 でも

- 20万回のループ
- 定数メモリ

で済むため、Node.js でも数百ミリ秒以内に終わります。

---
