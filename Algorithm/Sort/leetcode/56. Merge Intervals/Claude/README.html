<!doctype html>
<html lang="ja">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Merge Intervals Algorithm Analysis</title>
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
            rel="stylesheet"
        />
        <link
            href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
            rel="stylesheet"
        />
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                margin: 0;
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                min-height: 100vh;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
                background: white;
                border-radius: 15px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
                overflow: hidden;
            }

            .header {
                background: linear-gradient(135deg, #2c3e50, #3498db);
                color: white;
                padding: 30px;
                text-align: center;
            }

            .header h1 {
                margin: 0;
                font-size: 2.5em;
                font-weight: 300;
            }

            .content {
                padding: 40px;
            }

            .section {
                margin-bottom: 40px;
            }

            .section h2 {
                color: #2c3e50;
                border-bottom: 3px solid #3498db;
                padding-bottom: 10px;
                margin-bottom: 20px;
            }

            /* Code styling */
            pre[class*='language-'] {
                font-family: 'Fira Code', 'Monaco', 'Consolas', monospace !important;
                font-size: 14px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
                margin: 20px 0;
                transition: transform 0.3s ease;
            }

            pre[class*='language-']:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
            }

            .line-numbers .line-numbers-rows > span:before {
                color: #666;
            }

            /* Visualization styles */
            .visualization {
                background: #f8f9fa;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
                border-left: 4px solid #3498db;
            }

            .step {
                margin: 20px 0;
                padding: 15px;
                border-radius: 8px;
                background: white;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transition: all 0.3s ease;
            }

            .step:hover {
                transform: translateX(5px);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            }

            .step h4 {
                color: #e74c3c;
                margin-top: 0;
                display: flex;
                align-items: center;
            }

            .step-number {
                background: #3498db;
                color: white;
                border-radius: 50%;
                width: 30px;
                height: 30px;
                display: flex;
                align-items: center;
                justify-content: center;
                margin-right: 10px;
                font-weight: bold;
            }

            .interval-visual {
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin: 15px 0;
            }

            .interval {
                background: #3498db;
                color: white;
                padding: 8px 12px;
                border-radius: 20px;
                font-weight: bold;
                transition: all 0.3s ease;
            }

            .interval:hover {
                transform: scale(1.1);
                background: #2980b9;
            }

            .interval.merged {
                background: #e74c3c;
            }

            .interval.current {
                background: #f39c12;
                animation: pulse 1.5s infinite;
            }

            @keyframes pulse {
                0%,
                100% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.05);
                }
            }

            .complexity-box {
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                padding: 20px;
                border-radius: 10px;
                margin: 20px 0;
            }

            .complexity-box h4 {
                margin-top: 0;
                color: #fff;
            }

            .arrow {
                font-size: 2em;
                color: #e74c3c;
                text-align: center;
                margin: 10px 0;
            }

            .interactive-demo {
                background: #ecf0f1;
                padding: 20px;
                border-radius: 10px;
                margin: 20px 0;
            }

            .demo-controls {
                text-align: center;
                margin-bottom: 20px;
            }

            button {
                background: #3498db;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                cursor: pointer;
                margin: 0 5px;
                transition: background 0.3s ease;
            }

            button:hover {
                background: #2980b9;
            }

            .timeline {
                display: flex;
                justify-content: space-between;
                align-items: center;
                background: white;
                padding: 20px;
                border-radius: 8px;
                margin: 20px 0;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            }

            .timeline-item {
                text-align: center;
                flex: 1;
            }

            .timeline-step {
                width: 40px;
                height: 40px;
                border-radius: 50%;
                background: #bdc3c7;
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                margin: 0 auto 10px;
                font-weight: bold;
                transition: all 0.3s ease;
            }

            .timeline-step.active {
                background: #3498db;
                transform: scale(1.2);
            }

            .timeline-step.completed {
                background: #27ae60;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>🔄 Merge Intervals Algorithm</h1>
                <p>区間マージアルゴリズムの詳細解析</p>
            </div>

            <div class="content">
                <!-- アルゴリズム概要 -->
                <div class="section">
                    <h2>📋 アルゴリズム概要</h2>
                    <div class="visualization">
                        <p>
                            <strong>目的:</strong>
                            重複する区間をマージして、重複のない区間リストを作成
                        </p>
                        <p><strong>戦略:</strong> ソート → 順次比較・マージ</p>
                        <p>
                            <strong>キーポイント:</strong>
                            区間の開始点でソートすることで、線形時間でのマージが可能
                        </p>
                    </div>
                </div>

                <!-- TypeScriptコード -->
                <div class="section">
                    <h2>💻 TypeScript実装</h2>
                    <pre class="line-numbers"><code class="language-typescript">/**
 * 重複する区間をマージして、重複のない区間の配列を返す
 * @param intervals - 区間の配列。各区間は[start, end]の形式
 * @returns マージされた重複のない区間の配列
 * 
 * 時間計算量: O(n log n) - ソート処理が支配的
 * 空間計算量: O(1) - 入力配列を直接変更するため（ソートを除く）
 */
function merge(intervals: number[][]): number[][] {
    // 空配列または単一要素の場合はそのまま返す
    if (intervals.length <= 1) {
        return intervals;
    }
    
    // 区間を開始点でソート
    intervals.sort((a: number[], b: number[]): number => a[0] - b[0]);
    
    // 結果を格納する配列（最初の区間から開始）
    const merged: number[][] = [intervals[0]];
    
    // 2番目の区間から順次処理
    for (let i: number = 1; i < intervals.length; i++) {
        const current: number[] = intervals[i];
        const lastMerged: number[] = merged[merged.length - 1];
        
        // 現在の区間が直前のマージ済み区間と重複している場合
        if (current[0] <= lastMerged[1]) {
            // 終了点を更新してマージ
            lastMerged[1] = Math.max(lastMerged[1], current[1]);
        } else {
            // 重複していない場合は新しい区間として追加
            merged.push(current);
        }
    }
    
    return merged;
}</code></pre>
                </div>

                <!-- ステップバイステップ解析 -->
                <div class="section">
                    <h2>📊 ステップバイステップ解析</h2>

                    <div class="interactive-demo">
                        <div class="demo-controls">
                            <h3>例: intervals = [[1,3],[2,6],[8,10],[15,18]]</h3>
                            <button onclick="showStep(0)">初期状態</button>
                            <button onclick="showStep(1)">ソート</button>
                            <button onclick="showStep(2)">処理開始</button>
                            <button onclick="showStep(3)">マージ判定</button>
                            <button onclick="showStep(4)">完了</button>
                        </div>

                        <div class="timeline">
                            <div class="timeline-item">
                                <div class="timeline-step" id="step-0">1</div>
                                <p>初期化</p>
                            </div>
                            <div class="timeline-item">
                                <div class="timeline-step" id="step-1">2</div>
                                <p>ソート</p>
                            </div>
                            <div class="timeline-item">
                                <div class="timeline-step" id="step-2">3</div>
                                <p>処理開始</p>
                            </div>
                            <div class="timeline-item">
                                <div class="timeline-step" id="step-3">4</div>
                                <p>マージ</p>
                            </div>
                            <div class="timeline-item">
                                <div class="timeline-step" id="step-4">5</div>
                                <p>完了</p>
                            </div>
                        </div>

                        <div id="step-content"></div>
                    </div>

                    <div class="step">
                        <h4><span class="step-number">1</span>初期化チェック</h4>
                        <pre
                            class="line-numbers"
                        ><code class="language-typescript">if (intervals.length <= 1) {
    return intervals;
}</code></pre>
                        <p><strong>処理:</strong> 空配列または単一要素の場合の早期リターン</p>
                        <p><strong>効果:</strong> 不要な処理を避けてパフォーマンス向上</p>
                    </div>

                    <div class="step">
                        <h4><span class="step-number">2</span>ソート処理</h4>
                        <pre
                            class="line-numbers"
                        ><code class="language-typescript">intervals.sort((a: number[], b: number[]): number => a[0] - b[0]);</code></pre>
                        <p><strong>処理:</strong> 区間を開始点で昇順ソート</p>
                        <p><strong>時間計算量:</strong> O(n log n)</p>
                        <div class="interval-visual">
                            <div>ソート前:</div>
                            <div class="interval">[1,3]</div>
                            <div class="interval">[2,6]</div>
                            <div class="interval">[8,10]</div>
                            <div class="interval">[15,18]</div>
                        </div>
                        <div class="arrow">↓</div>
                        <div class="interval-visual">
                            <div>ソート後:</div>
                            <div class="interval">[1,3]</div>
                            <div class="interval">[2,6]</div>
                            <div class="interval">[8,10]</div>
                            <div class="interval">[15,18]</div>
                        </div>
                    </div>

                    <div class="step">
                        <h4><span class="step-number">3</span>初期設定</h4>
                        <pre
                            class="line-numbers"
                        ><code class="language-typescript">const merged: number[][] = [intervals[0]];</code></pre>
                        <p><strong>処理:</strong> 最初の区間をマージ結果に追加</p>
                        <p><strong>空間計算量:</strong> O(k) - kはマージ後の区間数</p>
                        <div class="interval-visual">
                            <div>merged初期化:</div>
                            <div class="interval merged">[1,3]</div>
                        </div>
                    </div>

                    <div class="step">
                        <h4><span class="step-number">4</span>メインループ処理</h4>
                        <pre
                            class="line-numbers"
                        ><code class="language-typescript">for (let i: number = 1; i < intervals.length; i++) {
    const current: number[] = intervals[i];
    const lastMerged: number[] = merged[merged.length - 1];
    
    if (current[0] <= lastMerged[1]) {
        // マージ処理
        lastMerged[1] = Math.max(lastMerged[1], current[1]);
    } else {
        // 新規追加
        merged.push(current);
    }
}</code></pre>
                        <p>
                            <strong>重複判定条件:</strong> <code>current[0] <= lastMerged[1]</code>
                        </p>
                        <p>
                            <strong>マージ処理:</strong>
                            <code>Math.max(lastMerged[1], current[1])</code>
                        </p>
                    </div>
                </div>

                <!-- 計算量分析 -->
                <div class="section">
                    <h2>⚡ 計算量分析</h2>

                    <div class="complexity-box">
                        <h4>🕒 時間計算量: O(n log n)</h4>
                        <ul>
                            <li><strong>ソート処理:</strong> O(n log n) - 支配的な要因</li>
                            <li><strong>メインループ:</strong> O(n) - 各要素を1回ずつ処理</li>
                            <li><strong>全体:</strong> O(n log n) + O(n) = O(n log n)</li>
                        </ul>
                    </div>

                    <div class="complexity-box">
                        <h4>💾 空間計算量: O(1)</h4>
                        <ul>
                            <li>
                                <strong>入力変更:</strong> 元の配列を直接ソート（追加メモリ不要）
                            </li>
                            <li><strong>結果配列:</strong> 最悪でもO(n)、通常はより少ない</li>
                            <li><strong>補助変数:</strong> O(1) - 定数個の変数のみ</li>
                        </ul>
                    </div>
                </div>

                <!-- 最適化ポイント -->
                <div class="section">
                    <h2>🚀 最適化ポイント</h2>

                    <div class="step">
                        <h4><span class="step-number">1</span>in-place操作</h4>
                        <p>元の配列を直接変更することで、追加のメモリ使用量を最小化</p>
                    </div>

                    <div class="step">
                        <h4><span class="step-number">2</span>早期終了</h4>
                        <p>単純なケース（空配列・単一要素）の早期リターンでパフォーマンス向上</p>
                    </div>

                    <div class="step">
                        <h4><span class="step-number">3</span>効率的なマージ</h4>
                        <p>Math.maxを使用した最適な終了点更新</p>
                    </div>

                    <div class="step">
                        <h4><span class="step-number">4</span>TypeScript型安全性</h4>
                        <p>コンパイル時の型チェックでランタイムエラーを防止</p>
                    </div>
                </div>
            </div>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

        <script>
            const steps = [
                {
                    title: '初期状態',
                    content: `
                    <div class="visualization">
                        <h4>入力: intervals = [[1,3],[2,6],[8,10],[15,18]]</h4>
                        <div class="interval-visual">
                            <div class="interval">[1,3]</div>
                            <div class="interval">[2,6]</div>
                            <div class="interval">[8,10]</div>
                            <div class="interval">[15,18]</div>
                        </div>
                        <p>4つの区間が入力されています。[1,3]と[2,6]が重複しています。</p>
                    </div>
                `,
                },
                {
                    title: 'ソート実行',
                    content: `
                    <div class="visualization">
                        <h4>ソート処理: intervals.sort((a, b) => a[0] - b[0])</h4>
                        <div class="interval-visual">
                            <div class="interval">[1,3]</div>
                            <div class="interval">[2,6]</div>
                            <div class="interval">[8,10]</div>
                            <div class="interval">[15,18]</div>
                        </div>
                        <p>開始点でソート済み（この例では既にソート済み状態）</p>
                        <p><strong>時間計算量:</strong> O(n log n)</p>
                    </div>
                `,
                },
                {
                    title: '処理開始',
                    content: `
                    <div class="visualization">
                        <h4>初期化: merged = [[1,3]]</h4>
                        <div class="interval-visual">
                            <div>merged: </div>
                            <div class="interval merged">[1,3]</div>
                        </div>
                        <div class="interval-visual">
                            <div>残り: </div>
                            <div class="interval current">[2,6]</div>
                            <div class="interval">[8,10]</div>
                            <div class="interval">[15,18]</div>
                        </div>
                        <p>最初の区間をmergedに追加し、2番目から処理開始</p>
                    </div>
                `,
                },
                {
                    title: 'マージ判定・実行',
                    content: `
                    <div class="visualization">
                        <h4>重複判定: current[0] (2) <= lastMerged[1] (3) → true</h4>
                        <div class="interval-visual">
                            <div>マージ前: </div>
                            <div class="interval merged">[1,3]</div>
                            <div class="interval current">[2,6]</div>
                        </div>
                        <div class="arrow">↓</div>
                        <div class="interval-visual">
                            <div>マージ後: </div>
                            <div class="interval merged">[1,6]</div>
                        </div>
                        <p>Math.max(3, 6) = 6で終了点を更新</p>
                        <p>残りの区間[8,10]、[15,18]は重複しないため、そのまま追加</p>
                    </div>
                `,
                },
                {
                    title: '処理完了',
                    content: `
                    <div class="visualization">
                        <h4>最終結果: [[1,6],[8,10],[15,18]]</h4>
                        <div class="interval-visual">
                            <div class="interval merged">[1,6]</div>
                            <div class="interval merged">[8,10]</div>
                            <div class="interval merged">[15,18]</div>
                        </div>
                        <p>✅ 4つの区間が3つにマージされました</p>
                        <p>✅ 重複する区間[1,3]と[2,6]が[1,6]に統合</p>
                        <p>✅ 全体の時間計算量: O(n log n)</p>
                    </div>
                `,
                },
            ];

            let currentStep = 0;

            function showStep(stepIndex) {
                // Reset all timeline steps
                for (let i = 0; i <= 4; i++) {
                    const stepElement = document.getElementById(`step-${i}`);
                    stepElement.classList.remove('active', 'completed');
                    if (i < stepIndex) {
                        stepElement.classList.add('completed');
                    } else if (i === stepIndex) {
                        stepElement.classList.add('active');
                    }
                }

                // Update content
                const contentDiv = document.getElementById('step-content');
                contentDiv.innerHTML = `
                <div class="step">
                    <h4><span class="step-number">${stepIndex + 1}</span>${steps[stepIndex].title}</h4>
                    ${steps[stepIndex].content}
                </div>
            `;

                currentStep = stepIndex;
            }

            // Initialize with first step
            showStep(0);
        </script>
    </body>
</html>
