# カードクエリ 問題 — 図解付き詳細解析

**目的**: 机の上に置かれた整数カードを管理し、2種類のクエリを高速に処理する。

* クエリ1: `1 x` — 値 `x` のカードを追加（重複しない）
* クエリ2: `2 x` — 机にあるカード `v` の中で `|x - v|` の最小値を出力（カードがなければ `-1`）

以下では、配列を使う実装（先に提示した実装）を中心に、各処理を**図解**しつつ詳細に解析します。さらに、性能上の注意点と**より高速で安全な代替手法**（Treap / ブロック分割）も図を用いて説明します。

---

## 目次

1. アルゴリズム概観
2. データ構造：昇順配列（sorted array）
3. `lowerBound`（二分探索）の図解と詳細
4. 挿入（`splice`）の図解とコスト
5. クエリ2（最小差）の実行手順と図
6. メインループ（クエリ処理の流れ）
7. 計算量解析（時間・メモリ） — 定量的検討
8. 実行時計測（`process.hrtime.bigint()` 等）の使い方
9. 改善案（Treap の概念図と操作、ブロック分割法）
10. 実装上の注意点・エッジケース

---

## 1. アルゴリズム概観

実装方針（先に示した TypeScript コードの方針）:

* `cards` を**常に昇順**に保つ配列として持つ
* 追加 (クエリ1): `lowerBound(cards, x)` で挿入位置を求め `splice` で挿入
* 問い合わせ (クエリ2): `lowerBound` で位置 `pos` を求め `cards[pos]` と `cards[pos-1]` の差を比べ最小を採る（存在しなければ `-1`）

メリット: 実装がシンプルで二分探索による高速な検索（`O(log N)`）を使える。
デメリット: `splice` に要する **要素の移動**が `O(N)` になり得るため、多数の挿入があると総和が大きくなる（最悪 `O(Q^2)`）。

---

## 2. データ構造：昇順配列（sorted array）

```
cards = [  a0,  a1,  a2,  a3,  a4, ..., a_{n-1} ]  // 昇順
index   0    1    2    3    4           n-1
```

* 検索（位置特定）は二分探索で高速に行える
* 挿入は `splice` で要素を右にシフトする必要がある
* メモリ: `N` 個の数値を格納 -> 理論上は `O(N)`

---

## 3. `lowerBound`（二分探索）の図解と詳細

`lowerBound(arr, x)` は **arr の中で最初に `>= x` となる位置** を返す。

**疑似コード（再掲）**:

```ts
function lowerBound(arr: number[], x: number): number {
  let l = 0, r = arr.length;
  while (l < r) {
    const mid = (l + r) >>> 1;
    if (arr[mid] < x) l = mid + 1;
    else r = mid;
  }
  return l; // 挿入位置
}
```

### 図解（例）

配列 `cards = [10, 40]` に対して `x = 30` を探す手順:

```
初期: l=0, r=2  (配列長 = 2)
mid = (0+2)>>>1 = 1
  arr[1] = 40  >= 30 -> r = mid = 1
次:   l=0, r=1
mid = (0+1)>>>1 = 0
  arr[0] = 10  < 30 -> l = mid + 1 = 1
終:   l=1, r=1 -> ループ終了 -> return 1
```

`pos = 1` が返る — つまり `x` は `arr[0]` と `arr[1]` の間に入るべき位置。

**注**: `mid` の取り方は切り捨て右シフト `>>>1` を使っており、`(l + r) >> 1` と等価（ただしビット演算子を使うことで整数演算になる）。

---

## 4. 挿入（`splice`）の図解とコスト

`splice(pos, 0, x)` は配列 `pos` 以降の要素を右に一つずつシフトして `x` を `pos` に置く操作です。

**例**: `cards = [10, 40, 70, 100]` に `x = 50` を挿入 (`pos = 2`) の場合

```
挿入前: [10, 40, 70, 100]
インデックス: 0   1   2    3

pos = 2 に挿入 -> 70 と 100 を右へシフトして空きスロットを作る

手順:
  - allocate space at index 2
  - move arr[3] -> arr[4]
  - move arr[2] -> arr[3]
  - set arr[2] = 50

挿入後: [10, 40, 50, 70, 100]
```

**移動コスト**: 右側にある要素 `k = n - pos` 個を移動する必要がある。最悪 `pos = 0`（先頭挿入）なら `k = n` で `O(n)` のコピーが必要。

V8（Node.js の JSエンジン）は `splice` を C/C++ 側で最適化していますが、理論的には要素の移動が発生するため計算量は `O(n)`。

---

## 5. クエリ2（最小差）の実行手順と図

処理手順:

1. `pos = lowerBound(cards, x)` を求める
2. 値候補は `cards[pos]`（存在すれば）と `cards[pos-1]`（存在すれば）の最大2つ
3. それらとの絶対差の最小値が答え

**図（例）**: `cards = [10, 40, 70]`, `x = 55`

```
lowerBound -> pos = 2  (arr[2] = 70)
候補値: arr[2] = 70  -> |70 - 55| = 15
      arr[1] = 40  -> |40 - 55| = 15
答え = min(15, 15) = 15
```

**端のケース**:

* `pos === 0` -> 候補は `cards[0]` のみ
* `pos === cards.length` -> 候補は `cards[n-1]` のみ
* `cards.length === 0` -> 答えは `-1`

このためクエリ2は二分探索1回と定数回の比較で済み、**`O(log N)`**。

---

## 6. メインループ（クエリ処理の流れ）

```
for each query (t, x):
  if t == 1:
    pos = lowerBound(cards, x)
    cards.splice(pos, 0, x)   // 挿入
  else: // t == 2
    if cards.length == 0:
      output -1
    else:
      pos = lowerBound(cards, x)
      ans = +INF
      if pos < cards.length: ans = min(ans, abs(cards[pos] - x))
      if pos > 0: ans = min(ans, abs(cards[pos-1] - x))
      output ans
```

フローチャート（簡略）:

```
[入力を読む] --> [クエリ t,x]
    |-- t==1 --> [lowerBound] --> [splice insert] --> next
    |-- t==2 --> [cards empty?] --yes--> [print -1]
               |no--> [lowerBound] --> [check pos,pos-1] --> [print ans]
```

---

## 7. 計算量解析（時間・メモリ） — 定量的検討

### 時間計算量

* `lowerBound`: `O(log n)` （二分探索）
* `splice`（挿入）: 平均 `O(n)`（右の要素を移動）
* クエリ2 (問い合わせ): `O(log n)`

総合:

* 挿入回数を `M`、最終的なサイズを `N` とすると、挿入に要するコストは概ね `O( sum_{i=0..M-1} (n_i - pos_i) )`。
* 最悪ケース（毎回先頭に挿入など）では挿入コストの合計は `O(M * N)` ではなく、挿入が逐次増える場合 `O(1 + 2 + 3 + ... + N)` = `O(N^2)` となる。Q が 100,000 のときは `O(Q^2)` = 1e10 の要素移動が発生する可能性 — 1 秒の制限では現実的に厳しい。

**現実的な評価**:

* 挿入が少ない、または挿入位置が主に配列末尾（push に相当）であれば高速に動く（末尾挿入は amortized O(1)）
* しかし問題制約下（Q=100k）では「挿入が多数かつランダム」だと配列実装は TLE のリスクあり

### メモリ計算量

* 配列 `cards` に `N` 個の数 (JSでは `number`) を保持する -> **理論的には `O(N)`**。
* JS の `number` は 8 バイト（倍精度浮動小数点）で、`N=100000` の場合は原始的な数値データだけで約 `800,000` バイト (0.8 MB)。
* ただし V8 の内部表現や配列ヘッダ、ガベージコレクション、オブジェクトテーブルなどのオーバーヘッドがあり、実際には数 MB 単位での消費になる。
* `process.memoryUsage()` で取得できる `heapUsed` は実際のヒープ消費を示すので、これをモニタリングするのが実用的。

---

## 8. 実行時計測の仕方（TypeScript 実装で用いた方法）

* 実行時間: `const start = process.hrtime.bigint()` として処理開始、終了時に差分を取る。

  * `Number(end - start) / 1e6` でミリ秒に変換
* メモリ: `process.memoryUsage().heapUsed` を開始時と終了時に取って差分。

**注意**: Node.js の GC が実行されるタイミングによって `heapUsed` は振動するため、厳密な数値は変動する。

---

## 9. 改善案（配列実装の問題点を解決する手法）

### A) 平衡化された二分探索木（例: Treap = ランダム化BST） — 推奨

**概念**:

* 各ノードは `(key, priority)` を持ち、キーは BST の順序、`priority` はランダム（ヒープ性）
* 挿入は BST の探索で位置を決め `priority` を基に回転（または `split/merge`）を行い木を整える
* 期待時間 `O(log N)`（各操作）

**Treap の簡略図（挿入のイメージ）**

```
挿入前の木 (keyのみ表示):
     40
    /  \
  10    70

挿入する値 x = 50, priority = 0.4 (乱数)
BST挿入位置 -> 40 の右 -> 70 の左
一時的:
     40
    /  \
  10    70
        /
      50(p=0.4)

priorityにより回転を行い、ヒープ条件を満たすように調整 -> 最終的に木はバランスされる
```

**操作**:

* `insert(x)`: ゼロから探して node を配置 → 回転（または split/merge）で整列
* `lower_bound(x)`（または predecessor/successor）: BST の走査で `O(log N)`

Treap を用いれば、全ての操作が期待 `O(log N)` となり、**最悪でも実行時間が現実的**になります。

**実装注意**:

* TypeScript でポインタ（参照）を用いたノードオブジェクトを作る
* 乱数（`Math.random()`）を priority に用いる
* 典型的なメモリは `O(N)` ノードオブジェクト（各ノードに key, priority, left, right を持つ）

---

### B) ブロック分割（sqrt decomposition）

**アイデア**: 要素を複数の "バケツ" に分割して各バケツをソート済みで保つ。

* バケツ数 \~ sqrt(N)
* 各バケツのサイズ \~ sqrt(N)
* クエリ2: 各バケツの代表値を使って近いバケツを探し、バケツ内は二分探索 -> `O(sqrt(N) + log sqrt(N)) ≈ O(√N)`
* 挿入: ターゲットバケツに挿入（バケツ内で線形探索/挿入）→ 最悪 `O(√N)`

√N が 316 なら `Q=100000` の場合でも十分な速さを期待できる。

---

## 10. 実装上の注意点・エッジケース

* **重複**: 問題制約で "クエリ1 では既に置かれているカードが追加されない" とあるが、一般実装では `lowerBound` で既存と等しいかをチェックして重複挿入をスキップできる。
* **空集合チェック**: クエリ2 の最初に `cards.length === 0` をチェックすること（`-1` を返す）。
* **数の範囲**: `x ≤ 1e9` だが JS の `number` で表現できる（安全な整数範囲 2^53-1 より小さいため問題なし）。
* **安定性**: 大量挿入で配列実装が TLE になる点に注意。競プロで 100k だと配列挿入は危険。Treap/バケツ法を検討すべき。

---

## 付録: サンプル入力（手順追跡）

入力例:

```
5
2 30
1 10
2 30
1 40
2 30
```

手順追跡:

1. (2,30): cards = \[] -> 空 -> 出力 `-1`
2. (1,10): lowerBound(\[],10)=0 -> splice -> cards = \[10]
3. (2,30): lowerBound(\[10],30)=1 -> pos=1 -> pos==len -> only check pos-1 -> |10-30|=20 -> 出力 `20`
4. (1,40): lowerBound(\[10],40)=1 -> splice -> cards = \[10,40]
5. (2,30): lowerBound(\[10,40],30)=1 -> check arr\[1]=40 => 10, arr\[0]=10 => 20 -> 出力 `10`

出力順: `-1`, `20`, `10`

---

## まとめ（推奨）

* **少数の挿入のみ** or **挿入が末尾中心** なら昇順配列+`lowerBound` の実装は簡潔で速い。
* **挿入が多数かつランダム** なら配列挿入の `O(N)` コストがボトルネックになるため、Treap 等のバランス木を用いるのが現実的で安全。
* sqrt-decomposition（ブロック分割）も実装が比較的簡単で、配列の `O(N)` 挿入より良い性能を与え得る。

---

もしご希望なら、以下を作成します：

* TypeScript での **Treap 実装（挿入 / predecessor / successor）** とその動作図
* ブロック分割法（sqrt decomposition）の **TypeScript 実装** とベンチマーク例
