// この問題は「k番目の順列」を求める問題ですね。全ての順列を生成するのではなく、数学的なアプローチで直接k番目の順列を計算する効率的な解法を実装します。この解法の特徴と効率性について説明します：

// ## アルゴリズムの概要
// 1. **階乗の事前計算**: `(n-1)!`, `(n-2)!`, ... `1!` を配列に保存
// 2. **数学的アプローチ**: 各桁で使用する数字を直接計算
// 3. **インデックス計算**: `k ÷ (n-1)!` で最初の桁を決定
// 4. **再帰的処理**: 残りの数字と更新されたkで次の桁を処理

// ## 時間計算量とメモリ効率
// - **時間計算量**: O(n²) - 各桁でsplice操作がO(n)、これをn回実行
// - **空間計算量**: O(n) - 階乗配列とnumbers配列のみ
// - **メモリ最適化**: 全順列を生成せず、必要な順列のみを直接計算

// ## 動作例（n=4, k=9の場合）
// 1. `k=8` (0-indexed), `factorial=[1,1,2,6]`, `numbers=[1,2,3,4]`
// 2. 1桁目: `8÷6=1` → `numbers[1]=2` を選択、`k=8%6=2`
// 3. 2桁目: `2÷2=1` → `numbers[1]=3` を選択、`k=2%2=0`
// 4. 3桁目: `0÷1=0` → `numbers[0]=1` を選択、`k=0%1=0`
// 5. 4桁目: `numbers[0]=4` を選択
// 6. 結果: `"2314"`

// この解法はLeetCodeの制約（n≤9）に対して十分に高速で、メモリ使用量も最小限に抑えられています。

/**
 * k番目の順列を求める関数
 * @param {number} n - 1からnまでの数字を含む集合のサイズ
 * @param {number} k - 求めたい順列の順番（1-indexed）
 * @return {string} - k番目の順列を表す文字列
 */
function getPermutation(n, k) {
    // 階乗を事前計算（メモリ効率のため配列で保存）
    const factorial = [1];
    for (let i = 1; i < n; i++) {
        factorial[i] = factorial[i - 1] * i;
    }

    // 使用可能な数字のリスト
    const numbers = [];
    for (let i = 1; i <= n; i++) {
        numbers.push(i);
    }

    // k を 0-indexed に変換
    k--;

    let result = '';

    // 各桁を順番に決定
    for (let i = 0; i < n; i++) {
        // 現在の桁で選択すべき数字のインデックスを計算
        const index = Math.floor(k / factorial[n - 1 - i]);

        // 選択した数字を結果に追加
        result += numbers[index];

        // 使用した数字を削除
        numbers.splice(index, 1);

        // k を更新（残りの順列での位置）
        k %= factorial[n - 1 - i];
    }

    return result;
}
