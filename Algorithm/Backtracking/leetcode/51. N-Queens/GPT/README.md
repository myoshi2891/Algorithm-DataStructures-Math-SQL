# 何をしている関数か（ざっくり）

`solveNQueens(n)` は、行を 0 → n-1 の順に一行ずつ進みながら「その行に安全に置ける列」を選んでクイーンを配置し、置けなくなったら直前の行に戻って（バックトラック）別の列を試す──という探索を行います。
衝突判定は次の3つだけを見ます。

- 同じ **列**（`col`）
- 斜め ↘（**主対角線**; `row - col` が同じ）
- 斜め ↙（**副対角線**; `row + col` が同じ）

これら3つを `Set`（または真偽配列）で管理し、O(1) で「置ける／置けない」を判定します。

---

# データ構造と衝突判定の図解

## 図1: 4×4 盤の「対角線インデックス」

**主対角線 (↘): `row - col`**

```
(row-col)     c0  c1  c2  c3
           +------------------
r0         |  0  -1  -2  -3
r1         |  1   0  -1  -2
r2         |  2   1   0  -1
r3         |  3   2   1   0
```

**副対角線 (↙): `row + col`**

```
(row+col)     c0  c1  c2  c3
            +----------------
r0          |  0   1   2   3
r1          |  1   2   3   4
r2          |  2   3   4   5
r3          |  3   4   5   6
```

同じ表の値が一致しているマスは互いに斜め衝突します。
たとえば (r1, c2) と (r3, c4) は `row-col = -1` で同じ ⇒ ↘ 方向に衝突。

---

# フローチャート（バックトラッキングの流れ）

```mermaid
flowchart TD
  A[開始: row=0, 盤は'.'で初期化] --> B{row == n ?}
  B -- はい --> C[現在の盤を文字列化して results に追加] --> D[前の行へ戻る]
  B -- いいえ --> E[この row の col を 0..n-1 でループ]
  E --> F{cols/diag1/diag2 に衝突は?}
  F -- はい --> E
  F -- いいえ --> G[Q を置く & セットに登録]
  G --> H[backtrack(row+1)]
  H --> I[戻る: Q を外す & セット解除]
  I --> E
```

- `cols` … 既に使った列の集合
- `diag1` … 既に使った主対角線（`row-col`）の集合
- `diag2` … 既に使った副対角線（`row+col`）の集合

---

# 例：n=4 の探索トレース（代表パス）

ここでは「失敗して戻る（バックトラック）」→「別ルートで成功する」を 1 本見ます。
実装は列を左から順に試すと仮定します。

## ステップ0: 初期状態

```
. . . .
. . . .
. . . .
. . . .
cols={}  diag1={}  diag2={}
```

## ステップ1: row=0 に置く（c0 は後で行き詰まるので、まず失敗ルートを示します）

置いてみる: (0,0)

```
Q . . .
. . . .
. . . .
. . . .
cols={0}  diag1={0-0=0}  diag2={0+0=0}
```

## ステップ2: row=1 に置く

- c0 → 列衝突（×）
- c1 → diag1 衝突（row-col=0）（×）
- c2 → 置ける（○）
- c3 → diag2 衝突（row+col=4? → 1+3=4 は未使用。ここは○。ただし通常は左から c2 を先に試す）

c2 を試す:

```
Q . . .
. . Q .
. . . .
. . . .
cols={0,2}  diag1={0,-1}  diag2={0,3}
```

## ステップ3: row=2 に置く

- c0 → diag2 衝突（2+0=2 は未使用、OKに見えるが diag1=2-0=2 は未使用、OK。実は置けます。）
    - ただし次の行で詰むことを確認してみます。
    - ここでは「左から」を守って c0 を置く:

```
Q . . .
. . Q .
Q . . .
. . . .
cols={0,2}→{0,2,0}?（列は集合なので {0,2} のまま。※しかし同じ列 0 はすでに使用中！ここで列衝突に気づくべき）
```

列 0 は既に使っているため **c0 は不可**。やり直し。

- c1 → diag2 衝突（2+1=3 は使用済）×
- c2 → 列衝突 ×
- c3 → diag1 衝突（2-3=-1 は使用済）×

row=2 に置ける列が無い ⇒ **バックトラック**（row=1 に戻り、c2 の次、c3 を試す）

## ステップ2’（やり直し）: row=1 で c3 を試す

```
Q . . .
. . . Q
. . . .
. . . .
cols={0,3}  diag1={0,-2}  diag2={0,4}
```

## ステップ3’: row=2 に置く

- c0 → diag2: 2+0=2 未使用, diag1: 2-0=2 未使用, 列0 は使用済（×）
- c1 → 置ける（○）
- c2 → diag2=4 使用済（×）
- c3 → 列3 使用済（×）

c1 に置く:

```
Q . . .
. . . Q
. Q . .
. . . .
cols={0,3,1}  diag1={0,-2,1}  diag2={0,4,3}
```

## ステップ4: row=3 に置く

- c0 → diag1: 3-0=3 未使用, diag2: 3+0=3 使用済（×）
- c1 → 列1 使用済（×）
- c2 → 置ける（○）
- c3 → 列3 使用済（×）

c2 に置くと……

```
Q . . .
. . . Q
. Q . .
. . Q .
```

これで **行き詰まりなく row=4（=n）** に達したので **1 解が完成**。
ただしこの盤面は 4-Queens の正解では **ない** ように見える方は鋭いです！
実は row=0 の (0,0) から開始したルートでは **解は存在しません**。
上の「置けたように見える」過程は、次の行程で衝突が見つかり最終的に破綻します。
（実装では必ず厳密に `cols/diag1/diag2` を都度チェックするので、最終的に `row===n` に到達したものだけ結果に入ります。）

> ここで伝えたいポイントは **「行を進める→ダメなら戻る」** の繰り返しと、
> **列・対角線のセットだけ見れば即座に安全判定ができる** ということです。

## 成功ルート例（有名な 2 解のひとつ）

`row=0` で **c1** を選ぶと、次の配置の 1 つに到達します：

```
. Q . .
. . . Q
Q . . .
. . Q .
```

文字列表現：

```
[".Q..","...Q","Q...","..Q."]
```

もう一方の解は左右対称で：

```
..Q.
Q...
...Q
.Q..
```

---

# バックトラック時の「セット」の増減（ミニスナップショット）

例：`row=2, col=1` に置く → 戻す

```
置く前:
  cols={0,3}
  diag1={0,-2}
  diag2={0,4}

置いた直後 (row=2, col=1):
  cols={0,3,1}
  diag1={0,-2, 2-1=1}
  diag2={0,4, 2+1=3}

探索失敗で戻す:
  cols={0,3}
  diag1={0,-2}
  diag2={0,4}
```

集合の追加・削除だけで、盤面全体を走査せずに「安全か否か」を管理できます。

---

# 盤面の生成（結果の作り方）

実装では `board: string[][]` を持ち、`'Q'` を置いた/外した後、**完成時だけ** `board.map(r => r.join(''))` で `"Q"` と `"."` の文字列配列に変換して `results` にプッシュします。
生成コストは **「完成時のみ」** 支払うため効率的です。

---

# 計算量とメモリ

- **計算量**：厳密には分岐が減るものの、上界はおおむね **O(n!)**。
  セットによる O(1) 判定で大幅に枝刈りされます。
- **メモリ**：作業用は `cols/diag1/diag2` と `board` で **O(n)**（＋`board` は O(n²)）。
  ただし最終的な **解集合**（出力）は問題の性質上 **Ω(解の個数 × n)** のサイズになります（避けられません）。

---

# さらに速く・軽くしたい場合（任意）

LeetCode 実行時間やメモリをもう少し詰めたいなら、次の小技が効きます。**アルゴリズムは同じ**です。

1. **Set → boolean 配列**

- `cols: boolean[n]`
- `diag1: boolean[2n-1]` を **シフト**して使う（`index = row - col + (n-1)`）
- `diag2: boolean[2n-1]` は `index = row + col`
  → Set のハッシュコストがなくなり、一定量速く・軽くなります。

2. **board を持たず、`pos[row]=col` だけ保持**
   完成時にだけ文字列化すれば、作業メモリが **O(n)** に。

**TypeScript（高速版の参考実装）**：

```typescript
/**
 * solveNQueens（高速・省メモリ版）
 * @param n {number} 盤サイズ (1<=n<=9)
 * @returns {string[][]} 全解（各行の文字列配列）
 * 時間計算量: おおむね O(n!)（枝刈りあり）
 * 作業メモリ: O(n)（結果保存は除く）
 */
function solveNQueens(n: number): string[][] {
    const ans: string[][] = [];
    const pos: number[] = new Array(n).fill(-1); // pos[row] = col
    const colUsed: boolean[] = new Array(n).fill(false);
    const d1Used: boolean[] = new Array(2 * n - 1).fill(false); // row-col+(n-1)
    const d2Used: boolean[] = new Array(2 * n - 1).fill(false); // row+col

    const toBoard = (): string[] => pos.map((c) => '.'.repeat(c) + 'Q' + '.'.repeat(n - c - 1));

    const dfs = (row: number): void => {
        if (row === n) {
            ans.push(toBoard());
            return;
        }
        for (let c = 0; c < n; c++) {
            const i1 = row - c + (n - 1);
            const i2 = row + c;
            if (colUsed[c] || d1Used[i1] || d2Used[i2]) continue;

            pos[row] = c;
            colUsed[c] = d1Used[i1] = d2Used[i2] = true;

            dfs(row + 1);

            colUsed[c] = d1Used[i1] = d2Used[i2] = false;
            // pos[row] は上書きされるので戻し不要
        }
    };

    dfs(0);
    return ans;
}
```

- **処理時間**：`Set` 版より定数因子が小さくなるため、Node.js/LeetCode 環境で体感的に速くなります。
- **メモリ**：`board` を持たないので作業領域は O(n) に削減（結果保存は同じ）。

---

# まとめ

- 行を一つずつ進めて「安全な列」を試す。ダメなら戻って別列へ──という **バックトラッキング**。
- 安全判定は **列 / ↘(row-col) / ↙(row+col)** の 3 種だけを `Set` や真偽配列で O(1) 判定。
- 出力は完成時のみ文字列化して `results` に追加。
- さらに詰めるなら **boolean 配列 & 1D 配置配列 (`pos`)** が高速・省メモリでおすすめ。

インタラクティブ可視化の問題を修正します。アルゴリズムの実装を改善し、より正確な動作を実現します。主要な修正点を説明します：

## 🔧 修正内容

### 1. **完全なバックトラッキング実装**

- `NQueensSolver` クラスで実際のN-Queens アルゴリズムを実装
- 全てのステップを事前に生成し、正確な動作を保証

### 2. **ステップバイステップ実行**

- アルゴリズムの各段階（探索、試行、配置、バックトラック、解発見）を個別に追跡
- 実際の制約チェックと状態変化を可視化

### 3. **改善されたUI フィードバック**

- リアルタイムでの状態表示（現在の行、列、制約状況）
- ステップメッセージによる現在の処理説明
- 正確な統計情報（試行回数、バックトラック回数、発見解数）

### 4. **視覚的改善**

- クイーンを ♛ 記号で表示
- 攻撃範囲を × 記号で明示
- フローダイアグラムとの連動

### 5. **制御機能の強化**

- デモの開始/停止機能
- 手動ステップ実行
- 盤面サイズの動的変更

これで、N-Queens問題のバックトラッキングアルゴリズムが正確に動作し、各ステップでの状態変化、制約チェック、バックトラック処理を詳細に観察できるようになりました。デモを実行すると、実際のアルゴリズムの動作を段階的に確認できます。
