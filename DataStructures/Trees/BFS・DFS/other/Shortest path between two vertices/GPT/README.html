<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>木における最短経路探索 - BFS解説</title>

    <!-- Prism.js 修正済み: 行番号プラグインを追加 -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>

    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary-color: #3b82f6;
        --secondary-color: #10b981;
        --accent-color: #f59e0b;
        --background-dark: #0f172a;
        --background-light: #1e293b;
        --text-primary: #f8fafc;
        --text-secondary: #cbd5e1;
        --border-color: #334155;
        --code-bg: #1a1b26;
        --highlight-color: #fbbf2440;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
        background: linear-gradient(
          135deg,
          var(--background-dark) 0%,
          var(--background-light) 100%
        );
        color: var(--text-primary);
        line-height: 1.6;
        min-height: 100vh;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 2rem;
      }

      h1 {
        font-size: 3rem;
        text-align: center;
        margin-bottom: 2rem;
        background: linear-gradient(
          135deg,
          var(--primary-color),
          var(--secondary-color)
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-weight: 700;
      }

      .section {
        background: rgba(30, 41, 59, 0.8);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        border: 1px solid var(--border-color);
        backdrop-filter: blur(10px);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
      }

      .section:hover {
        transform: translateY(-2px);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      }

      .section h2 {
        color: var(--primary-color);
        margin-bottom: 1.5rem;
        font-size: 2rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .section h3 {
        color: var(--secondary-color);
        margin: 1.5rem 0 1rem;
        font-size: 1.5rem;
      }

      pre,
      code {
        font-family: "Fira Code", "Courier New", Consolas, "Liberation Mono",
          Menlo, monospace !important;
        white-space: pre !important;
        overflow-x: auto;
        line-height: 1.5;
      }

      pre {
        padding: 1.5rem;
        background: var(--code-bg) !important;
        border-radius: 12px;
        margin: 1rem 0;
        position: relative;
        border: 1px solid var(--border-color);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
      }

      /* 修正済み: Prism.js 行番号の正しい設定 */
      pre.line-numbers {
        padding-left: 3.8em;
        counter-reset: linenumber;
      }

      pre.line-numbers > code {
        position: relative;
      }

      .line-numbers .line-numbers-rows {
        position: absolute;
        pointer-events: none;
        top: 0;
        font-size: 100%;
        left: -3.8em;
        width: 3em;
        letter-spacing: -1px;
        border-right: 1px solid #999;
        user-select: none;
      }

      .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
      }

      .line-numbers-rows > span:before {
        content: counter(linenumber);
        color: #999;
        display: block;
        padding-right: 0.8em;
        text-align: right;
      }

      .code-container {
        position: relative;
      }

      .copy-button {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.875rem;
        transition: all 0.3s ease;
        z-index: 10;
      }

      .copy-button:hover {
        background: #2563eb;
        transform: scale(1.05);
      }

      .algorithm-flow {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 2rem;
        margin: 2rem 0;
      }

      .flow-step {
        background: linear-gradient(
          135deg,
          rgba(59, 130, 246, 0.1),
          rgba(16, 185, 129, 0.1)
        );
        padding: 2rem;
        border-radius: 12px;
        border: 1px solid var(--border-color);
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .flow-step:hover {
        transform: translateY(-4px);
        box-shadow: 0 12px 24px rgba(59, 130, 246, 0.2);
      }

      .flow-step::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: linear-gradient(
          90deg,
          var(--primary-color),
          var(--secondary-color)
        );
      }

      /* 修正済み: ステップ番号を枠内に表示 */
      .step-number {
        position: absolute;
        top: 1rem;
        left: 1rem;
        background: var(--accent-color);
        color: var(--background-dark);
        width: 2.5rem;
        height: 2.5rem;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 1rem;
        z-index: 10;
      }

      .visualization {
        background: rgba(15, 23, 42, 0.5);
        padding: 2rem;
        border-radius: 12px;
        margin: 2rem 0;
        text-align: center;
        overflow-x: auto;
      }

      /* 修正済み: ツリーの表示領域を拡大して枠内に収める */
      .tree-diagram {
        position: relative;
        width: 600px;
        height: 350px;
        margin: 0 auto;
        border: 2px solid var(--border-color);
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.3);
      }

      .node {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: var(--primary-color);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        position: absolute;
        transition: all 0.3s ease;
        cursor: pointer;
        border: 3px solid transparent;
      }

      .node.start {
        background: var(--secondary-color);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.5);
      }

      .node.end {
        background: var(--accent-color);
        box-shadow: 0 0 20px rgba(245, 158, 11, 0.5);
      }

      .node.visited {
        background: #8b5cf6;
        transform: scale(1.1);
      }

      .node.path {
        background: #ef4444;
        animation: pulse 1s infinite;
        border-color: white;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1.1);
        }
        50% {
          transform: scale(1.2);
        }
      }

      .complexity-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1.5rem;
        margin: 2rem 0;
      }

      .complexity-card {
        background: rgba(59, 130, 246, 0.1);
        padding: 1.5rem;
        border-radius: 12px;
        border-left: 4px solid var(--primary-color);
        transition: all 0.3s ease;
      }

      .complexity-card:hover {
        background: rgba(59, 130, 246, 0.2);
        transform: translateX(4px);
      }

      .complexity-title {
        color: var(--primary-color);
        font-weight: bold;
        margin-bottom: 0.5rem;
        font-size: 1.1rem;
      }

      .interactive-demo {
        background: rgba(16, 185, 129, 0.1);
        padding: 2rem;
        border-radius: 12px;
        margin: 2rem 0;
      }

      .demo-controls {
        display: flex;
        justify-content: center;
        gap: 1rem;
        margin: 2rem 0;
        flex-wrap: wrap;
      }

      .demo-button {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 0.75rem 1.5rem;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1rem;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .demo-button:hover {
        background: #2563eb;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
      }

      .demo-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .speed-control {
        display: flex;
        align-items: center;
        gap: 1rem;
        background: rgba(30, 41, 59, 0.8);
        padding: 1rem;
        border-radius: 8px;
      }

      .speed-slider {
        flex: 1;
        max-width: 200px;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }
        h1 {
          font-size: 2rem;
        }
        .section {
          padding: 1.5rem;
        }
        .algorithm-flow {
          grid-template-columns: 1fr;
        }
        .demo-controls {
          flex-direction: column;
          align-items: center;
        }
        .tree-diagram {
          width: 100%;
          min-width: 500px;
        }
      }

      .fade-in {
        animation: fadeIn 0.8s ease-in-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1 class="fade-in">
        <i class="fas fa-sitemap"></i> 木における最短経路探索 - BFS解説
      </h1>

      <div class="section fade-in">
        <h2><i class="fas fa-info-circle"></i> アルゴリズム概要</h2>
        <p>
          木構造において2つの頂点間の最短経路を求める問題です。木は閉路がないため、任意の2頂点間には唯一の経路が存在します。BFS（幅優先探索）を使用して効率的に経路を探索します。
        </p>

        <div class="complexity-info">
          <div class="complexity-card">
            <div class="complexity-title">時間計算量</div>
            <div>O(n) - 全頂点を最大1回訪問</div>
          </div>
          <div class="complexity-card">
            <div class="complexity-title">空間計算量</div>
            <div>O(n) - グラフ表現とキューに必要</div>
          </div>
          <div class="complexity-card">
            <div class="complexity-title">特徴</div>
            <div>木構造では常に最短経路が一意に決まる</div>
          </div>
        </div>
      </div>

      <div class="section fade-in">
        <h2><i class="fas fa-code"></i> 実装コード</h2>
        <div class="code-container">
          <button class="copy-button" onclick="copyCode(this)">
            <i class="fas fa-copy"></i> コピー
          </button>
          <!-- 修正済み: Prism.js行番号の正しい設定 -->
          <pre
            class="line-numbers"
          ><code class="language-python">from typing import List, Dict
from collections import defaultdict, deque
import sys

class Solution:
    def shortest_path_in_tree(self, n: int, x: int, y: int, edges: List[List[int]]) -> List[int]:
        """
        木における2頂点間の最短経路を BFS で求める
        """
        if not (1 <= n <= 100000):
            raise ValueError("Invalid number of nodes")
        if not (1 <= x <= n and 1 <= y <= n and x != y):
            raise ValueError("Invalid start or end node")
        if len(edges) != n - 1:
            raise ValueError("Edges must contain exactly n-1 items")

        graph: Dict[int, List[int]] = defaultdict(list)
        for a, b in edges:
            graph[a].append(b)
            graph[b].append(a)

        parent = [-1] * (n + 1)
        parent[x] = 0
        q = deque([x])

        while q:
            cur = q.popleft()
            if cur == y:
                break
            for nxt in graph[cur]:
                if parent[nxt] == -1:
                    parent[nxt] = cur
                    q.append(nxt)

        path: List[int] = []
        node = y
        while node != 0:
            path.append(node)
            if node == x:
                break
            node = parent[node]
        path.reverse()
        return path

if __name__ == "__main__":
    sys.setrecursionlimit(1 << 25)
    N, X, Y = 6, 1, 6
    edges = [[1,2],[1,3],[2,4],[2,5],[3,6]]
    solver = Solution()
    print(solver.shortest_path_in_tree(N, X, Y, edges))</code></pre>
        </div>
      </div>

      <div class="section fade-in">
        <h2><i class="fas fa-cogs"></i> アルゴリズムの動作ステップ</h2>
        <div class="algorithm-flow">
          <div class="flow-step">
            <div class="step-number">1</div>
            <h3>入力検証</h3>
            <p>
              頂点数、始点・終点、辺の数が適切かチェックします。木構造では辺の数は必ずn-1個である必要があります。
            </p>
          </div>

          <div class="flow-step">
            <div class="step-number">2</div>
            <h3>隣接リスト構築</h3>
            <p>
              与えられた辺のリストから、各頂点に接続されている隣接頂点のリストを作成します。無向グラフなので双方向に追加します。
            </p>
          </div>

          <div class="flow-step">
            <div class="step-number">3</div>
            <h3>BFS初期化</h3>
            <p>
              親ノードを記録する配列とBFS用のキューを初期化します。始点から探索を開始します。
            </p>
          </div>

          <div class="flow-step">
            <div class="step-number">4</div>
            <h3>BFS実行</h3>
            <p>
              キューから頂点を取り出し、その隣接頂点を探索します。未訪問の頂点があれば親を記録してキューに追加します。
            </p>
          </div>

          <div class="flow-step">
            <div class="step-number">5</div>
            <h3>終点到達判定</h3>
            <p>
              現在の頂点が終点と一致した場合、BFSを終了します。木構造なので必ず終点に到達できます。
            </p>
          </div>

          <div class="flow-step">
            <div class="step-number">6</div>
            <h3>経路復元</h3>
            <p>
              終点から始点まで親を辿って経路を復元し、最後に反転させて始点→終点の順序にします。
            </p>
          </div>
        </div>
      </div>

      <div class="section fade-in">
        <h2><i class="fas fa-play-circle"></i> インタラクティブデモ</h2>
        <div class="interactive-demo">
          <p>下のボタンを使ってBFSの動作を段階的に確認できます。</p>

          <div class="visualization">
            <!-- 修正済み: ツリーグラフが枠内に収まるように調整 -->
            <div class="tree-diagram" id="treeDiagram">
              <!-- 動的に生成される木構造 -->
            </div>
          </div>

          <div class="demo-controls">
            <button class="demo-button" onclick="initDemo()">
              <i class="fas fa-refresh"></i> リセット
            </button>
            <button class="demo-button" onclick="stepBFS()" id="stepBtn">
              <i class="fas fa-step-forward"></i> 次のステップ
            </button>
            <button class="demo-button" onclick="runFullDemo()" id="autoBtn">
              <i class="fas fa-play"></i> 自動実行
            </button>
            <div class="speed-control">
              <label>速度:</label>
              <input
                type="range"
                class="speed-slider"
                min="0.5"
                max="3"
                step="0.1"
                value="1"
                id="speedSlider"
              />
              <span id="speedValue">1.0x</span>
            </div>
          </div>

          <div
            id="stepInfo"
            style="
              margin-top: 1rem;
              padding: 1rem;
              background: rgba(59, 130, 246, 0.1);
              border-radius: 8px;
              text-align: center;
            "
          >
            デモを開始するには「リセット」ボタンを押してください
          </div>
        </div>
      </div>

      <div class="section fade-in">
        <h2><i class="fas fa-lightbulb"></i> アルゴリズムの特徴と利点</h2>
        <div class="algorithm-flow">
          <div class="flow-step">
            <h3>木構造の特性</h3>
            <p>
              木は閉路がないため、任意の2頂点間に唯一の経路が存在します。これにより探索が効率的になります。
            </p>
          </div>

          <div class="flow-step">
            <h3>BFSの適用</h3>
            <p>
              BFSは最短経路を保証し、親ノードの記録により経路復元が簡単になります。
            </p>
          </div>

          <div class="flow-step">
            <h3>効率性</h3>
            <p>
              各頂点を最大1回だけ訪問するため、時間計算量はO(n)と非常に効率的です。
            </p>
          </div>
        </div>
      </div>
    </div>

    <script>
      let currentStep = 0;
      let bfsQueue = [];
      let visited = new Set();
      let parent = {};
      let graph = {};
      let path = [];
      let isRunning = false;

      // デモ用のサンプルグラフ
      const sampleGraph = {
        nodes: [1, 2, 3, 4, 5, 6],
        edges: [
          [1, 2],
          [1, 3],
          [2, 4],
          [2, 5],
          [3, 6],
        ],
        start: 1,
        end: 6,
      };

      // 修正済み: リセット機能の正常化
      function initDemo() {
        currentStep = 0;
        bfsQueue = [sampleGraph.start];
        visited = new Set();
        parent = { [sampleGraph.start]: 0 };
        path = [];
        isRunning = false;

        // グラフ構築
        graph = {};
        sampleGraph.nodes.forEach((node) => {
          graph[node] = [];
        });

        sampleGraph.edges.forEach(([a, b]) => {
          graph[a].push(b);
          graph[b].push(a);
        });

        renderTree();
        updateStepInfo(
          "BFS初期化完了。始点" + sampleGraph.start + "からキューを開始します。"
        );
        document.getElementById("stepBtn").disabled = false;
        document.getElementById("autoBtn").disabled = false;
      }

      function renderTree() {
        const diagram = document.getElementById("treeDiagram");
        diagram.innerHTML = "";

        // ノードの位置を定義（枠内に収まるように調整）
        const positions = {
          1: { x: 280, y: 50 },
          2: { x: 180, y: 150 },
          3: { x: 380, y: 150 },
          4: { x: 120, y: 250 },
          5: { x: 240, y: 250 },
          6: { x: 380, y: 250 },
        };

        // SVG要素を作成（枠内に収まるサイズ）
        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        svg.setAttribute("width", "600");
        svg.setAttribute("height", "350");
        svg.style.position = "absolute";
        svg.style.top = "0";
        svg.style.left = "0";

        // エッジを描画
        sampleGraph.edges.forEach(([a, b]) => {
          const line = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "line"
          );
          line.setAttribute("x1", positions[a].x);
          line.setAttribute("y1", positions[a].y);
          line.setAttribute("x2", positions[b].x);
          line.setAttribute("y2", positions[b].y);
          line.setAttribute("stroke", "#cbd5e1");
          line.setAttribute("stroke-width", "2");
          line.setAttribute("id", `edge-${a}-${b}`);
          svg.appendChild(line);
        });

        diagram.appendChild(svg);

        // ノードを描画
        sampleGraph.nodes.forEach((node) => {
          const nodeDiv = document.createElement("div");
          nodeDiv.className = "node";
          nodeDiv.textContent = node;
          nodeDiv.id = `node-${node}`;
          nodeDiv.style.position = "absolute";
          nodeDiv.style.left = `${positions[node].x - 25}px`;
          nodeDiv.style.top = `${positions[node].y - 25}px`;

          if (node === sampleGraph.start) {
            nodeDiv.classList.add("start");
          } else if (node === sampleGraph.end) {
            nodeDiv.classList.add("end");
          }

          if (visited.has(node)) {
            nodeDiv.classList.add("visited");
          }

          if (path.includes(node)) {
            nodeDiv.classList.add("path");
          }

          diagram.appendChild(nodeDiv);
        });
      }

      function stepBFS() {
        if (bfsQueue.length === 0) {
          reconstructPath();
          return;
        }

        const current = bfsQueue.shift();
        visited.add(current);

        updateStepInfo(`現在の頂点: ${current} を処理中...`);

        if (current === sampleGraph.end) {
          updateStepInfo(
            `終点 ${sampleGraph.end} に到達しました！経路を復元します。`
          );
          reconstructPath();
          return;
        }

        // 隣接頂点を探索
        graph[current].forEach((neighbor) => {
          if (!parent.hasOwnProperty(neighbor)) {
            parent[neighbor] = current;
            bfsQueue.push(neighbor);
          }
        });

        renderTree();

        if (bfsQueue.length > 0) {
          updateStepInfo(`次の探索候補: [${bfsQueue.join(", ")}]`);
        }
      }

      function reconstructPath() {
        path = [];
        let node = sampleGraph.end;

        while (node !== 0) {
          path.unshift(node);
          if (node === sampleGraph.start) break;
          node = parent[node];
        }

        renderTree();
        updateStepInfo(`最短経路が見つかりました: ${path.join(" → ")}`);
        document.getElementById("stepBtn").disabled = true;
      }

      // 修正済み: 自動実行機能の正常化
      async function runFullDemo() {
        if (isRunning) return;

        isRunning = true;
        document.getElementById("autoBtn").disabled = true;
        document.getElementById("stepBtn").disabled = true;

        const speed = parseFloat(document.getElementById("speedSlider").value);
        const delay = 1000 / speed;

        updateStepInfo("自動実行を開始します...");
        await sleep(delay);

        while (bfsQueue.length > 0 && isRunning && path.length === 0) {
          stepBFS();
          await sleep(delay);
        }

        isRunning = false;
        document.getElementById("autoBtn").disabled = false;
        if (path.length === 0) {
          document.getElementById("stepBtn").disabled = false;
        }
      }

      function updateStepInfo(message) {
        document.getElementById("stepInfo").textContent = message;
      }

      function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }

      function copyCode(button) {
        const codeBlock = button.nextElementSibling.querySelector("code");
        const text = codeBlock.textContent;

        navigator.clipboard.writeText(text).then(() => {
          const originalText = button.innerHTML;
          button.innerHTML = '<i class="fas fa-check"></i> コピー完了！';
          setTimeout(() => {
            button.innerHTML = originalText;
          }, 2000);
        });
      }

      // 速度スライダーの値を表示
      document
        .getElementById("speedSlider")
        .addEventListener("input", function (e) {
          document.getElementById("speedValue").textContent =
            e.target.value + "x";
        });

      // ページ読み込み時にデモを初期化
      document.addEventListener("DOMContentLoaded", function () {
        // Prism.jsの初期化を待つ
        setTimeout(() => {
          if (window.Prism) {
            Prism.highlightAll();
          }
        }, 100);

        initDemo();

        // フェードインアニメーションを順次実行
        const sections = document.querySelectorAll(".section");
        sections.forEach((section, index) => {
          setTimeout(() => {
            section.style.opacity = "0";
            section.style.transform = "translateY(20px)";
            section.style.animation = `fadeIn 0.8s ease-in-out ${
              index * 0.2
            }s forwards`;
          }, 100);
        });
      });
    </script>
  </body>
</html>
